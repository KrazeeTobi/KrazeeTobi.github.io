<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Prototypes and Old-Style Function Definitions</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccDeclaring_Attributes_of_Function.html">Previous</A>|<A HREF="gccCompiling_Functions_for_Interrup.html">Next</A>
<BR><FONT FACE="Futura Md BT"><FONT COLOR="#000000">&nbsp;<A NAME="off_3672671"></A><A NAME="ed1bc631"></A><B><FONT SIZE=+3>Prototypes
and old-style function definitions&nbsp;</FONT></B>&nbsp;</FONT></FONT>&nbsp;
<HR SIZE=6 WIDTH="100%">
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>GNU C extends ANSI C to
allow a function prototype to override a later old-style non-prototype
definition. Consider the following example.</FONT></FONT>
<UL>
<PRE><FONT SIZE=+1><FONT FACE="Courier New">*/ Use prototypes unless the compiler is old-fashioned. /*&nbsp;
#if __STDC__&nbsp;
#define P(x) x&nbsp;
#else&nbsp;
#define P(x) ()&nbsp;
#endif&nbsp;

/* </FONT><I><TT>Prototype function declaration.</TT></I><FONT FACE="Courier New"> */&nbsp;
int isroot P((uid_t));&nbsp;

/* </FONT><I><TT>Old-style function definition.</TT></I><FONT FACE="Courier New"> */&nbsp;
int isroot (x) /* ??? lossage here ??? */&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid_t x;&nbsp;
{&nbsp;
&nbsp;&nbsp; return x == 0;&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>Suppose the type, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>uid_t</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
happens to be </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>short</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
ANSI C does not allow this example, because subword arguments in old-style
non-prototype definitions are promoted. Therefore in this example the function
definition’s argument is really an </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>int</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
which does not match the prototype argument type of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>short</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This restriction of ANSI
C makes it hard to write code that is portable to traditional C compilers,
because the programmer does not know whether the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>uid_t</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
type is </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>short</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>int</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>long</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Therefore, in cases like
these GNU C allows a prototype to override a later old-style definition.
More precisely, in GNU C, a function prototype argument type overrides
the argument type specified by a later old-style definition if the former
type is the same as the latter type before promotion. Thus, in GNU C, the
previous example is equivalent to the following:</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>int isroot (uid_t);&nbsp;
int&nbsp;
isroot (uid_t x)&nbsp;
{&nbsp;
&nbsp;&nbsp; return x == 0;&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>GNU C++ does not support old-style
function definitions, so the previous example’s extension is irrelevant.</FONT></FONT>
<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccDeclaring_Attributes_of_Function.html">Previous</A>|<A HREF="gccCompiling_Functions_for_Interrup.html">Next</A></CENTER>

</BODY>
</HTML>
