<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Computed Variable Names</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeSubstitution_References.html">Previous</A>|<A HREF="makeHow_Variables_Get_Their_Values.html">Next</A>
<BR><A NAME="off_1213299"></A><A NAME="edbfcfa3"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>Computed
variable names</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>Computed
variable names are a complicated concept needed only for sophisticated
makefile programming. For most purposes you need not consider them, except
to know that making a variable with a dollar sign in its name might have
strange results. However, if you are the type that wants to understand
everything, or you are actually interested in what they do, read on.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Variables may be referenced
<I>inside</I> the name of a variable. This is called a <I>computed variable
name</I> or a <I>nested variable reference</I>. Consider the next example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>x =y</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>y =z</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>a := $($(x))</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example defines
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>z</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
the ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(x)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
inside ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(x))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>y</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
so ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(x))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(y)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which in turn expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>z</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
Here the name of the variable to reference is not stated explicitly; it
is computed by expansion of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(x)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
The reference, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(x)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
is nested within the outer variable reference.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example shows
two levels of nesting; however, any number of levels is possible. For example,
the following example shows three levels.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>x =y</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>y =z</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>z =u</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>a := $($($(x)))</FONT></FONT>
<BR>&nbsp;</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example shows the
innermost ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(x)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>y</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
so ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(x))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(y)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which in turn expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>z</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
now we have ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(z)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
which becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>u</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>References to recursively-expanded
variables within a variable name are reexpanded in the usual fashion. Consider
the following example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>x = $(y)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>y =z</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>z = Hello</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>a := $($(x))</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example shows
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
defined as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Hello</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(x))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(y))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(z)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Hello</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Nested variable references
can also contain modified references and function invocations (see <FONT COLOR="#008000"><A HREF="makeFunctions_for_Transforming_Text.html">Functions
for transforming text</A></FONT>), just like any other reference. For instance,
the following example uses the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>subst</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
function (see <FONT COLOR="#008000"><A HREF="makeFunctions_for_String_Substitutio.html">Functions
for string substitution and analysis</A></FONT>).</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>x = variable1</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>variable2 := Hello</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>y = $(subst 1,2,$(x))</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>z =y a := $($($(z)))</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example eventually
defines </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Hello</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
It is doubtful that anyone would ever want to write a nested reference
as convoluted as this one, but it works. ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($($(z)))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(y))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$($(subst
1,2,$(x)))</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’. This
gets the value ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>variable1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
from </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>x</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and changes it by substitution to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>variable2</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
so that the entire string becomes ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(variable2)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
a simple variable reference whose value is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Hello</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>A computed variable name
need not consist entirely of a single variable reference. It can contain
several variable references as well as some invariant text. Consider the
following example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>a_dirs := dira dirb</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>1_dirs := dir1 dir2</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>a_files := filea fileb</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>1_files := file1 file2</FONT></FONT>

<P><FONT SIZE=+0><FONT FACE="Courier New">ifeq </FONT><FONT FACE="Times New Roman">“</FONT><FONT FACE="Courier New">$(use_a)</FONT><FONT FACE="Times New Roman">”</FONT><FONT FACE="Courier New">
</FONT><FONT FACE="Times New Roman">“</FONT><FONT FACE="Courier New">yes</FONT><FONT FACE="Times New Roman">”</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>a1 := a</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>else</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>a1 := 1</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>endif</FONT></FONT>

<P><FONT SIZE=+0><FONT FACE="Courier New">ifeq </FONT><FONT FACE="Times New Roman">“</FONT><FONT FACE="Courier New">$(use_dirs)</FONT><FONT FACE="Times New Roman">”</FONT><FONT FACE="Courier New">
</FONT><FONT FACE="Times New Roman">“</FONT><FONT FACE="Courier New">yes</FONT><FONT FACE="Times New Roman">”</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>df := dirs</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>else</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>df := files</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>endif</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>dirs := $($(a1)_$(df))</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example will
give </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dirs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
the same value as </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a_dirs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>1_dirs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a_files</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>1_files</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
depending on the settings of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>use_a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>use_dirs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Computed variable names can
also be used in substitution references:</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>a_objects := a.o b.o c.o</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>1_objects := 1.o 2.o 3.o</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>sources := $($(a1)_objects:.o=.c)</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example defines
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sources</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a.c b.c c.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
or ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>1.c 2.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>3.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
depending on the value of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The only restriction on this
sort of use of nested variable references is that they cannot specify part
of the name of a function to be called. This is because the test for a
recognized function name is done before the expansion of nested references
as in the following example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>ifdef do_sort</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>func := sort</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>else</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>func := strip</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>endif</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>bar:=a d bg q c</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>foo := $($(func) $(bar))</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The previous example attempts
to give ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
the value of the variable ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sort
a d b g q c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’ or
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>strip a db gq c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
rather than giving ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ad
b gq c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’ as the
argument to either the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sort</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>strip</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
function. This restriction could be removed in the future if that change
is shown to be a good idea.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can also use computed
variable names in the left-hand side of a variable assignment, or in a
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>define</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
directive as in the following example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>dir = foo</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>$(dir)_sources := $(wildcard
$(dir)/*.c)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>define $(dir)_print</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>lpr $($(dir)_sources)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>endef</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This example defines the
variables, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo_sources</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
and ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo_print</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Nested variable references</I>
are quite different from <I>recursively expanded variables</I> (see <FONT COLOR="#008000"><A HREF="makeThe_Two_Flavors_of_Variables.html">The
two flavors of variables</A></FONT>), though both are used together in
complex ways when doing makefile programming.</FONT></FONT></UL>

<HR SIZE=3 WIDTH="100%">
<CENTER><A HREF="#Top">Top</A>|<A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeSubstitution_References.html">Previous</A>|<A HREF="makeHow_Variables_Get_Their_Values.html">Next</A></CENTER>

</BODY>
</HTML>
