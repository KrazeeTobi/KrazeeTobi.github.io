<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Using Implicit Rules</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeImplicit_Rules.html">Previous</A>|<A HREF="makeCatalogue_of_Implicit_Rules.html">Next</A>
<BR><A NAME="off_1933980"></A><A NAME="8e498d1c"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>Using
implicit rules</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>To allow
</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
to find a customary method for updating a target file, all you have to
do is refrain from specifying commands yourself. Either write a rule with
no command lines, or don’t write a rule at all. Then </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
will figure out which implicit rule to use based on which kind of source
file exists or can be made. For example, suppose the makefile looks like
the following.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>foo : foo.o bar.o</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>cc -o foo foo.o bar.o $(CFLAGS)
$(LDFLAGS)</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Because you mention ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
but do not give a rule for it, </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
will automatically look for an implicit rule that tells how to update it.
This happens whether or not the file ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
currently exists.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If an implicit rule is found,
it can supply both commands and one or more dependencies (the source files).
You would want to write a rule for ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
with no command lines if you need to specify additional dependencies (such
as header files) which the implicit rule cannot supply.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Each implicit rule has a
target pattern and dependency patterns. There may be many implicit rules
with the same target pattern. For example, numerous rules make ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.o</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
files: one, from a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.c</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file with the C compiler; another, from a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.p</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file with the Pascal compiler; and so on. The rule that actually applies
is the one whose dependencies exist or can be made. So, if you have a file
‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
will run the C compiler; otherwise, if you have a file ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.p</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
make will run the Pascal compiler; and so on.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Of course, when you write
the makefile, you know which implicit rule you want </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
to use, and you know it will choose that one because you know which possible
dependency files are supposed to exist. See <FONT COLOR="#008000"><A HREF="makeCatalogue_of_Implicit_Rules.html">Catalogue
of implicit rules </A></FONT>for a catalogue of all the predefined implicit
rules.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Previously, we said an implicit
rule applies if the required dependencies exist or can be made”. A file
“can be made” if it is mentioned explicitly in the makefile as a target
or a dependency, or if an implicit rule can be recursively found for how
to make it. When an implicit dependency is the result of another implicit
rule, we say that chaining is occurring. See <FONT COLOR="#008000"><A HREF="makeChains_of_Implicit_Rules.html">Chains
of implicit rules</A></FONT>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>In general, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
searches for an implicit rule for each target, and for each double-colon
rule, that has no commands. A file that is mentioned only as a dependency
is considered a target whose rule specifies nothing, so implicit rule search
happens for it. See <FONT COLOR="#008000"><A HREF="makeImplicit_Rule_Search_Algorithm.html">Implicit
rule search algorithm</A></FONT> for the details of how the search is done.</FONT></FONT>
<BR>&nbsp;
<UL><I><FONT FACE="Times New Roman"><FONT SIZE=+1>Note:</FONT></FONT></I>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>Explicit dependencies do
not influence implicit rule search. For example, consider the explicit
rule: </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.o: foo.p</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The dependency on ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.p</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
does not necessarily mean that </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
will remake ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.o</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
according to the implicit rule to make an object file, a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.o</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file, from a Pascal source file, a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.p</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file. For example, if ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
also exists, the implicit rule to make an object file from a C source file
is used instead, because it appears before the Pascal rule in the list
of predefined implicit rules (see <FONT COLOR="#008000"><A HREF="makeCatalogue_of_Implicit_Rules.html">Catalogue
of implicit rules </A></FONT>).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If you do not want an implicit
rule to be used for a target that has no commands, you can give that target
empty commands by writing a semicolon (see <FONT COLOR="#008000"><A HREF="makeUsing_Empty_Commands.html">Using
empty commands</A></FONT>).</FONT></FONT>
<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeImplicit_Rules.html">Previous</A>|<A HREF="makeCatalogue_of_Implicit_Rules.html">Next</A></CENTER>

</BODY>
</HTML>
