<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Examining the Symbol Table</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gdb.html">Contents</A>|<A HREF="gdbindex.html">Index</A>|<A HREF="gdbModula2.html">Previous</A>|<A HREF="gdbAltering_Execution.html">Next</A>
<BR><A NAME="off_2066782"></A><A NAME="075074c8"></A><B><FONT FACE="Futura Md BT"><FONT COLOR="#000000"><FONT SIZE=+3>Examining
the symbol table</FONT></FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>The
commands described in this section allow you to inquire about the symbols
(names of variables, functions and types) defined in your program. This
information is inherent in the text of your program and does not change
as your program executes. GDB finds it in your program’s symbol table,
in the file indicated when you started GDB (see <FONT COLOR="#008000"><A HREF="gdbCommand_files.html">Choosing
files</A></FONT>), or by one of the file-management commands (see <FONT COLOR="#008000"><A HREF="gdbCommands_to_specify_files.html">Commands
to specify files</A></FONT>).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Occasionally, you may need
to refer to symbols that contain unusual characters, which GDB ordinarily
treats as word delimiters. The most frequent case is in referring to static
variables in other source files (see <FONT COLOR="#008000"><A HREF="gdbProgram_variables.html">Program
variables</A></FONT>). File names are recorded in object files as debugging
symbols, but GDB would ordinarily parse a typical file name, like ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
as three words, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
To allow GDB to recognize ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
as a single symbol, enclose it in single quotes; for example, </FONT></FONT><FONT SIZE=+0><FONT FACE="Courier New">p
</FONT><TT>’</TT><FONT FACE="Courier New">foo.c</FONT><TT>’</TT><FONT FACE="Courier New">::x
</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>looks up the value
of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>x</FONT></FONT><FONT SIZE=+1><FONT FACE="Times New Roman">
in the scope of the </FONT><TT>’</TT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT><FONT SIZE=+1><TT>’</TT><FONT FACE="Times New Roman">
file.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>info address</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>symbol</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Describe where the data
for </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>symbol</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is stored. For a register variable, this says which register it is kept
in. For a non-register local variable, this prints the stack-frame offset
at which the variable is always stored.</FONT></FONT></UL>
&nbsp;
<UL>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>The contrast with ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>print
&amp;<I>symbol</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
does not work at all for a register variable, and for a stack local variable
prints the exact address of the current instantiation of the variable.</FONT></FONT></UL>
</UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>whatis</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>exp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the data type of expression
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>exp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>exp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is not actually evaluated, and any side-effecting operations (such as assignments
or function calls) inside it do not take place. See <FONT COLOR="#008000"><A HREF="gdbExpressions.html">Expressions</A></FONT>.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>whatis</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the data type of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
the last value in the value history.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>typename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print a description of data
type </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>typename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>typename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
may be the name of a type, or for C code it may have the form ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>class</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>class-name</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>struct</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>struct-tag</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>union</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>union-tag</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>’
or ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>enum</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>enum-tag</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>exp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print a description of the
type of expression </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>exp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
differs from </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>whatis</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
by printing a detailed description, instead of just the name of the type.
For instance, consider the following variable declaration example.</FONT></FONT></UL>
&nbsp;
<UL>
<UL><FONT FACE="Courier New"><FONT SIZE=+0>struct complex {double real;
double imag;} v;</FONT></FONT></UL>
</UL>
&nbsp;
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Such declarations give output
as the following example shows.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0><B>(gdb) </B>whatis v</FONT></FONT>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>type = struct complex</FONT></FONT></B>
<BR><FONT FACE="Courier New"><FONT SIZE=+0><B>(gdb) </B>ptype v</FONT></FONT>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>type = struct complex {</FONT></FONT></B>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double real;</FONT></FONT></B>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double imag;</FONT></FONT></B>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>}</FONT></FONT></B></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>As with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>whatis</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
using </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
without an argument refers to the type of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
the last value in the value history.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info types</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>info types</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print a brief description
of all types whose name matches </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
(or all types in your program, if you supply no argument). Each complete
typename is matched as though it were a complete line; thus, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>i
type</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>value</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
gives information on all types in your program whose name includes the
string </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>value</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
but ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>i type ˆvalue$</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
gives information only on types whose complete name is value.</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>This command differs from
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ptype</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in two ways: first, like </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>whatis</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
it does not print a detailed description; second, it lists all source files
where a type is defined.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info source</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Show the name of the current
source file—that is, the source file for the function containing the current
point of execution—and the language it was written in.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info sources</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the names of all source
files in your program for which there is debugging information, organized
into two lists: files whose symbols have already been read, and files whose
symbols will be read when needed.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info functions</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the names and data
types of all defined functions.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info functions</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the names and data
types of all defined functions whose names contain a match for regular
expression, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
Thus, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>info fun step</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
finds all functions whose names include </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>step</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>;
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>info fun ˆstep</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
finds those whose names start with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>step</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info variables</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the names and data
types of all variables that are declared outside of functions (i.e., excluding
local variables).</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>info variables</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Print the names and data
types of all variables (except for local variables) whose names contain
a match for regular expression </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>regexp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Some systems allow individual
object files that make up your program to be replaced without stopping
and restarting your program. For example, in VxWorks you can simply recompile
a defective object file and keep on running. If you are running on one
of these systems, you can allow GDB to reload the symbols for the following
automatically relinked modules:</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>set symbol-reloading on</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Replace symbol definitions
for the corresponding source file when an object file with a particular
name is seen again.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>set symbol-reloading off</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Do not replace symbol definitions
when re-encountering object files of the same name. This is the default
state; if you are not running on a system that permits automatically relinking
modules, you should leave </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>symbol-reloading</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
off, since otherwise GDB may discard symbols when linking large programs,
that may contain several modules (from different directories or libraries)
with the same name.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>show symbol-reloading</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Show the current </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>on</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>off</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
setting.</FONT></FONT></UL>


<P><FONT FACE="Courier New"><FONT SIZE=+0>maint print symbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>filename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>maint print psymbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>filename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>maint print msymbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>filename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1></FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Write a dump of debugging
symbol data into the file, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>filename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
These commands are used to debug the GDB symbol-reading code. Only symbols
with debugging data are included.</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>If you use ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>maint
print</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>symbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
GDB includes all the symbols for which it has already collected full details:
that is, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>filename</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
reflects symbols for only those files whose symbols GDB has read.</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>You can use the command,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>info sources</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
to find out which files these are. If you use ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>maint
print</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>psymbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
instead, the dump shows information about symbols that GDB only knows partially—that
is, symbols defined in files that GDB has skimmed, but not yet read completely.</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>Finally, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>maint
print msymbols</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
dumps just the minimal symbol information required for each object file
from which GDB has read some symbols. See <FONT COLOR="#008000"><A HREF="gdbCommands_to_specify_files.html">Commands
to specify files</A></FONT> for a discussion of how GDB reads symbols (in
the description of </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>symbol-file</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>).</FONT></FONT></UL>
</UL>

<HR SIZE=3 WIDTH="100%">
<CENTER><A HREF="#Top">Top</A>|<A HREF="gdb.html">Contents</A>|<A HREF="gdbindex.html">Index</A>|<A HREF="gdbModula2.html">Previous</A>|<A HREF="gdbAltering_Execution.html">Next</A></CENTER>

</BODY>
</HTML>
