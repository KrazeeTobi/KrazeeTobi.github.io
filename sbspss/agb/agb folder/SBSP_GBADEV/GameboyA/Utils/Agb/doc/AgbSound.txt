/********************************************************************/
/*          AgbSound.txt                                            */
/*            Using the DirectSound Driver                          */
/*                                                                  */
/*          Copyright (C) 1999, 2000 NINTENDO Co.,Ltd.              */
/*          Programmed by SMASH Co.,Ltd.                            */
/********************************************************************/


[Overview]

(1) First, declare the following.  The variable sa (random name) is the work area 
    to be used by the sound driver. 

	#include <AgbSound.h>
	SoundArea sa;

(2) Execute the following in the initialization routine after the reset. 

	SoundDriverInit(&sa); // Initialize sound driver

(3) Call the function below immediately after the V-blank interrupt is received.  
    It is ideal to call this function before any other processing due to the CBA 
    timing. Also, the process itself is extremely short.  

	SoundDriverVSync(); // Reset sound driver DMA

(4) Call the function below during the V-blank cycle (every 1/60 second).  There 
    is no need to be sensitive to the timing.  This function could as well be 
    called after all other processing, except for other music, has been completed. 

	SoundDriverMain(); // System call

(5) The AGB title sound can be played by writing a value to the vchn element in 
    the sa structure. 


[Details About Functions]


(1) Initialize Sound Driver

	void SoundDriverInit(SoundArea *sa);

This initializes the sound driver. 
Call this only once when starting the game.  At this time, it is necessary that 
the work area, sa, already be reserved.  Furthermore, even if work areas are 
separately set aside, this driver cannot be executed multiple times. 

(2) Main Sound Driver

	void SoundDriverMain(void);

This is the main sound driver. 
Call this every 1/60 second.  The processing flow should be such that SoundVSync(), 
described below, is called immediately after a V-Blank interrupt, after which BG 
or OBJ processing is performed, and then this function is called. 

(3) Reset Sound Driver DMA

	void SoundDriverVSync(void);

This is an extremely short system call to reset the sound DMA. Since the timing 
is CBA, be sure to call this "immediately after" the V-blank interrupt is 
received every 1/60 second. 

(4) Sound buffer area

	void SoundChannelClear(void);

This clears all DirectSound channels and stops the sound. 

(5) Calculate tone from MIDI key

	u32 MidiKey2Freq(WaveData *wa, s32 mk, s32 fp);

This will calculate the value put in the place of sa.vchn[x].fr when waveform data 
wa are produced at the tone mk (MIDI KEY) and fine tuning value (semi-tone=256) fc. 


[Details About Structures]

(1) Structure of Sound Driver Work Area
     
	typedef struct {
		u32 ident;
		vu8 DmaCount;	// * ... Prohibit user access
		u8 reverb;
		u16 d1;		// *
		void (*func)();	// *
		int intp;	// *
		void *NoUse;	// *
		SoundChannel vchn[MAX_SOUND_CHANNEL];
		s8 pcmbuf[PCM_BF*2];	// *
	} SoundArea;

	#define MAX_SOUND_CHANNEL 8

(Description of Various Elements)

 ident;

This is the part where the system checks to see if the work area has been 
initialized or if it is being accessed.  After initialization has been completed,
this is set to +1 before access starts, and to -1 when access is completed so 
that the work area can be safely accessed. 

 reverb;

This is a variable for putting reverb on the DirectSound sound.  It is 
simultaneously put on all channels and cannot be operated separately. 

 vchn[];

This is the structure array that operates the various DirectSound channels (8 
channels are currently available).  Also, the channels referred to here, are not 
hardware channels, but are virtual channels in this sound driver. 


(2) Virtual Channel Structure

	typedef struct {
		u8 sf;
		u8 r1;		// * ... Prohibit user access 
		u8 rv;
		u8 lv;
		u8 at;
		u8 de;
		u8 su;
		u8 re;
		u8 r2[4];	// *
		u32 fr;
		WaveData *wp;
		u32 r3[6];	// *
		u8 r4[4];	// *
	} SoundChannel;

	#define SOUND_CHANNEL_SF_START 0x80
	#define SOUND_CHANNEL_SF_STOP  0x40

(Description of Various Elements)

 sf;

This is a flag indicating the status of this particular channel.  IF it is zero, 
sound is stopped.  To start generating sound, after setting the other elements, 
write 0x80 to this flag.  To stop sound, write 0x40 to effect a stop with a 
release effect with an OR logic (key OFF), or write a 0 to immediately stop the 
sound. Also, the user is prohibited from operating the other bits. 

 rv;

This is the output volume on the right side. 

 lv;

This is the output volume on the left side. 

 at;

This is the envelope attack value.  When sound generation is started, the volume 
starts from zero and this value is incremented every 1/60 second, and when it 
reaches 255, processing moves to the next decay. 

 de;

This is the envelope decay value.  Every 1/60 second, "this value/256" is 
calculated and when the next sustain value is reached, processing shifts to 
the sustain status. 

 su;

This is the value of the envelope sustain.  The sound will continue at this level.
(Actually, rv/256, lv/256 are calculated and output to the right and left). 

 re;

This is the value of the envelope release.  Processing enters this state when 
a key off(0x40 is written as OR to sf) is encountered.  Every 1/60 second, 
"this value/256" is calculated and this channel is completely stopped when 
zero is reached. 

 fr;

This is the frequency of the sound being generated.  Write the value found using 
the MidiKey2Freq function described above here. 

 wp;

This is the pointer to the waveform data to be generated. 


(3) Wave Data Structure

* Since waveform data can be created from an AIFF file using a tool called 
aif2agb.exe, there is usually no need for the user to create this. 

	typedef struct {
		u16 type;
		u16 stat;
		u32 freq;
		u32 loop;
		u32 size;
		s8 data[];
	} WaveData;

	#define WAVE_STAT_LOOP 0xc000

(Description of Various Elements)

 type;

This is where the data type is indicated, and it is not used at this time. 

 stat;

At present, non-looped (one-shot) waves are 0x0000, and forward looped waves 
are 0x4000. 

 freq;

This is the value for calculating the frequency.  It is basically found using 
the following equation. 

	Sampling frequency x 2^((180 - original MIDI key).12)

 loop;

Loop point (loop start). 

 size;

Number of samples (end position). 

 data[];

This is the actual waveform data.  These are 8-bit, signed, linear, uncompressed 
data, but they are aligned on the sampling number + 1 byte.  Additionally, in the 
case of non-looping waveform data, a zero is placed in the last byte, while the 
same value as that in the loop point data is placed in the last byte for looped 
wave data. 

