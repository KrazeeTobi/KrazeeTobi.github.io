<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Reading strings</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="libio.html">Contents</A>|<A HREF="libioindex.html">Index</A>|<A HREF="libioReading_one_character.html">Previous</A>|<A HREF="libioRepositioning_an_istream.html">Next</A>
<BR><A NAME="off_360815"></A><A NAME="26d8cae3"></A><A NAME="off_360815"></A><A NAME="26d8cae3"></A><A NAME="off_360815"></A><A NAME="26d8cae3"></A><A NAME="off_360815"></A><A NAME="26d8cae3"></A><A NAME="off_360815"></A><A NAME="26d8cae3"></A><A NAME="off_360815"></A><A NAME="26d8cae3"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>Reading
strings</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>Use
the following methods to read strings (for example, a line at a time) from
the input stream</FONT></FONT>
<UL><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;</FONT></FONT><FONT FACE="Times New Roman">
<B>istream::get </B></FONT><FONT FACE="Courier New"><FONT COLOR="#000000">(char*
<I>c</I>, int <I>len </I></FONT></FONT><FONT FACE="Times New Roman">[</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">,
char <I>delim</I></FONT></FONT><FONT FACE="Times New Roman">]</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Read a string from the input
stream, into the array at </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>c</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
The remaining arguments limit how much to read: up to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>len-1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
characters, or up to (but not including) the first occurrence in the input
of a particular delimiter character </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>—newline
(</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>\n</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
by default. (Naturally, if the stream reaches end of file first, that too
will terminate reading.) If </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
was present in the input, it remains available as if unread; to discard
it instead, see </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0><A HREF="#istream_getline">iostream::getline</A></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></UL>
</UL>

<UL>
<UL><FONT FACE="Courier New"><FONT SIZE=+0>get</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
writes </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>\0</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
at the end of the string, regardless of which condition terminates the
read.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;</FONT></FONT><FONT FACE="Times New Roman">
<B>istream::get </B></FONT><FONT FACE="Courier New"><FONT COLOR="#000000">(streambuf&amp;
<I>sb </I></FONT></FONT><FONT FACE="Times New Roman">[</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">,
char <I>delim</I></FONT></FONT><FONT FACE="Times New Roman">]</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Read characters from the
input stream and copy them on the streambuf object, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>sb</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
Copying ends either just before the next instance of the delimiter character,
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>,
which is newline (</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>\n</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
by default, or when either stream ends. If </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
was present in the input, it remains available as if unread.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><A NAME="istream_getline"></A><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;</FONT></FONT><FONT FACE="Times New Roman">
<B>istream::getline </B></FONT><FONT FACE="Courier New"><FONT COLOR="#000000">(<I>charptr</I>,
int <I>len </I></FONT></FONT><FONT FACE="Times New Roman">[</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">,char
<I>delim</I></FONT></FONT><FONT FACE="Times New Roman">]</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Read a line from the input
stream, into the array at </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>charptr</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>.
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>charptr</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
may be any of three kinds of pointer: </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>unsigned char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>signed char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The remaining arguments limit
how much to read: up to (but not including) the first occurrence in the
input of a line delimiter character </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>—newline
(</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>\n</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
by default, or up to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>len-1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
characters (or to end of file, if that happens sooner). If </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>getline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
succeeds in reading a ‘full line’, it also discards the trailing delimiter
character from the input stream. (To preserve it as available input, see
the similar form of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0><A HREF="#istream_gets">istream::gets</A></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.)</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
was <I>not</I> found before </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>len</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
characters or end of file, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>getline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
sets the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ios::fail</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
flag, as well as the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ios::eof</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
flag if appropriate.</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>getline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
writes a null character at the end of the string, regardless of which condition
terminates the read.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;
</FONT></FONT><B><FONT FACE="Times New Roman">istream::read </FONT></B><FONT FACE="Courier New"><FONT COLOR="#000000">(<I>pointer</I>,
int <I>len</I>)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Read </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>len</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
bytes into the location at </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>pointer</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>,
unless the input ends first.</FONT></FONT>

<P><I><FONT FACE="Courier New"><FONT SIZE=+0>pointer</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
may be of type </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>void*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>unsigned char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>signed char*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>istream</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
ends before reading </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>len</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
bytes, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>read</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
sets the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ios::fail</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
flag.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><A NAME="istream_gets"></A><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;
</FONT></FONT><B><FONT FACE="Times New Roman">istream::gets </FONT></B><FONT FACE="Courier New"><FONT COLOR="#000000">(char
** <I>s </I></FONT></FONT><FONT FACE="Times New Roman">[</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">,
char <I>delim</I></FONT></FONT><FONT FACE="Times New Roman">]</FONT><FONT FACE="Courier New"><FONT COLOR="#000000">)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>A GNU extension, to read
an arbitrarily long string from the current input position to the next
instance of the </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>delim</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
character, which is newline (</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>\n</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
by default).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>To permit reading a string
of arbitrary length, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>gets</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
allocates whatever memory is required. Notice that the first argument,
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>s</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>,
is an address to record a character pointer, rather than the pointer itself.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;
</FONT></FONT><B><FONT FACE="Times New Roman">istream::scan </FONT></B><FONT FACE="Courier New"><FONT COLOR="#000000">(const
char *<I>format</I> ...)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>A GNU extension, similar
to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fscanf (<I>file</I>,
<I>format</I>, ...)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
The </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>format</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is a </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>scanf</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>-style
format control string, which is used to read the variables in the remainder
of the argument list from the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>istream</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></UL>
<FONT FACE="Courier New"><FONT COLOR="#000000"><FONT SIZE=+1></FONT></FONT></FONT>

<P><FONT SIZE=+1><FONT FACE="Courier New"><FONT COLOR="#000000">istream&amp;
</FONT></FONT><B><FONT FACE="Times New Roman">istream::vscan </FONT></B><FONT FACE="Courier New"><FONT COLOR="#000000">(const
char *<I>format</I>, va_list <I>args</I>)&nbsp;<BR>
</FONT></FONT><B><I><FONT FACE="Times New Roman">Method</FONT></I></B></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Like </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>istream::scan</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
but takes a single </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>va_list</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
argument.</FONT></FONT></UL>
</UL>

<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="libio.html">Contents</A>|<A HREF="libioindex.html">Index</A>|<A HREF="libioReading_one_character.html">Previous</A>|<A HREF="libioRepositioning_an_istream.html">Next</A></CENTER>

</BODY>
</HTML>
