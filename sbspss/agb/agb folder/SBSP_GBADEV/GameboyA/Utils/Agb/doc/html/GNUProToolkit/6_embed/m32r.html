<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (Win95; I) [Netscape]">
   <title> Developing for the M32R/X/D targets</title>
</head>
<body bgcolor="#FFFFFF">

<div CLASS="Heading1"><a NAME="Top"></a><a href="emb.html">Contents</a>|<a href="embindex.html">Index</a>|<a href="embD10V.html">Previous</a>|<a href="embMotorola_m68k_targets.html#Top">Next</a></div>

<div CLASS="Heading1"><a NAME="pgfId=999630"></a><font face="Futura Md BT"><font size=+2>Developing
for the Mitsubishi M32R/X/D targets</font></font>
<hr SIZE=5 WIDTH="100%"></div>

<div CLASS="BodyAfterHead"><a NAME="pgfId=999632"></a><font size=+1>The
following documentation discusses the Mitsubishi&nbsp;<a NAME="M32R/X/D development"></a>M32R
processors.</font>
<ul TYPE=SQUARE>
<li>
<font size=+1><a href="#M32rxd">M32R/X/D</a></font></li>

<li>
<font size=+1><a href="#M32rd">M32R/D</a></font></li>
</ul>

<p><br><a NAME="M32rxd"></a><b><i><font size=+2>Mitsubishi M32R/X/D processors</font></i></b>
<p><font size=+1>The following documentation discusses the Mitsubishi M32R/X/D
processors.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999636"></a><font size=+1><a href="#17045" CLASS="XRef">Compiler
support for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999640"></a><font size=+1><a href="m32r.html#13583" CLASS="XRef">ABI
summary for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999644"></a><font size=+1><a href="m32r.html#21464" CLASS="XRef">Assembler
support for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999648"></a><font size=+1><a href="m32r.html#12202" CLASS="XRef">Linker
support for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999652"></a><font size=+1><a href="m32r.html#23881" CLASS="XRef">Debugger
support for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999656"></a><font size=+1><a href="m32r.html#10090" CLASS="XRef">Standalone
simulator for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999660"></a><font size=+1><a href="m32r.html#_Toc435604883" CLASS="XRef">Overlays
for the M32R/X/D targets</a></font></li>
</ul>

<div CLASS="Heading1"><a NAME="pgfId=999662"></a><b><i><font size=+2>Compiler
support for M32R/X/D targets</font></i></b><a NAME="17045"></a></div>

<div CLASS="Body"><a NAME="pgfId=999666"></a><font size=+1>For a list of
available generic compiler options, see <a href="../2_comp/Using_GNU_CC/gccGNU_CC_Command_Options.html#Top" CLASS="XRef">GNU
CC command options</a> and <a href="../2_comp/Using_GNU_CC/gccOption_Summary.html#Top" CLASS="XRef">Option
summary for GCC </a>in&nbsp;<a NAME="M32R/X/D"></a><i><a href="../2_comp/Using_GNU_CC/gcc.html#Top">Using
GNU CC</a></i> in <b><i>GNUPro Compiler Tools</i></b>.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999674"></a><font size=+1><a href="m32r.html#15942" CLASS="XRef">Preprocessor
symbol issues for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999678"></a><font size=+1><a href="m32r.html#24321" CLASS="XRef">M32R/X/D-specific
compiling attributes</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999682"></a><font size=+1><a href="m32r.html#29843" CLASS="XRef">Data
types and alignment for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999686"></a><font size=+1><a href="m32r.html#17718" CLASS="XRef">CPU
registers for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999690"></a><font size=+1><a href="m32r.html#24331" CLASS="XRef">The
stack frame for M32R/X/D targets</a></font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=999691"></a><font size=+1>The following
M32R/X/D-specific command-line options are supported.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=999692"></a><tt><font size=+1>-m32r</font></tt></div>

<blockquote><font size=+1>Generate code for the M32R processor (including
M32R/D).</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999693"></a><tt><font size=+1>-m32rx</font></tt></div>

<blockquote><font size=+1>Generate code for the M32R/X processor.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999694"></a><tt><font size=+1>-mmodel=small</font></tt></div>

<blockquote><font size=+1>Assume all objects live in the lower 16MB of
memory (so that their addresses can be loaded with the ‘<tt>ld24</tt>’
instruction), and assume all subroutines are reachable with the ‘<tt>bl</tt>’
instruction. This is the default.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=999695"></a><font size=+1>The
addressability of a particular object can be set with the ‘<tt>model</tt>’
attribute in the source code. See <a href="m32r.html#24321" CLASS="XRef">M32R/X/D-specific
compiling attributes</a>.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999699"></a><tt><font size=+1>-mmodel=medium</font></tt></div>

<blockquote><font size=+1>Assume objects may be anywhere in the 32 bit
address space (the compiler will generate ‘<tt>seth/add3</tt>’ instructions
to load their addresses), and assume all subroutines are reachable with
the ‘<tt> bl</tt>’ instruction.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999700"></a><tt><font size=+1>-mmodel=large</font></tt></div>

<blockquote><font size=+1>Assume objects may be anywhere in the 32 bit
address space (the compiler will generate ‘<tt>seth/add3</tt>’ instructions
to load their addresses), and assume subroutines may not be reachable with
the ‘<tt>bl</tt>’ instruction (the compiler will generate the much slower
‘<tt>seth/add3/jl</tt>’ instruction sequence).</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999701"></a><tt><font size=+1>-msdata=none</font></tt></div>

<blockquote><font size=+1>Disable use of the small data area. Variables
will be put into one of ‘<tt>.data</tt>’, ‘<tt>bss</tt>’, or ‘<tt>.rodata</tt>’
(unless the ‘<tt>section</tt>’ attribute has been specified). This is the
default.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999702"></a><font size=+1>The
small data area consists of sections ‘<tt>.sdata</tt>’ and ‘<tt>.sbss</tt>’.
Objects may be explicitly put in the small data area with the ‘section’
attribute using one of these sections.</font></div>
</blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999703"></a><tt><font size=+1>-msdata=sdata</font></tt></div>

<blockquote><font size=+1>Put small global and static data in the small
data area, but do not generate special code to reference them. This is
normally only used to build system libraries. It enables them to be used
with both ‘<tt>-msdata=none</tt> ’ and ‘<tt>-msdata=use</tt>’.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999704"></a><tt><font size=+1>-msdata=use</font></tt></div>

<blockquote><font size=+1>Put small global and static data in the small
data area, and generate special instructions to reference them.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999705"></a><tt><font size=+1>-G
<i>num</i></font></tt></div>

<blockquote><font size=+1>Put global and static objects less than or equal
to ‘<i><tt>num</tt></i> ’ bytes into the small data or bss sections instead
of the normal data or bss sections. The default value of ‘<i><tt>num</tt></i>’
is 8.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999706"></a><font size=+1>The
‘<tt>-msdata</tt> ’ option must be set to one of ‘<tt>sdata</tt>’ or ‘<tt>use</tt>’
for this option to have any effect.</font></div>
</blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999707"></a><font size=+1>All
modules should be compiled with the same ‘<tt>-G <i>num</i></tt>’ value.
Compiling with different values of ‘<i><tt>num</tt></i>’ may or may not
work; if it does not work, the linker will give an error message. Incorrect
code will not be generated.</font></div>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=999709"></a><b><i><font size=+2>Preprocessor
symbol issues for M32R/X/D targets</font></i></b><a NAME="15942"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999711"></a><font size=+1>By default, the compiler defines
the ‘<tt>__M32R__</tt>’ preprocessor symbol.</font><a NAME="M32R/X/D"></a></div>

<div CLASS="Heading2"><a NAME="pgfId=999714"></a><b><i><font size=+2>M32R/X/D-specific
compiling attributes</font></i></b><a NAME="24321"></a><a NAME="M32R/X/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999715"></a><font size=+1>The following M32R/X/D-specific
attributes are supported. Names may be surrounded with double-underscores
to avoid namespace pollution. For example, <tt>__interrupt__</tt> can also
be used for <tt>interrupt</tt> . See <a href="../2_comp/Using_GNU_CC/gccDeclaring_Attributes_of_Function.html#Top" CLASS="XRef">Declaring
attributes of functions</a> and <a href="../2_comp/Using_GNU_CC/gccSpecifying_Attributes_of_Variabl.html#Top" CLASS="XRef">Specifying
attributes of variables</a> in <a href="../2_comp/Using_GNU_CC/gccExtensions_to_the_C_Language_Fam.html#Top" CLASS="XRef">Extensions
to the C language family</a> in <i>Using GNU CC</i> in <b><i>GNUPro Compiler
Tools</i></b> for more information.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=999725"></a><tt><font size=+1>interrupt</font></tt></div>

<blockquote>&nbsp;
<br><font size=+1>Indicates the specified function is an interrupt handler.
The compiler will generate <tt>prologue</tt> and <tt>epilogue</tt> sequences
appropriate for an interrupt handler.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999726"></a><font size=+1><tt>model
(</tt><i>&lt;<tt>model-name</tt>></i><tt>)</tt></font></div>

<blockquote><font size=+1>Use this attribute on the M32R/X/D to set the
addressability of an object, and the code generated for a function. The
identifier ‘<tt>&lt;<i>model-name</i>></tt> ’ is one of ‘<tt>small</tt>’,
‘<tt>medium</tt>’, or ‘<tt>large</tt> ’, representing each of the code
models.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=999727"></a><font size=+1>Small
model objects live in the lower 16MB of memory (so that their addresses
can be loaded with the ‘<tt>ld24</tt>’ instruction), and are callable with
the ‘<tt>bl</tt>’ instruction.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=999728"></a><font size=+1>Medium
model objects may live anywhere in the 32 bit address space (the compiler
will generate ‘<tt>seth/add3</tt>’ instructions to load their addresses),
and are callable with the ‘<tt>bl</tt>’ instruction.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=999729"></a><font size=+1>Large
model objects may live anywhere in the 32 bit address space (the compiler
will generate ‘<tt>seth/add3</tt>’ instructions to load their addresses),
and may not be reachable with the ‘<tt>bl</tt>’ instruction (the compiler
will generate the much slower ‘<tt>seth/add3/jl</tt>’ instruction sequence).</font></blockquote>

<div CLASS="Heading1"><a NAME="pgfId=999731"></a><b><i><font size=+2>ABI
summary for M32R/X/D targets</font></i></b><a NAME="13583"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999733"></a><font size=+1>The following documentation
discusses the Application Binary Interface (<a NAME="M32R/X/D"></a>ABI)
for the M32R/X/D processors.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999737"></a><font size=+1><a href="m32r.html#29843" CLASS="XRef">Data
types and alignment for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999741"></a><font size=+1><a href="m32r.html#39813" CLASS="XRef">Allocation
rules for structures and unions for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999745"></a><font size=+1><a href="m32r.html#17718" CLASS="XRef">CPU
registers for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999749"></a><font size=+1><a href="m32r.html#24331" CLASS="XRef">The
stack frame for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999753"></a><font size=+1><a href="m32r.html#_Toc435604863" CLASS="XRef">Argument
passing for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999757"></a><font size=+1><a href="m32r.html#_Toc435604864" CLASS="XRef">Function
return values for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999761"></a><font size=+1><a href="m32r.html#18466" CLASS="XRef">Startup
code for M32R/X/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999765"></a><font size=+1><a href="m32r.html#38616" CLASS="XRef">Producing
S-records for M32R/X/D targets</a></font></li>
</ul>

<div CLASS="Heading2"><a NAME="pgfId=999767"></a><b><i><font size=+2>Data
types and alignment for M32R/X/D targets</font></i></b><a NAME="29843"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999772"></a><font size=+1><a href="m32r.html#17668" CLASS="XRef">Table
1</a> shows the data type sizes for M32R/X/D processors.</font><a NAME="M32R/X/D"></a></div>

<div CLASS="TableTitle"><a NAME="pgfId=999811"></a><a NAME="17668"></a><font size=+1>Data
type sizes for M32R/X/D processors</font></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=999776"></a><b><i>Type</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=999778"></a><b><i>Size (bytes)</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999780"></a><tt>char</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999782"></a>1 byte</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999784"></a><tt>short</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999786"></a>2 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999788"></a><tt>int</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999790"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999792"></a><tt>long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999794"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999796"></a><tt>long long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999798"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999800"></a><tt>float</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999802"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999804"></a><tt>double</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999806"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=999808"></a><i>pointer</i></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=999810"></a>4 bytes</div>
</td>
</tr>
</table>


<p CLASS="Body"><a NAME="pgfId=999812"></a><font size=+1>The stack is aligned
to a four-byte boundary. One byte is used for characters (including structure/unions
made entirely of <tt>char</tt>s), two bytes for <tt>short</tt>s (including
structure/unions made entirely of <tt>short</tt>s), and four-byte alignment
for everything else.</font>

<p CLASS="Heading2"><a NAME="pgfId=999814"></a><b><i><font size=+2>Allocation
rules for structures and unions for M32R/X/D targets</font></i></b><a NAME="39813"></a>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999816"></a><font size=+1>The following rules apply
to the allocation of structure and union members in memory.</font><a NAME="M32R/X/D"></a></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999817"></a><font size=+1>Structure and union packing can
be controlled by attributes specified in the source code. In the absence
of any attributes however, the following rules are obeyed:</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999818"></a><font size=+1>Fields that are shorts are aligned
to 2 byte boundaries. Fields that are <tt>int</tt>s, <tt>long</tt>s, <tt>float</tt>s,
<tt>double</tt>s
and <tt>long long</tt>s are aligned to 4 byte boundaries;
<tt>char</tt>
fields are not aligned.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999819"></a><font size=+1>Composite fields (ones that are
themselves structures or unions) are aligned to greatest alignment requirement
of any of their component fields. So if a field is a structure that contains
a char, a short and an int, the field will be aligned to a 4-byte boundary
because of the int.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999820"></a><font size=+1>Bit fields are packed in a big-endian
fashion, and they are aligned so that they will not cross boundaries of
their type. For instance, consider the following example’s structure.</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=999821"></a><font size=+1>struct { int a:2, b:31;} s = { 0x1, 0x3};</font></pre>
</blockquote>
</blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote><a NAME="pgfId=999822"></a><font size=+1>Such input is stored
in memory as the following code example shows.</font></blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=999823"></a><font size=+1>.byte 0x40</font></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><font size=+1>.zero 3</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x6</font></pre>
</blockquote>
</blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999824"></a><font size=+1>So
the ‘<tt>a</tt>’ field is stored in the top two bits of the first byte;
with the most significant bit of ‘<tt>a</tt>’ being stored in the most
significant bit of the byte. The bottom six bits of that byte and the next
three bytes are all padding, so that the next bitfield ‘<tt>b</tt>’ does
not cross a word boundary.</font></div>
</blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999825"></a><font size=+1>Consider
the following example’s structure.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=999826"></a><font size=+1>struct { short c:2, d:2, e:13; } s = { 0x2, 0x3, 0xf};</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=999827"></a><font size=+1>Such
input is stored in memory as the following code example shows.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=999828"></a><font size=+1>.byte 0xb0</font></pre>

<pre><font size=+1>.zero 1</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x78</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=999829"></a><font size=+1>So
‘<tt>c</tt>’ and ‘<tt>d</tt>’ fields are both held in the same byte, but
the ‘<tt>e</tt>’ field starts two bytes further on, so that it will not
cross a two byte boundary.</font></div>

<div CLASS="Bullet"><a NAME="pgfId=999830"></a><font size=+1>Fields in
unions are treated in the same way as fields in structures. A union is
aligned to the greatest alignment requirement of any of its members.</font></div>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=999832"></a><b><i><font size=+2>CPU
registers for M32R/X/D targets</font></i></b><a NAME="17718"></a></div>

<div CLASS="Body"><a NAME="pgfId=999834"></a><font size=+1>The following&nbsp;<a NAME="M32R/X/D"></a>registers
are specific to the M32R/X/D processors.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=999835"></a><font size=+1><tt>r0</tt> through <tt>r3</tt></font></div>

<blockquote><font size=+1>Used for passing arguments to functions. Additional
arguments are passed on the stack (see below). ‘<tt>r0</tt>’, ‘<tt>r1</tt>’
is also used to return the result of function calls. The values of these
registers are not preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999836"></a><font size=+1><tt>r4</tt>
through <tt>r7</tt></font></div>

<blockquote><font size=+1>Temporary registers for expression evaluation.
The values of these registers are not preserved across function calls.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=999837"></a><font size=+1>‘<tt>r4</tt>’
is reserved for use as a temporary register in the prologue.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=999838"></a><font size=+1>‘<tt>r6</tt>’
is also reserved for use as a temporary in the Position Independent Code
(PIC) calling sequence (if ever necessary) and may not be used in the function
calling sequence or prologue of functions.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=999839"></a><font size=+1>‘<tt>r7</tt>’
is also used as the static chain pointer in nested functions (a GNU C extension)
and may not be used in the function calling sequence or prologue of functions.
In other contexts it is used as a temporary register.</font></div>
</blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999840"></a><font size=+1><tt>r8</tt>
, <tt>r9</tt> , <tt>r10</tt> , <tt>r11</tt></font></div>

<blockquote><font size=+1>Temporary registers for expression evaluation.
The values of these registers are preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999841"></a><tt><font size=+1>r12</font></tt></div>

<blockquote><font size=+1>Temporary register for expression evaluation.
Its value is preserved across function calls. It is also reserved for use
as potential <i>global pointer</i>.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999842"></a><tt><font size=+1>r13(fp)</font></tt></div>

<blockquote><font size=+1>Reserved for use as the frame pointer if one
is needed. Otherwise it may be used for expression evaluation. Its value
is preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999843"></a><tt><font size=+1>r14(lr)</font></tt></div>

<blockquote><font size=+1>Link register. This register contains the return
address in function calls. It may also be used for expression evaluation
if the return address has been saved.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999844"></a><tt><font size=+1>r15(sp)</font></tt></div>

<blockquote><font size=+1>Stack pointer.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999845"></a><tt><font size=+1>accumulator</font></tt></div>

<blockquote><font size=+1>This register is not preserved across function
calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=999846"></a><tt><font size=+1>psw</font></tt></div>

<blockquote><font size=+1>The carry bit of the ‘<tt>psw</tt>’ is not preserved
across function calls.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=999849"></a><b><i><font size=+2>The
stack frame for M32R/X/D targets</font></i></b><a NAME="24331"></a><a NAME="M32R/X/D"></a></div>

<div CLASS="Body"><a NAME="pgfId=999850"></a><font size=+1>Stack frames
for M32R/X/D processors use the following functionality.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999851"></a><font size=+1>The stack grows downwards from
high addresses to low addresses.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999852"></a><font size=+1>A leaf function need not allocate
a stack frame if it does not need one.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999853"></a><font size=+1>A frame pointer need not be allocated.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999854"></a><font size=+1>The stack pointer shall always
be aligned to 4-byte boundaries.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999855"></a><font size=+1>The register save area shall be
aligned to a 4-byte boundary.</font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=999856"></a><font size=+1>Stack frames
for functions that take a fixed number of arguments use the definitions
and allocations shown in <a href="m32r.html#25622" CLASS="XRef">M32R/X/D
stack frames for functions that take a fixed number of arguments</a>. The
frame pointer (<i> </i><font face="Arial,Helvetica">FP</font> ) points
to the same location as the stack pointer (<i> </i><font face="Arial,Helvetica">SP</font>
).</font></div>

<div CLASS="FigureTitle"><a NAME="pgfId=999861"></a><a NAME="25622"></a><b><font size=+1>M32R/X/D
stack frames for functions that take a fixed number of arguments</font></b></div>

<div CLASS="Body"><a NAME="pgfId=999917"></a><map NAME="m32r-1"></map><img SRC="m32r-1.gif" BORDER=3 USEMAP="#m32r-1" height=308 width=360></div>

<div CLASS="Body"><a NAME="pgfId=999918"></a><font size=+1>Stack frames
for functions taking a variable number of arguments use the definitions
and allocations shown in <a href="m32r.html#36875" CLASS="XRef">M32R/X/D
stack frames for functions that take a variable number of arguments</a>.
The frame pointer (<i> </i><font face="Arial,Helvetica">FP</font> ) points
to the same location as the stack pointer (<i> </i><font face="Arial,Helvetica">SP</font>
).</font></div>

<div CLASS="FigureTitle"><a NAME="pgfId=999923"></a><a NAME="36875"></a><b><font size=+1>M32R/X/D
stack frames for functions that take a variable number of arguments</font></b></div>

<div CLASS="Body"><a NAME="pgfId=999978"></a><map NAME="m32r-2"></map><img SRC="m32r-2.gif" BORDER=3 USEMAP="#m32r-2" height=325 width=360></div>

<div CLASS="Heading2"><a NAME="pgfId=999981"></a><a NAME="_Toc435604863"></a><b><i><font size=+2>Argument
passing for M32R/X/D targets</font></i></b><a NAME="M32R/X/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999982"></a><font size=+1>Arguments are passed to a
function using first registers and then memory if the argument passing
registers are used up. Each register is assigned an argument until all
are used. Unused argument registers have undefined values on entry. The
following rules must be adhered to.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999983"></a><font size=+1>An argument, if it is less than
or equal to 8 bytes in size, is passed in registers if available. However,
if such an argument is a composite structure (one with more than one field
and greater than 4 bytes in size) it is also passed on the stack, in addition
to being passed in the registers. An argument, which is greater than 8
bytes in size, is always passed by reference, which means that a copy of
the argument is placed on the stack and a pointer to that copy is passed
in the register.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999984"></a><font size=+1>If a data type would overflow
the register arguments, then it is passed in registers and memory. A ‘<tt>long
long</tt>’ data type passed in ‘<tt>r3</tt>’ would be passed in ‘<tt>r3</tt>’
and in the first 4 bytes of the stack.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999985"></a><font size=+1>Arguments passed on the stack
begin at ‘<tt> sp</tt>’ with respect to the caller.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999986"></a><font size=+1>Each argument passed on the stack
is aligned on a 4 byte boundary.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999987"></a><font size=+1>Space for all arguments is rounded
up to a multiple of 4 bytes.</font></li>
</ul>

<div CLASS="Heading2"><a NAME="pgfId=999989"></a><a NAME="_Toc435604864"></a><b><i><font size=+2>Function
return values for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999990"></a><font size=+1>Integers, floating point values,
and aggregates of 8 bytes or less are returned in register ‘<tt>r0</tt>
’ (and ‘<tt>r1</tt>’ if necessary).</font></div>

<div CLASS="Body"><a NAME="pgfId=999991"></a><font size=+1>Aggregates larger
than 8 bytes are returned by having the caller pass the address of a buffer
to hold the value in ‘<tt>r0</tt>’ as an <i>invisible</i> first argument.
All arguments are then shifted down by one. The address of this buffer
is returned in ‘<tt>r0</tt>’.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=999994"></a><b><i><font size=+2>Startup
code
for M32R/X/D targets</font></i></b><a NAME="18466"></a><a NAME="M32R/X/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=999995"></a><font size=+1>Before the ‘<tt>main</tt>
’ function can be called, code must be run that does four things:</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=999996"></a><font size=+1>Contain symbol ‘<tt>_start</tt>’</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999997"></a><font size=+1>Initialize the stack pointer</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999998"></a><font size=+1>Zeros the ‘<tt>bss</tt>’ section</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=999999"></a><font size=+1>Runs constructors for any global
objects that have them</font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=1000000"></a><font size=+1>The default
startup code is shown in the following example. It is part of the ‘<tt>libgloss/m32r/crt0.S</tt>’
file in the source tree. The best way to write your own startup code is
to take the following example and modify it to suit your needs.</font></div>

<div CLASS="CodeExample">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000001"></a><tt><font size=+1>.text</font></tt></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><tt><font size=+1>.balign 4</font></tt></pre>

<pre><tt><font size=+1>.global _start</font></tt></pre>

<pre><tt><font size=+1>_start:</font></tt></pre>

<pre><tt><font size=+1>ld24 sp, _stack</font></tt></pre>

<pre><tt><font size=+1>ldi fp, #0</font></tt></pre>

<pre><tt><font size=+1># Clear the BSS. Do it in two parts for efficiency: longwords first</font></tt></pre>

<pre><tt><font size=+1># for most of it, then the remaining 0 to 3 bytes.</font></tt></pre>

<pre><tt><font size=+1>ld24 r2, __bss_start ; R2 = start of BSS</font></tt></pre>

<pre><tt><font size=+1>ld24 r3, _end ; R3 = end of BSS + 1</font></tt></pre>

<pre><tt><font size=+1>sub r3, r2 ; R3 = BSS size in bytes</font></tt></pre>

<pre><tt><font size=+1>mv r4, r3</font></tt></pre>

<pre><tt><font size=+1>srli r4, #2 ; R4 = BSS size in longwords (rounded down)</font></tt></pre>

<pre><tt><font size=+1>ldi r1, #0 ; clear R1 for longword store</font></tt></pre>

<pre><tt><font size=+1>addi r2, #-4 ; account for pre-inc store</font></tt></pre>

<pre><tt><font size=+1>beqz r4, .Lendloop1 ; any more to go?</font></tt></pre>

<pre><tt><font size=+1>.Lloop1:</font></tt></pre>

<pre><tt><font size=+1>st r1, @+r2 ; yep, zero out another longword</font></tt></pre>

<pre><tt><font size=+1>addi r4, #-1 ; decrement count</font></tt></pre>

<pre><tt><font size=+1>bnez r4, .Lloop1 ; go do some more</font></tt></pre>

<pre><tt><font size=+1>.Lendloop1:</font></tt></pre>

<pre><tt><font size=+1>and3 r4, r3, #3 ; get no. of remaining BSS bytes to clear</font></tt></pre>

<pre><tt><font size=+1>addi r2, #4 ; account for pre-inc store</font></tt></pre>

<pre><tt><font size=+1>beqz r4, .Lendloop2 ; any more to go?</font></tt></pre>

<pre><tt><font size=+1>.Lloop2:</font></tt></pre>

<pre><tt><font size=+1>stb r1, @r2 ; yep, zero out another byte</font></tt></pre>

<pre><tt><font size=+1>addi r2, #1 ; bump address</font></tt></pre>

<pre><tt><font size=+1>addi r4, #-1 ; decrement count</font></tt></pre>

<pre><tt><font size=+1>bnez r4, .Lloop2 ; go do some more</font></tt></pre>

<pre><tt><font size=+1>.Lendloop2:</font></tt></pre>

<pre><tt><font size=+1># Run code in the .init section.</font></tt></pre>

<pre><tt><font size=+1># This will queue the .fini section to be run with atexit.</font></tt></pre>

<pre><tt><font size=+1>bl __init</font></tt></pre>

<pre><tt><font size=+1># Call main, then exit.</font></tt></pre>

<pre><tt><font size=+1>bl main</font></tt></pre>

<pre><tt><font size=+1>bl exit</font></tt></pre>

<pre><tt><font size=+1># If that fails just loop.</font></tt></pre>

<pre><tt><font size=+1>.Lexit:</font></tt></pre>

<pre><tt><font size=+1>bra .Lexit</font></tt></pre>
</blockquote>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000003"></a><b><i><font size=+2>Producing
S-records for M32R/X/D targets</font></i></b><a NAME="38616"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000005"></a><font size=+1>The following command reads
the contents of ‘<tt>hello.x</tt>’, converts the code and data into S-records,
and puts the result into ‘<a NAME="M32R/X/D"></a> <tt>hello.srec</tt>’.</font></div>

<div CLASS="CodeExample">
<blockquote>
<blockquote><a NAME="pgfId=1000006"></a><tt><font size=+1>m32r-elf-objcopy
-O srec hello.x hello.srec</font></tt></blockquote>
</blockquote>
</div>

<div CLASS="Body"><a NAME="pgfId=1000007"></a><font size=+1>The following
example shows the first few lines of the resulting ‘<tt>hello.srec</tt>’
S-record.</font></div>

<blockquote>
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000008"></a><tt><font size=+1>S00D000068656C6C6F2E7372656303</font></tt></div>

<p><br><tt><font size=+1>S11801002D7F2E7F1D8FF000E0006DF4FE0000FEFE001B281F54</font></tt>
<br><tt><font size=+1>S11801158D2EEF2DEF1FCEEF1000006D00F000E20075C0E300C8</font></tt>
<br><tt><font size=+1>S118012A75F4032214835402610042FCF000B0840003216244B4</font></tt>
<br><tt><font size=+1>S118013FFFB094FFFF84C300034204F000B08400042102420148</font></tt></blockquote>
</blockquote>

<div CLASS="Heading1"><a NAME="pgfId=1000010"></a><b><i><font size=+2>Assembler
support for M32R/X/D targets</font></i></b><a NAME="21464"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000014"></a><font size=+1>For a list of available generic
assembler options, see <a href="../5_ut/a_Using_AS/asCommandLine_Options.html#Top" CLASS="XRef">Command-line
options</a> in&nbsp;<a NAME="M32R/X/D"></a><a href="../5_ut/a_Using_AS/as.html#Top"><i>Using
</i><tt>as</tt></a> in
<b><i>GNUPro Utilities</i></b>. In addition, the
following M32R/X/D-specific command-line options are supported.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000016"></a><tt><font size=+1>-m32rx</font></tt></div>

<blockquote><font size=+1>Support the extended m32rx instruction set</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000017"></a><tt><font size=+1>-O</font></tt></div>

<blockquote><font size=+1>Try to combine instructions in parallel (M32R/X
only)</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000018"></a><tt><font size=+1>-warn-explict-parallel-conflicts</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000019"></a><tt><font size=+1>-no-warn-explict-parallel-conflicts</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000020"></a><tt><font size=+1>-Wp</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000021"></a><tt><font size=+1>-Wnp</font></tt></div>

<blockquote><font size=+1>Warn (or don’t warn with <tt>-no-warn-explict-parallel-conflicts</tt>
or <tt>-Wnp</tt> ) when parallel instructions conflict. The default is
to issue the warning.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000022"></a><tt><font size=+1>-warn-unmatched-high</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000023"></a><tt><font size=+1>-no-warn-unmatched-high</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000024"></a><tt><font size=+1>-Wuh</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000025"></a><tt><font size=+1>-Wnuh</font></tt></div>

<blockquote><font size=+1>Warn (or don’t warn with <tt>-no-warn-unmatched-high</tt>
or <tt>-Wnuh</tt> ) if a ‘<tt>high</tt>’ or ‘<tt>shigh</tt>’ relocation
has no matching ‘<tt>low</tt>’ relocation. The default is no warning.</font></blockquote>

<blockquote>
<div CLASS="Body"><a NAME="pgfId=1000026"></a><font size=+1>Syntax for
M32R/X/D is based on the syntax in Mitsubishi’s <b><i>M32R Family Software
Manual</i></b>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000027"></a><font size=+1>The M32R/X/D
assembler supports ‘<tt>;</tt>’ (semi-colon) and ‘<tt>#</tt>’ (pound).
Both characters are line comment characters when used in column zero. The
semi-colon may also be used to start a comment anywhere within a line.</font></div>
</blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000028"></a><tt><font size=+1>||</font></tt></div>

<blockquote><font size=+1>Specify that two instructions are executed in
parallel by placing them on the same line, separated by ‘<tt>||</tt>’.
Use the following example’s input, for instance.</font></blockquote>

<blockquote>
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000029"></a><font size=+1>mv r1,r2 || mv r2,r1</font></pre>
</blockquote>
</blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000030"></a><font size=+1>These
two instructions are executed in parallel.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000031"></a><font size=+1>A new syntax
has been added to explicitly allow specifying two instructions executed
sequentially.</font></div>
</blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000032"></a><tt><font size=+1>-></font></tt></div>

<blockquote><font size=+1>Specify that two instructions are executed sequentially
by placing them on the same line, separated by ‘<tt>-></tt>’. This is useful
when assembling with optimization turned on and you explicitly want to
state that two instructions are to be executed sequentially and not in
parallel.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000033"></a><font size=+1>Use
the following example’s input, for instance.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000034"></a><font size=+1>mv r1,r2 -> ld r1,@r2</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000035"></a><font size=+1>The
‘<tt>mv r1,r2</tt> ’ instruction is first executed, and then the ‘<tt>ld
r1,@r2</tt>’ instruction is executed.</font></div>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000037"></a><a NAME="_Toc435604869"></a><b><i><font size=+2>Register
names for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<p><a NAME="pgfId=1000039"></a><font size=+1>You can use the predefined
symbols ‘<a NAME="M32R/X/D"></a> <tt>r0</tt>’ through ‘<tt>r15</tt>’ to
refer to the M32R/X/D registers. You can also use ‘<tt>sp</tt>’ as an alias
for ‘<tt>r15</tt>’, ‘<tt>lr</tt>’ as an alias for ‘<tt>r14</tt> ’, and
‘<tt>fp</tt>’ as an alias for ‘<tt>r13</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000040"></a><font size=+1>The M32R/X/D
also has predefined symbols for the control registers and status bits described
in <a href="m32r.html#11239" CLASS="XRef">Symbols and usage for M32R/X/D
processors</a>.</font></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000074"></a><a NAME="11239"></a><b><font size=+1>Symbols
and usage for M32R/X/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000047"></a><b><i>Symbol</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000049"></a><b><i>Usage</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000051"></a><tt>cr0 </tt>through
<tt>cr15</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000053"></a>Control registers</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000055"></a><tt>psw</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000057"></a>Processor status word
(alias for ‘<tt>cr0</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000059"></a><tt>cbr</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000061"></a>Condition bit register
(alias for ‘<tt>cr1</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000063"></a><tt>spi</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000065"></a>Interrupt stack pointer
(alias for ‘<tt>cr2</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000067"></a><tt>spu</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000069"></a>User stack pointer (alias
for ‘<tt>cr3</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000071"></a><tt>bpc</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000073"></a>Backup program counter
(alias for ‘<tt>cr6</tt>’)</div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000076"></a><a NAME="_Toc435604870"></a><b><i><font size=+2>Addressing
modes for M32R/X/D targets</font></i></b>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000078"></a><font size=+1>The assembler understands
the following addressing modes for the M32R/X/D. The ‘<a NAME="M32R/X/D"></a><tt>Rn</tt>’
symbol in the following examples refers to any of the specifically numbered
registers or register pairs, but not the control registers.</font></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000116"></a><b><font size=+1>Symbols
and addressing modes for the M32R/X/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000081"></a><b><i>Symbol</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000083"></a><b><i>Addressing Mode</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000085"></a><tt>Rn</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000087"></a>Register direct</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000089"></a><tt>@Rn</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000091"></a>Register indirect</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000093"></a><tt>@Rn+</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000095"></a>Register indirect with
post-increment</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000097"></a><tt>@Rn-</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000099"></a>Register indirect with
post-decrement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000101"></a><tt>@-Rn</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000103"></a>Register indirect with
pre-decrement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000105"></a><tt>@(disp, Rn)</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000107"></a>Register indirect with
displacement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000109"></a><tt>addr</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000111"></a>PC relative address (for
branch or rep)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000113"></a><tt>#imm</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000115"></a>Immediate data</div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000118"></a><a NAME="_Toc435604871"></a><b><i><font size=+2>Floating
point for M32R/X/D targets</font></i></b>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000119"></a><font size=+1>Although the M32R/X/D has
no hardware floating point, the ‘<tt>.float</tt>’ and ‘<tt>.double</tt>
’ directives generate IEEE-format floating-point values for compatibility
with other development tools.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000121"></a><a NAME="_Toc435604872"></a><b><i><font size=+2>Pseudo
opcodes for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000123"></a><font size=+1>M32R/X/D processors use one
pseudo opcode.</font><a NAME="M32R/X/D"></a></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000124"></a><font size=+1><tt>.debugsym </tt><i>&lt;<tt>label</tt>></i></font></div>

<blockquote><font size=+1>Create a ‘<i> &lt;<tt>label</tt>></i>’ label
with the value of the next instruction that follows the pseudo opcode.
Unlike normal labels, the label created with ‘<tt>.debugsym</tt>’ does
not force the next instruction to be aligned to a 32-bit boundary (in other
words, it does not generate a nop, if the previous instruction is a 16-bit
instruction, and the instruction that follows is also a 16-bit instruction).</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000126"></a><a NAME="_Toc435604873"></a><b><i><font size=+2>Opcodes
for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000127"></a><font size=+1>For detailed information
on the M32R/X/D machine instruction set, see <b><i>M32R Family Software
Manual</i></b>. The GNU assembler implements all the standard M32R/X/D
opcodes.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000128"></a><font size=+1>The assembler
does not support the ‘<tt>:8</tt>’ or ‘<tt>:24</tt>’ syntax for explicitly
specifying the size of the branch instruction. Instead, the assembler supports
the ‘<tt>.s</tt>’ suffix to specify a short branch, and the ‘<tt>.l</tt>
’ suffix to specify a long branch.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000129"></a><font size=+1>For example,
‘<tt>bra label:8</tt> ’ becomes ‘<tt>bra.s label</tt>’ and ‘<tt>bra label:24</tt>’
becomes ‘<tt>bra.l label</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000130"></a><font size=+1>The assembler
does not support the ‘<tt>:8</tt>’ or ‘<tt>:16</tt>’ syntax for explicitly
specifying the size of an immediate constant. Instead, the assembler supports
the ‘<tt>ldi8</tt>’ and ‘<tt>ldi16</tt>’mnemonics. For example, ‘<tt>ldi
r0, 1:8</tt>’ becomes ‘<tt>ldi8 r0, 1</tt>’ and ‘<tt>ldi r0, 1:16</tt>
’ becomes ‘<tt>ldi16 r0, 1</tt>’.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000132"></a><a NAME="_Toc435604874"></a><b><i><font size=+2>Synthetic
instructions for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000134"></a><font size=+1>Synthetic instructions are
aliases for existing instructions. They provide an additional and often
simpler way to specify an instruction.</font><a NAME="M32R/X/D"></a></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000204"></a><b><font size=+1>Synthetic
instructions for M32R/X/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000137"></a><b><i>Synthetic Instruction</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000139"></a><b><i>Real Instruction</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000141"></a><tt>bc.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000143"></a><tt>bc label [8-bit offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000145"></a><tt>bc.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000147"></a><tt>bc label [24-bit
offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000149"></a><tt>bcl.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000151"></a><tt>bcl label</tt> [8
bit offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000153"></a><tt>bcl.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000155"></a><tt>bcl label</tt> [24
bit offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000157"></a><tt>bl.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000159"></a><tt>bl label [8-bit offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000161"></a><tt>bl.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000163"></a><tt>bl label [24-bit
offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000165"></a><tt>bnc.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000167"></a><tt>bnc label [8-bit
offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000169"></a><tt>bnc.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000171"></a><tt>bnc label [24-bit
offset]</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000173"></a><tt>bncl.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000175"></a><tt>bncl label</tt> [8
bit offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000177"></a><tt>bncl.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000179"></a><tt>bncl label</tt> [24
bit offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000181"></a><tt>bra.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000183"></a><tt>bra label </tt>[8-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000185"></a><tt>bra.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000187"></a><tt>bra label </tt>[24-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000189"></a><tt>ldi8 reg, #const</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000191"></a><tt>ldi reg, #const </tt>[8-bit
constant]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000193"></a><tt>ldi16 reg, #const</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000195"></a><tt>ldi reg, #const </tt>[16-bit
constant]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000197"></a><tt>push reg</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000199"></a><tt>st reg, @-sp</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000201"></a><tt>pop reg</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000203"></a><tt>ld reg, @sp+</tt></div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000206"></a><b><i><font size=+2>Writing
assembler code for M32R/X/D targets</font></i></b><a NAME="M32R/X/D"></a>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000207"></a><font size=+1>The best way to write assembler
code is to write a small C program, compile it with the ‘<tt>-S</tt>’ flag,
and study the assembler code GCC produces.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000208"></a><font size=+1>The assembler
code in the following example (‘<tt>hello.s</tt>’) is from the ‘<tt>hello.c</tt>’
example. It was created with ‘<tt>m32r-elf-gcc -S -O2 hello.c</tt>’. See
<a href="../5_ut/a_Using_AS/as.html"><i>Using
</i><tt>as</tt></a>
in <b><i>GNUPro Utilities</i></b> for more information on GNU <a href="../5_ut/a_Using_AS/asAssembler_Directives.html#Top">assembler
directives</a>, or <i><a href="../5_ut/a_Using_AS/asas_the_GNU_Assembler.html#Top">pseudo-opcodes<a NAME="marker=1000209"></a></a></i>.
See the<b> <i>M32R Family Software Manual</i></b> for more information
on the instruction set, and syntax.</font></div>

<div CLASS="CodeExample">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000210"></a><font size=+1>gcc2_compiled.:</font></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><font size=+1>.section .rodata</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC0:</font></pre>

<pre><font size=+1>.string"hello world!\n"</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC1:</font></pre>

<pre><font size=+1>.string"%d + %d = %d\n"</font></pre>

<pre><font size=+1>.section .text</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.globalmain</font></pre>

<pre><font size=+1>.type main,@function</font></pre>

<pre><font size=+1>main:</font></pre>

<pre><font size=+1>; BEGIN PROLOGUE ; vars= 0, regs= 2, args= 0, extra= 0</font></pre>

<pre><font size=+1>push r8</font></pre>

<pre><font size=+1>push lr</font></pre>

<pre><font size=+1>; END PROLOGUE</font></pre>

<pre><font size=+1>ld24 r8,#a</font></pre>

<pre><font size=+1>ldi r4,#3</font></pre>

<pre><font size=+1>st r4,@(r8)</font></pre>

<pre><font size=+1>ld24 r0,#.LC0</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>ld24 r0,#.LC1</font></pre>

<pre><font size=+1>ld r1,@(r8)</font></pre>

<pre><font size=+1>ld24 r4,#c</font></pre>

<pre><font size=+1>ldi r2,#4</font></pre>

<pre><font size=+1>add3 r3,r1,#4</font></pre>

<pre><font size=+1>st r3,@(r4)</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>; EPILOGUE</font></pre>

<pre><font size=+1>pop lr</font></pre>

<pre><font size=+1>pop r8</font></pre>

<pre><font size=+1>jmp lr</font></pre>

<pre><font size=+1>.Lfe1:</font></pre>

<pre><font size=+1>.size main,.Lfe1-main</font></pre>

<pre><font size=+1>.comma,4,4</font></pre>

<pre><font size=+1>.commc,4,4</font></pre>

<pre><font size=+1>.ident"GCC: (GNU) 2.7-m32r-970408"</font></pre>
</blockquote>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000211"></a><font size=+1>To assemble
the ‘<tt>hello.s</tt> ’ file, use the following input.</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000212"></a><tt><font size=+1>m32r-elf-as
hello.s -o hello.o</font></tt></div>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000213"></a><font size=+1>The following
are some tips for assembler programmers.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000214"></a><font size=+1>To clear the ‘<tt>CBR</tt>’ register,
just one instruction can be used:</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000215"></a><font size=+1><tt>cmp Rx,Rx</tt>
total 2 bytes</font></blockquote>
</blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote><a NAME="pgfId=1000216"></a><font size=+1>Where ‘<tt>Rx</tt>
’, is an arbitrary register. Note the operation does not destroy the contents
of ‘<tt>Rx</tt>’. The previous code example is smaller than the following
code:</font></blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000217"></a><tt><font size=+1>ldi Rx,#1</font></tt></blockquote>
</blockquote>
</div>

<ul TYPE=SQUARE>&nbsp;
<br><font size=+1><tt>cmpi Rx,#0</tt> total 6 bytes and destroys ‘<tt>Rx</tt>’.</font>
<br>&nbsp;
<li CLASS="Bullet">
<a NAME="pgfId=1000218"></a><font size=+1>To set the ‘<tt>CBR</tt>’ register,
there are several methods. First, try using the following example’s input.</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000219"></a><tt><font size=+1>ldi Rx,#-1</font></tt>
<br><font size=+1><tt>addv R0,R0</tt> <tt>total 4 bytes</tt></font></blockquote>
</blockquote>
</div>

<ul TYPE=SQUARE>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000220"></a><font size=+1>Alternatively,
try using the following example’s input.</font></div>

<blockquote>&nbsp;
<div CLASS="CodeExample2"><a NAME="pgfId=1000221"></a><tt><font size=+1>ldi
Rx,#-2</font></tt></div>

<p><br><tt><font size=+1>addx R0,R0 total 4 bytes</font></tt></blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000222"></a><font size=+1>The
previous code examples are smaller than the following code example:</font></div>

<blockquote>&nbsp;
<div CLASS="CodeExample2"><a NAME="pgfId=1000223"></a><tt><font size=+1>ldi
Rx,#0</font></tt></div>

<p><br><tt><font size=+1>cmpi Rx,#1 total 6 bytes</font></tt></blockquote>

<li CLASS="Bullet">
<a NAME="pgfId=1000224"></a><font size=+1>To set a comparison result to
a register, there are some idioms for the M32R.</font></li>
</ul>

<div CLASS="BodyListFollow">
<blockquote><a NAME="pgfId=1000225"></a><font size=+1>For instance, try
using the following example’s input.</font></blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000226"></a><font size=+1>(a) ‘... <tt>flag = (x == 0);...</tt>’</font></pre>
</blockquote>
</blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000227"></a><font size=+1>cmpui Rx,#1</font></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><font size=+1>mvfc Rx,CBR total 4 byte</font></pre>

<pre CLASS="BodyListFollow"><a NAME="pgfId=1000228"></a><font size=+1>(b) ‘...<tt>flag = !(x op 0); ...</tt>’</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000229"></a><font size=+1>To
get the inverted result of comparison, first set ‘<tt>CBR</tt>’ using one
of the methods above, then, try using the following example’s input.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000230"></a><font size=+1>subx Rx,Rx</font></pre>

<pre><font size=+1>addi Rx,#1 <tt>total 4 byte</tt></font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000231"></a><font size=+1>The
previous example will provide better results than than the following code.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000232"></a><font size=+1>mvfc Rx,CBR</font></pre>

<pre><font size=+1>xor3 Rx,Rx,#1 total 6-byte</font></pre>
</blockquote>

<h6 CLASS="Label">
<a NAME="pgfId=1000233"></a><font size=+1>Note:</font></h6>
</blockquote>

<div CLASS="Note">
<blockquote><a NAME="pgfId=1000234"></a><font size=+1>The ‘<tt>subx Rx,Rx</tt>
’ operation is equivalent to the following code.</font></blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000235"></a><font size=+1>mvfc Rx,CBR</font></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><font size=+1>neg Rx,Rx</font></pre>
</blockquote>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000237"></a><b><i><font size=+2>M32R/X/D-specific
assembler error messages</font></i></b><a NAME="M32R/X/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000238"></a><font size=+1>The following error messages
may occur for M32R/X/D processors during assembly implementation.</font></div>

<div CLASS="BodyHang1">
<blockquote><a NAME="pgfId=1000239"></a><tt><font size=+1>Error: bad instruction</font></tt></blockquote>
</div>

<blockquote>
<blockquote><font size=+1>The instruction is misspelled or there is a syntax
error somewhere.</font></blockquote>
</blockquote>

<blockquote>
<div CLASS="BodyHang1"><a NAME="pgfId=1000240"></a><tt><font size=+1>Error:
expression too complex</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000241"></a><tt><font size=+1>Error:
unresolved expression that must be resolved</font></tt></div>

<blockquote><font size=+1>The instruction contains an expression that is
too complex; no relocation exists to handle it.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000242"></a><tt><font size=+1>Error:
relocation overflow</font></tt></div>

<blockquote><font size=+1>The instruction contains an expression that is
too large to fit in the field.</font></blockquote>
</blockquote>

<div CLASS="Heading1"><a NAME="pgfId=1000244"></a><b><i><font size=+2>Linker
support for M32R/X/D targets</font></i></b><a NAME="12202"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000249"></a><font size=+1>For a list of available generic
linker options, see <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Top" CLASS="XRef">Linker
scripts</a> in&nbsp;<a NAME="M32R/X/D"></a><a href="../5_ut/b_Usingld/ld.html"><i>Using
</i><tt>ld</tt></a>
in
<b><i>GNUPro Utilities</i></b>. In addition, the following M32R/X/D-specific
command-line option is supported.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=1000250"></a><tt><font size=+1>--defsym
_stack=0xnnnn</font></tt></div>

<blockquote><font size=+1>Specify the initial value for the stack pointer.
This assumes the application loads the stack pointer with the value of
‘<tt>_stack</tt>’ in the start up code.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000251"></a><font size=+1>The
initial value for the stack pointer is defined in the linker script with
the <tt>PROVIDE</tt> linker command. This allows the user to specify a
new value on the command line with the standard linker option ‘<tt>--defsym</tt>’.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000253"></a><a NAME="_Toc435604877"></a><b><i><font size=+2>Linker
script for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000254"></a><font size=+1>The GNU linker uses a linker
script to determine how to process each section in an object file, and
how to lay out the executable. The linker script is a declarative program
consisting of a number of directives. For instance, the ‘<tt>ENTRY ()</tt>’
directive specifies the symbol in the executable that will be the executable’s
entry point. Since linker scripts can be complicated to write, the linker
includes one built-in script that defines the default linking process.
For the M32R/X/D tools, the following example shows the default script.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000255"></a><font size=+1>Although this
script is somewhat lengthy, it is a generic script that will support all
ELF situations. In practice, generation of sections like ‘<tt>.rela.dtors</tt>’
are unlikely when compiling using embedded ELF tools.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000256"></a><font size=+1>OUTPUT_FORMAT("elf32-m32r", "elf32-m32r", "elf32-m32r")</font></pre>
</blockquote>
</div>

<blockquote>
<pre><font size=+1>OUTPUT_ARCH(m32r)</font></pre>

<pre><font size=+1>ENTRY(_start)</font></pre>

<pre><font size=+1>SEARCH_DIR( <i>&lt;installation directory path></i> );</font></pre>

<pre><font size=+1>SECTIONS</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>/* Read-only sections, merged into text segment: */</font></pre>

<pre><font size=+1>. = 0x200000;</font></pre>

<pre><font size=+1>.interp : { *(.interp) }</font></pre>

<pre><font size=+1>.hash : { *(.hash) }</font></pre>

<pre><font size=+1>.dynsym : { *(.dynsym) }</font></pre>

<pre><font size=+1>.dynstr : { *(.dynstr) }</font></pre>

<pre><font size=+1>.rel.text : { *(.rel.text) }</font></pre>

<pre><font size=+1>.rela.text : { *(.rela.text) }</font></pre>

<pre><font size=+1>.rel.data : { *(.rel.data) }</font></pre>

<pre><font size=+1>.rela.data : { *(.rela.data) }</font></pre>

<pre><font size=+1>.rel.rodata : { *(.rel.rodata) }</font></pre>

<pre><font size=+1>.rela.rodata : { *(.rela.rodata) }</font></pre>

<pre><font size=+1>.rel.got : { *(.rel.got) }</font></pre>

<pre><font size=+1>.rela.got : { *(.rela.got) }</font></pre>

<pre><font size=+1>.rel.ctors : { *(.rel.ctors) }</font></pre>

<pre><font size=+1>.rela.ctors : { *(.rela.ctors) }</font></pre>

<pre><font size=+1>.rel.dtors : { *(.rel.dtors) }</font></pre>

<pre><font size=+1>.rela.dtors : { *(.rela.dtors) }</font></pre>

<pre><font size=+1>.rel.init : { *(.rel.init) }</font></pre>

<pre><font size=+1>.rela.init : { *(.rela.init) }</font></pre>

<pre><font size=+1>.rel.fini : { *(.rel.fini) }</font></pre>

<pre><font size=+1>.rela.fini : { *(.rela.fini) }</font></pre>

<pre><font size=+1>.rel.bss : { *(.rel.bss) }</font></pre>

<pre><font size=+1>.rela.bss : { *(.rela.bss) }</font></pre>

<pre><font size=+1>.rel.plt : { *(.rel.plt) }</font></pre>

<pre><font size=+1>.rela.plt : { *(.rela.plt) }</font></pre>

<pre><font size=+1>.init : { *(.init) } =0</font></pre>

<pre><font size=+1>.plt : { *(.plt) }</font></pre>

<pre><font size=+1>.text :</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>*(.text)</font></pre>

<pre><font size=+1>/* .gnu.warning sections are handled specially by</font></pre>

<pre><font size=+1>elf32.em. */</font></pre>

<pre><font size=+1>*(.gnu.warning)</font></pre>

<pre><font size=+1>*(.gnu.linkonce.t*)</font></pre>

<pre><font size=+1>} =0</font></pre>

<pre><font size=+1>_etext = .;</font></pre>

<pre><font size=+1>PROVIDE (etext = .);</font></pre>

<pre><font size=+1>.fini : { *(.fini) } =0</font></pre>

<pre><font size=+1>.rodata : { *(.rodata) *(.gnu.linkonce.r*) }</font></pre>

<pre><font size=+1>.rodata1 : { *(.rodata1) }</font></pre>

<pre><font size=+1>/* Adjust the address for the data segment. We want to</font></pre>

<pre><font size=+1>adjust up to the same address within the page on the</font></pre>

<pre><font size=+1>next page up. */</font></pre>

<pre><font size=+1>. = ALIGN(32) + (ALIGN(8) &amp; (32 - 1));</font></pre>

<pre><font size=+1>.data :</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>*(.data)</font></pre>

<pre><font size=+1>*(.gnu.linkonce.d*)</font></pre>

<pre><font size=+1>CONSTRUCTORS</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>.data1 : { *(.data1) }</font></pre>

<pre><font size=+1>.ctors : { *(.ctors) }</font></pre>

<pre><font size=+1>.dtors : { *(.dtors) }</font></pre>

<pre><font size=+1>.got : { *(.got.plt) *(.got) }</font></pre>

<pre><font size=+1>.dynamic : { *(.dynamic) }</font></pre>

<pre><font size=+1>/* We want the small data sections together, so</font></pre>

<pre><font size=+1>single-instruction offsets can access them all, and</font></pre>

<pre><font size=+1>initialized data all before uninitialized, so we can</font></pre>

<pre><font size=+1>shorten the on-disk segment size. */</font></pre>

<pre><font size=+1>.sdata : { *(.sdata) }</font></pre>

<pre><font size=+1>_edata = .;</font></pre>

<pre><font size=+1>PROVIDE (edata = .);</font></pre>

<pre><font size=+1>__bss_start = .;</font></pre>

<pre><font size=+1>.sbss : { *(.sbss) *(.scommon) }</font></pre>

<pre><font size=+1>.bss : { *(.dynbss) *(.bss) *(COMMON) }</font></pre>

<pre><font size=+1>_end = . ;</font></pre>

<pre><font size=+1>PROVIDE (end = .);</font></pre>

<pre><font size=+1>/* Stabs debugging sections. */</font></pre>

<pre><font size=+1>.stab 0 : { *(.stab) }</font></pre>

<pre><font size=+1>.stabstr 0 : { *(.stabstr) }</font></pre>

<pre><font size=+1>.stab.excl 0 : { *(.stab.excl) }</font></pre>

<pre><font size=+1>.stab.exclstr 0 : { *(.stab.exclstr) }</font></pre>

<pre><font size=+1>.stab.index 0 : { *(.stab.index) }</font></pre>

<pre><font size=+1>.stab.indexstr 0 : { *(.stab.indexstr) }</font></pre>

<pre><font size=+1>.comment 0 : { *(.comment) }</font></pre>

<pre><font size=+1>/* DWARF debug sections.</font></pre>

<pre><font size=+1>Symbols in the .debug DWARF section are relative to the</font></pre>

<pre><font size=+1>beginning of the section so we begin .debug at 0. It’s</font></pre>

<pre><font size=+1>not clear yet what needs to happen for the others. */</font></pre>

<pre><font size=+1>.debug 0 : { *(.debug) }</font></pre>

<pre><font size=+1>.debug_srcinfo 0 : { *(.debug_srcinfo) }</font></pre>

<pre><font size=+1>.debug_aranges 0 : { *(.debug_aranges) }</font></pre>

<pre><font size=+1>.debug_pubnames 0 : { *(.debug_pubnames) }</font></pre>

<pre><font size=+1>.debug_sfnames 0 : { *(.debug_sfnames) }</font></pre>

<pre><font size=+1>.line 0 : { *(.line) }</font></pre>

<pre><font size=+1>PROVIDE (_stack = 0x3ffffc);</font></pre>

<pre><font size=+1>}</font></pre>
</blockquote>

<div CLASS="Heading1"><a NAME="pgfId=1000258"></a><b><i><font size=+2>Debugger
support for M32R/X/D targets</font></i></b><a NAME="23881"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000260"></a><font size=+1>GDB’s built-in software simulation
of the M32R/X/D processor allows the debugging of programs compiled for
the M32R/X/D without requiring any access to actual hardware. Activate
this mode in GDB by typing ‘<a NAME="M32R/X/D"></a> <tt>target sim</tt>
’. Then load code into the simulator by typing ‘<tt>load</tt>’ and debug
it in the normal fashion.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000261"></a><font size=+1>For the available
generic debugger options, see <i><a href="../3_dbug/b_Debugging_with_GDB/gdb.html#Top">Debugging
with GDB</a></i> in <b><i>GNUPro Debugging Tools</i></b>. There are no
M32R/X/D specific debugger command-line options.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000262"></a><font size=+1>Cygnus Insight
is the graphic user interface (GUI) for the GNUPro debugger. See <a href="../1_GS/int06.html#Top">Working
with Cygnus Insight, the visual debugger</a> in <b><i>GETTING STARTED</i></b>.</font></div>

<div CLASS="Heading1"><a NAME="pgfId=1000267"></a><b><i><font size=+2>Standalone
simulator for M32R/X/D targets</font></i></b><a NAME="10090"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000269"></a><font size=+1>The simulator supports the
general-registers (<a NAME="M32R/X/D"></a> <tt>r0</tt> to <tt>r15</tt>
), control-registers (<tt>psw</tt> , <tt>cbr</tt> , <tt>spi</tt> , <tt>spu</tt>
, and <tt>bpc</tt> ), and the accumulator. The simulator allocates a contiguous
chunk of memory starting at the ‘<tt>0</tt>’ address. The default memory
size is 8 MB.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000270"></a><font size=+1>Three run-time
command-line options are available with the simulator: <tt>-t</tt> , <tt>-v</tt>
, and
<tt>-p</tt> .</font></div>

<div CLASS="Label"><a NAME="pgfId=1000271"></a><font size=+1>Warning!</font></div>

<div CLASS="Note"><a NAME="pgfId=1000272"></a><font size=+1>Simulator cycle
counts are not intended to be extremely accurate in the following script
examples. Use them with caution.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000273"></a><font size=+1>The ‘<tt>-t</tt>’ command-line
option to the stand-alone simulator turns on instruction level tracing
as shown in the following segment.</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000274"></a><b><tt><font size=+1>m32r-elf-run
-t hello.x</font></tt></b></blockquote>
</blockquote>
</div>

<blockquote>
<blockquote><tt><font size=+1>0x00011c ld24 sp,0x100000 dr &lt;- 0x100000</font></tt>
<br><tt><font size=+1>0x000120 ldi fp,0 dr &lt;- 0x0</font></tt>
<br><tt><font size=+1>0x000122 nop</font></tt>
<br><tt><font size=+1>0x000124 ld24 r2,0x75c0 dr &lt;- 0x75c0</font></tt>
<br><tt><font size=+1>0x000128 ld24 r3,0x75f4 dr &lt;- 0x75f4</font></tt>
<br><tt><font size=+1>0x00012c sub r3,r2 dr &lt;- 0x34</font></tt>
<br><tt><font size=+1>0x00012e mv r4,r3 dr &lt;- 0x34</font></tt>
<br><tt><font size=+1>0x000130 srli r4,0x2 dr &lt;- 0xd</font></tt>
<br><tt><font size=+1>0x000132 ldi r1,0 dr &lt;- 0x0</font></tt>
<br><tt><font size=+1>0x000134 addi r2,-4 dr &lt;- 0x75bc</font></tt>
<br><tt><font size=+1>0x000136 nop</font></tt>
<br><tt><font size=+1>0x000138</font></tt>
<br><tt><font size=+1>. . .</font></tt></blockquote>

<li CLASS="Bullet">
<a NAME="pgfId=1000275"></a><font size=+1>The ‘<tt>-v</tt>’ command-line
option prints some simple statistics.</font></li>
</blockquote>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000276"></a><b><tt><font size=+1>m32r-elf-run
-v hello.x</font></tt></b></blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>&nbsp;
<br><tt><font size=+1>hello world!</font></tt>
<br><tt><font size=+1>3 + 4 = 7</font></tt>
<br><tt><font size=+1>Total: 3808 insns</font></tt>
<br><tt><font size=+1>Fill nops: 609</font></tt></blockquote>

<li CLASS="Bullet">
<a NAME="pgfId=1000277"></a><font size=+1>The ‘<tt>-p</tt>’ command prints
profiling statistics.</font></li>
</blockquote>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000278"></a><tt><font size=+1>m32r-elf-run
-p hello.x</font></tt></blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>&nbsp;
<br><tt><font size=+1>Hello world!</font></tt>
<br><tt><font size=+1>3 + 4 = 7</font></tt>
<br><tt><font size=+1>Instruction Statistics</font></tt>
<p><tt><font size=+1>Total: 3796 insns</font></tt>
<p><tt><font size=+1>add: 75: *****</font></tt>
<br><tt><font size=+1>add3: 123: ********</font></tt>
<br><tt><font size=+1>and: 3:</font></tt>
<br><tt><font size=+1>and3: 61: ****</font></tt>
<br><tt><font size=+1>or: 28: *</font></tt>
<br><tt><font size=+1>or3: 3:</font></tt>
<br><tt><font size=+1>addi: 222: ***************</font></tt>
<br><tt><font size=+1>bc8: 9:</font></tt>
<br><tt><font size=+1>bc24: 3:</font></tt>
<br><tt><font size=+1>beq: 23: *</font></tt>
<br><tt><font size=+1>beqz: 131: ********</font></tt>
<br><tt><font size=+1>bgez: 8:</font></tt>
<br><tt><font size=+1>bgtz: 2:</font></tt>
<br><tt><font size=+1>blez: 42: **</font></tt>
<br><tt><font size=+1>bltz: 6:</font></tt>
<br><tt><font size=+1>bnez: 252: *****************</font></tt>
<br><tt><font size=+1>bl8: 11:</font></tt>
<br><tt><font size=+1>bl24: 82: *****</font></tt>
<br><tt><font size=+1>bnc8: 52: ***</font></tt>
<br><tt><font size=+1>bne: 1:</font></tt>
<br><tt><font size=+1>bra8: 29: *</font></tt>
<br><tt><font size=+1>bra24: 9:</font></tt>
<br><tt><font size=+1>cmp: 28: *</font></tt>
<br><tt><font size=+1>cmpu: 34: **</font></tt>
<br><tt><font size=+1>cmpui: 2:</font></tt>
<br><tt><font size=+1>jl: 7:</font></tt>
<br><tt><font size=+1>jmp: 100: ******</font></tt>
<br><tt><font size=+1>ld: 93: ******</font></tt>
<br><tt><font size=+1>ld-d: 277: ******************</font></tt>
<br><tt><font size=+1>ldb: 77: *****</font></tt>
<br><tt><font size=+1>ldb-d: 6:</font></tt>
<br><tt><font size=+1>ldh-d: 38: **</font></tt>
<br><tt><font size=+1>ldub: 23: *</font></tt>
<br><tt><font size=+1>lduh-d: 23: *</font></tt>
<br><tt><font size=+1>ld-plus: 158: **********</font></tt>
<br><tt><font size=+1>ld24: 55: ***</font></tt>
<br><tt><font size=+1>ldi8: 163: ***********</font></tt>
<br><tt><font size=+1>ldi16: 5:</font></tt>
<br><tt><font size=+1>mv: 282: *******************</font></tt>
<br><tt><font size=+1>neg: 26: *</font></tt>
<br><tt><font size=+1>nop: 584: ****************************************</font></tt>
<br><tt><font size=+1>sll: 3:</font></tt>
<br><tt><font size=+1>sll3: 7:</font></tt>
<br><tt><font size=+1>slli: 25: *</font></tt>
<br><tt><font size=+1>srai: 25: *</font></tt>
<br><tt><font size=+1>srli: 35: **</font></tt>
<br><tt><font size=+1>st: 52: ***</font></tt>
<br><tt><font size=+1>st-d: 195: *************</font></tt>
<br><tt><font size=+1>stb: 27: *</font></tt>
<br><tt><font size=+1>stb-d: 4:</font></tt>
<br><tt><font size=+1>sth: 25: *</font></tt>
<br><tt><font size=+1>sth-d: 11:</font></tt>
<br><tt><font size=+1>st-plus: 13:</font></tt>
<br><tt><font size=+1>st-minus: 164: ***********</font></tt>
<br><tt><font size=+1>sub: 52: ***</font></tt>
<br><tt><font size=+1>trap: 2:</font></tt>
<p><tt><font size=+1>Memory Access Statistics</font></tt>
<p><tt><font size=+1>Total read: 1891 accesses</font></tt>
<br><tt><font size=+1>Total write: 491 accesses</font></tt>
<p><tt><font size=+1>QI read: 83: **</font></tt>
<br><tt><font size=+1>QI write: 31: *</font></tt>
<br><tt><font size=+1>HI read: 38: *</font></tt>
<br><tt><font size=+1>HI write: 36: *</font></tt>
<br><tt><font size=+1>SI read: 528: *****************</font></tt>
<br><tt><font size=+1>SI write: 424: **************</font></tt>
<br><tt><font size=+1>UQI read: 23:</font></tt>
<br><tt><font size=+1>UHI read: 23:</font></tt>
<br><tt><font size=+1>USI read: 1196: ****************************************</font></tt>
<p><tt><font size=+1>Model m32r/d timing information:</font></tt>
<p><tt><font size=+1>Taken branches: 532</font></tt>
<br><tt><font size=+1>Untaken branches: 237</font></tt>
<br><tt><font size=+1>Cycles stalled due to branches: 1064</font></tt>
<br><tt><font size=+1>Cycles stalled due to loads: 670</font></tt>
<br><tt><font size=+1>Total cycles (approx): 4946</font></tt>
<p><tt><font size=+1>Fill nops: 584</font></tt></blockquote>
</blockquote>

<h3 CLASS="Heading1">
<a NAME="pgfId=1000280"></a><a NAME="_Toc435604883"></a><b><i><font size=+2>Overlays
for the M32R/X/D targets</font></i></b></h3>

<div CLASS="Body"><a NAME="pgfId=1000282"></a><font size=+1>Overlays are
sections of code or data, which are to be loaded as part of a single memory
image, but are to be run or used at a common memory address. At run time,
an overlay manager will copy the sections in and out of the runtime memory
address. This approach can be useful, for example, when a certain region
of memory is faster than another section.</font><a NAME="M32R/X/D"></a></div>

<div CLASS="Body"><a NAME="pgfId=1000283"></a><font size=+1>A simple, portable
runtime overlay manager is provided in the ‘<tt>examples</tt>’ directory.
To access the examples directory follow the instructions for installing
the entire source tree. The full path will be:</font></div>

<div CLASS="CodeExample"><a NAME="pgfId=1000284"></a><font size=+1>‘<tt>/usr/cygnus/m32r-</tt>&lt;yymmdd><tt>/src/examples</tt>
’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000285"></a><font size=+1>Replace ‘ &lt;yymmdd>
’ with the release date found on the CD.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000286"></a><font size=+1>The sample
overlay manager may be used as is, or as a prototype to develop a 3rd party
overlay manager (or adapt an existing one for use with the GDB debugger).
It is intended to be extremely simple, easy to understand, but not particularly
sophisticated.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000287"></a><font size=+1>The overlay
manager has a single entry point as a function called ‘<tt>OverlayLoad(ovly_number)</tt>’.
It looks up the overlay in a table called ‘<tt>ovly_table</tt>’ to find
the corresponding section’s load address and runtime address; then it copies
the section from its load address into its runtime address. ‘<tt>OverlayLoad</tt>
’ must be called before code, or data in an overlay section can be used
by the program. It is up to the programmer to keep track of which overlays
have been loaded. The ‘ _ovly_table’ table is built by the linker from
information provided by the programmer in the linker script; see the example
with <a href="m32r.html#_Toc435604885" CLASS="XRef">Linker script with
overlays for M32R/X/D targets</a>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000291"></a><font size=+1>The example
program contains four overlay sections, which are mapped into two runtime
regions of memory. Sections ‘<tt>.ovly0</tt>’ and ‘<tt>.ovly1</tt>’ are
both mapped into the region starting at ‘<tt>0x300000</tt>’, and sections
‘<tt>.ovly2</tt> ’ and ‘<tt>.ovly3</tt>’ are both mapped into the region
starting at ‘<tt> 0x380000</tt>’.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000293"></a><a NAME="_Toc435604885"></a><b><i><font size=+2>Linker
script with overlays for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000294"></a><font size=+1>To build a program with overlays
requires a customized linker script. Our example program is built with
the script ‘<tt>m32rtext.ld</tt>’, found in the ‘<tt>examples/overlay</tt>
’ directory. This is just a modified version of the default linker script,
with two parts added.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000295"></a><font size=+1>The first added
part describes the overlay sections, and must be located in the ‘<tt>SECTIONS</tt>’
block, before the ‘<tt>.text</tt>’ and ‘<tt>.data</tt>’ sections. Here
we use the new linker command ‘<tt>OVERLAY</tt>’, which allows the specification
of groups of sections sharing a common runtime address range.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000296"></a><font size=+1>SECTIONS</font></pre>
</blockquote>
</div>

<blockquote>
<pre><font size=+1>{</font></pre>

<pre><font size=+1>OVERLAY 0x300000 : AT (0x400000)</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>.ovly0 { foo.o(.text) }</font></pre>

<pre><font size=+1>.ovly1 { bar.o(.text) }</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>OVERLAY 0x380000 : AT (0x480000)</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>.ovly2 { baz.o(.text) }</font></pre>

<pre><font size=+1>.ovly3 { grbx.o(.text) }</font></pre>

<pre><font size=+1>}</font></pre>
<font size=+1>[...]</font></blockquote>

<div CLASS="Body"><a NAME="pgfId=1000297"></a><font size=+1>The ‘<tt>OVERLAY</tt>’
command has two arguments: first, the base address where all of the overlay
sections link and run; second, the address where the first overlay section
loads.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000298"></a><font size=+1>In the example,
the ‘<tt>.ovly1</tt> ’ section will load at ‘<tt>0x400000 + SIZEOF(.ovly0)</tt>’.
For a full description of the ‘<tt>OVERLAY</tt>’ linker command, see <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Output_section_type" CLASS="XRef">Output
section type</a> and <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Overlay_description" CLASS="XRef">Overlay
description</a> in <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Top" CLASS="XRef">Linker
scripts</a> in <a href="../5_ut/b_Usingld/ld.html"><i>Using </i><tt>ld</tt></a>
in <b><i>GNUPro Utilities</i></b>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000305"></a><font size=+1>The ‘<tt>OVERLAY</tt>’
command is really just a syntactic convenience. If you need finer control
over where the individual sections will be loaded, you can use the following
example’s syntax.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000306"></a><font size=+1>SECTIONS</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>.ovly0 0x300000 : AT (0x400000) { foo.o(.text) }</font></pre>

<pre><font size=+1>.ovly1 0x300000 : AT (0x410000) { bar.o(.text) }</font></pre>

<pre><font size=+1>.ovly2 0x380000 : AT (0x420000) { baz.o(.text) }</font></pre>

<pre><font size=+1>.ovly3 0x380000 : AT (0x430000) { grbx.o(.text) }</font></pre>

<pre><font size=+1>[...]</font></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000307"></a><font size=+1>The second
addition to the linker script actually builds the ‘<tt>_ovly_table</tt>’
table, which will be used by the sample runtime overlay manager. This table
has several entries for each overlay, and must be located somewhere in
the ‘<tt>.data</tt> ’ section:</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000308"></a><tt><font size=+1>.data
:</font></tt></div>

<p><br><tt><font size=+1>{</font></tt>
<br><tt><font size=+1>[...]</font></tt>
<br><tt><font size=+1>_ovly_table = .;</font></tt>
<br><tt><font size=+1>LONG(ABSOLUTE(ADDR(.ovly0)));</font></tt>
<br><tt><font size=+1>LONG(SIZEOF(.ovly0));</font></tt>
<br><tt><font size=+1>LONG(LOADADDR(.ovly0));</font></tt>
<br><tt><font size=+1>LONG(0);</font></tt>
<br><tt><font size=+1>LONG(ABSOLUTE(ADDR(.ovly1)));</font></tt>
<br><tt><font size=+1>LONG(SIZEOF(.ovly1));</font></tt>
<br><tt><font size=+1>LONG(LOADADDR(.ovly1));</font></tt>
<br><tt><font size=+1>LONG(0);</font></tt>
<br><tt><font size=+1>LONG(ABSOLUTE(ADDR(.ovly2)));</font></tt>
<br><tt><font size=+1>LONG(SIZEOF(.ovly2));</font></tt>
<br><tt><font size=+1>LONG(LOADADDR(.ovly2));</font></tt>
<br><tt><font size=+1>LONG(0);</font></tt>
<br><tt><font size=+1>LONG(ABSOLUTE(ADDR(.ovly3)));</font></tt>
<br><tt><font size=+1>LONG(SIZEOF(.ovly3));</font></tt>
<br><tt><font size=+1>LONG(LOADADDR(.ovly3));</font></tt>
<br><tt><font size=+1>LONG(0);</font></tt>
<br><tt><font size=+1>_novlys = .;</font></tt>
<br><tt><font size=+1>LONG((_novlys - _ovly_table) / 16);</font></tt>
<br><tt><font size=+1>[...]</font></tt>
<br><tt><font size=+1>}</font></tt></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000309"></a><b><i><font size=+2>Example
overlay program for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000310"></a><font size=+1>The example program has four
functions: <tt>foo</tt> , <tt>bar</tt> , <tt>baz</tt> , and <tt>grbx</tt>
. Each is in a separate overlay section. The ‘<tt>foo</tt>’ and ‘<tt> bar</tt>’
functions are both linked to run at the ‘<tt>0x300000</tt> ’ address, while
the ‘<tt>baz</tt>’ and ‘<tt>grbx</tt>’ functions are both linked to run
at the ‘<tt>0x380000</tt>’ address.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000311"></a><font size=+1>The main program
calls ‘<tt> OverlayLoad</tt>’ once before calling each of the overlaid
functions, giving it the overlay number of the respective overlay. The
overlay manager, using the table ‘<tt>_ovly_table</tt>’, that was built
up by the linker script, copies each overlayed function into the appropriate
region of memory before it is called.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000312"></a><font size=+1>In order to
compile and link the example overlay manager, use the following example’s
input.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000313"></a><font size=+1>m32r-elf-gcc -g -Tm32rdata.ld -oovlydata maindata.c ovlymgr.c</font></pre>
</blockquote>
</div>

<h4 CLASS="Heading2">
<a NAME="pgfId=1000314"></a>Debugging the overlay program for M32R/X/D
targets</h4>

<div CLASS="Body"><a NAME="pgfId=1000315"></a><font size=+1>Using GDB’s
built-in overlay support, it is possible to debug this program even though
several of the functions share an address range. After loading the program,
give GDB the ‘<tt>overlay auto</tt>’ command. GDB then detects the actions
of the overlay manager on the target, and can step into overlayed functions,
showing appropriate backtraces, etc. If a symbol is in an overlay that
is not currently mapped, GDB will access the symbol from its load address
instead of the mapped runtime address (which would currently be holding
something else from another overlay).</font></div>

<div CLASS="Body"><a NAME="pgfId=1000316"></a><font size=+1>In the following
example, the ‘<tt>foo</tt>’ and ‘<tt>bar</tt>’ functions are in different
overlays which run at the same address. The example shows the use of GDB’s
overlay debugging to step into and debug them.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000317"></a><font size=+1><tt>(gdb)</tt> file ovlydata</font></pre>
</blockquote>
</div>

<blockquote>
<pre><tt><font size=+1>Reading symbols from ovlydata...done.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> target sim</font></pre>

<pre><tt><font size=+1>Connected to the simulator.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> load</font></pre>

<pre><tt><font size=+1>Loading section .ovly0, size 0x28 lma 0x400000</font></tt></pre>

<pre><tt><font size=+1>Loading section .ovly1, size 0x28 lma 0x400028</font></tt></pre>

<pre><tt><font size=+1>Loading section .ovly2, size 0x28 lma 0x480000</font></tt></pre>

<pre><tt><font size=+1>Loading section .ovly3, size 0x28 lma 0x480028</font></tt></pre>

<pre><tt><font size=+1>Loading section .data00, size 0x4 lma 0x440000</font></tt></pre>

<pre><tt><font size=+1>Loading section .data01, size 0x4 lma 0x440004</font></tt></pre>

<pre><tt><font size=+1>Loading section .data02, size 0x4 lma 0x4c0000</font></tt></pre>

<pre><tt><font size=+1>Loading section .data03, size 0x4 lma 0x4c0004</font></tt></pre>

<pre><tt><font size=+1>Loading section .init, size 0x1c lma 0x208000</font></tt></pre>

<pre><tt><font size=+1>Loading section .text, size 0xa3c lma 0x20801c</font></tt></pre>

<pre><tt><font size=+1>Loading section .fini, size 0x14 lma 0x208a58</font></tt></pre>

<pre><tt><font size=+1>Loading section .rodata, size 0x24 lma 0x208a6c</font></tt></pre>

<pre><tt><font size=+1>Loading section .data, size 0x374 lma 0x208ab0</font></tt></pre>

<pre><tt><font size=+1>Loading section .ctors, size 0x8 lma 0x208e24</font></tt></pre>

<pre><tt><font size=+1>Loading section .dtors, size 0x8 lma 0x208e2c</font></tt></pre>

<pre><tt><font size=+1>Start address 0x20801c</font></tt></pre>

<pre><tt><font size=+1>Transfer rate: 30240 bits in &lt;1 sec.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> overlay auto</font></pre>

<pre><font size=+1><tt>(gdb)</tt> overlay list</font></pre>

<pre><tt><font size=+1>No sections are mapped.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info address foo</font></pre>

<pre><tt><font size=+1>Symbol "foo" is a function at address 0x300000,</font></tt></pre>

<pre><tt><font size=+1>loaded at 0x400000 in overlay section .ovly0.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info symbol 0x300000</font></pre>

<pre><tt><font size=+1>foo in unmapped overlay section .ovly0</font></tt></pre>

<pre><tt><font size=+1>bar in unmapped overlay section .ovly1</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info address bar</font></pre>

<pre><tt><font size=+1>Symbol "bar" is a function at address 0x300000,</font></tt></pre>

<pre><tt><font size=+1>loaded at 0x400028 in overlay section .ovly1.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> break main</font></pre>

<pre><tt><font size=+1>Breakpoint 1 at 0x20839c: file maindata.c, line 12.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> run</font></pre>

<pre><tt><font size=+1>Starting program: ovlydata</font></tt></pre>

<pre><tt><font size=+1>Breakpoint 1, main () at maindata.c:12</font></tt></pre>

<pre><tt><font size=+1>12 if (!OverlayLoad(0))</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> next</font></pre>

<pre><tt><font size=+1>14 if (!OverlayLoad(4))</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> next</font></pre>

<pre><tt><font size=+1>16 a = foo(1);</font></tt></pre>
</blockquote>

<blockquote>
<pre><font size=+1><tt>(gdb)</tt> overlay list</font></pre>

<pre><tt><font size=+1>Section .ovly0, loaded at 00400000 - 00400028, mapped at 00300000 - 00300028</font></tt></pre>

<pre><tt><font size=+1>Section .data00, loaded at 00440000 - 00440004, mapped at 00340000 - 00340004</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info symbol 0x300000</font></pre>

<pre><tt><font size=+1>foo in mapped overlay section .ovly0</font></tt></pre>

<pre><tt><font size=+1>bar in unmapped overlay section .ovly1</font></tt></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000318"></a><font size=+1>The overlay
containing the ‘<tt>foo</tt>’ function is now mapped.</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000319"></a><font size=+1><tt>(gdb)</tt> step</font></pre>

<pre><tt><font size=+1>foo (x=1) at foo.c:5</font></tt></pre>

<pre><tt><font size=+1>5 if (x)</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> x /i $pc</font></pre>

<pre><tt><font size=+1>0x300008 &lt;foo+8>: ld r4, @fp || nop</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print foo</font></pre>

<pre><tt><font size=+1>$1 = {int (int)} 0x300000 &lt;foo></font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print bar</font></pre>

<pre><tt><font size=+1>$2 = {int (int)} 0x400028 &lt;*bar*></font></tt></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000320"></a><font size=+1>GDB uses labels
such as ‘<tt> &lt;*bar*></tt>’ (with asterisks) to distinguish overlay
load addresses from the symbol’s runtime address (where it will be when
used by the program).</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000321"></a><font size=+1><tt>(gdb)</tt> disassemble</font></pre>

<pre><tt><font size=+1>Dump of assembler code for function foo:</font></tt></pre>

<pre><tt><font size=+1>0x300000 &lt;foo>: st fp,@-sp -> addi sp,-4</font></tt></pre>

<pre><tt><font size=+1>0x300004 &lt;foo+4>: mv fp,sp -> st r0,@fp</font></tt></pre>

<pre><tt><font size=+1>0x300008 &lt;foo+8>: ld r4,@fp || nop</font></tt></pre>

<pre><tt><font size=+1>0x30000c &lt;foo+12>: beqz r4,0x30001c &lt;foo+28></font></tt></pre>

<pre><tt><font size=+1>0x300010 &lt;foo+16>: ld24 r4,0x340000 &lt;foox></font></tt></pre>

<pre><tt><font size=+1>0x300014 &lt;foo+20>: ld r5,@r4 -> mv r0,r5</font></tt></pre>

<pre><tt><font size=+1>0x300018 &lt;foo+24>: bra 0x300020 &lt;foo+32> -> bra 0x300020 &lt;foo+32></font></tt></pre>

<pre><tt><font size=+1>0x30001c &lt;foo+28>: ldi r0,0 -> bra 0x300020 &lt;foo+32></font></tt></pre>

<pre><tt><font size=+1>0x300020 &lt;foo+32>: add3 sp,sp,4</font></tt></pre>

<pre><tt><font size=+1>0x300024 &lt;foo+36>: ld fp,@sp+ -> jmp lr</font></tt></pre>

<pre><tt><font size=+1>End of assembler dump.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> disassemble bar</font></pre>

<pre><tt><font size=+1>Dump of assembler code for function bar:</font></tt></pre>

<pre><tt><font size=+1>0x400028 &lt;*bar*>: st fp,@-sp -> addi sp,-4</font></tt></pre>

<pre><tt><font size=+1>0x40002c &lt;*bar+4*>: mv fp,sp -> st r0,@fp</font></tt></pre>

<pre><tt><font size=+1>0x400030 &lt;*bar+8*>: ld r4,@fp || nop</font></tt></pre>

<pre><tt><font size=+1>0x400034 &lt;*bar+12*>: beqz r4,0x400044 &lt;*bar+28*></font></tt></pre>

<pre><tt><font size=+1>0x400038 &lt;*bar+16*>: ld24 r4,0x340000 &lt;foox></font></tt></pre>

<pre><tt><font size=+1>0x40003c &lt;*bar+20*>: ld r5,@r4 -> mv r0,r5</font></tt></pre>

<pre><tt><font size=+1>0x400040 &lt;*bar+24*>: bra 0x400048 &lt;*bar+32*> -> bra 0x400048 &lt;*bar+32*></font></tt></pre>

<pre><tt><font size=+1>0x400044 &lt;*bar+28*>: ldi r0,0 -> bra 0x400048 &lt;*bar+32*></font></tt></pre>

<pre><tt><font size=+1>0x400048 &lt;*bar+32*>: add3 sp,sp,4</font></tt></pre>

<pre><tt><font size=+1>0x40004c &lt;*bar+36*>: ld fp,@sp+ -> jmp lr</font></tt></pre>

<pre><tt><font size=+1>End of assembler dump.</font></tt></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000322"></a><font size=+1>Since the overlay
containing ‘<tt>bar</tt>’ is not currently mapped, GDB finds ‘<tt>bar</tt>’
at its load address, and disassembles it there.</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000323"></a><font size=+1><tt>(gdb)</tt> finish</font></pre>

<pre><tt><font size=+1>Run till exit from #0 foo (x=1) at foo.c:5</font></tt></pre>

<pre><tt><font size=+1>0x2083cc in main () at maindata.c:16</font></tt></pre>

<pre><tt><font size=+1>16a = foo(1);</font></tt></pre>

<pre><tt><font size=+1>Value returned is $3 = 324</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> next</font></pre>

<pre><tt><font size=+1>17if (!OverlayLoad(1))</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> next</font></pre>

<pre><tt><font size=+1>19if (!OverlayLoad(5))</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> next</font></pre>

<pre><tt><font size=+1>21b = bar(1);</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> overlay list</font></pre>

<pre><tt><font size=+1>Section .ovly1, loaded at 00400028 - 00400050, mapped at 00300000 - 00300028</font></tt></pre>

<pre><tt><font size=+1>Section .data01, loaded at 00440004 - 00440008, mapped at 00340000 - 00340004</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info symbol 0x300000</font></pre>

<pre><tt><font size=+1>foo in unmapped overlay section .ovly0</font></tt></pre>

<pre><tt><font size=+1>bar in mapped overlay section .ovly1</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> step</font></pre>

<pre><tt><font size=+1>bar (x=1) at bar.c:5</font></tt></pre>

<pre><tt><font size=+1>5 if (x)</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> x /i $pc</font></pre>

<pre><tt><font size=+1>0x300008 &lt;bar+8>: ld r4,@fp || nop</font></tt></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000324"></a><font size=+1>Now ‘<tt>bar</tt>’
is mapped, and ‘<tt>foo</tt>’ is not. Even though the PC is at the same
address as before, GDB recognizes that we are in ‘<tt>bar</tt>’ rather
than ‘<tt> foo</tt>’.</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000325"></a><font size=+1><tt>(gdb)</tt> disassemble</font></pre>

<pre><tt><font size=+1>Dump of assembler code for function bar:</font></tt></pre>

<pre><tt><font size=+1>0x300000 &lt;bar>: st fp,@-sp -> addi sp,-4</font></tt></pre>

<pre><tt><font size=+1>0x300004 &lt;bar+4>: mv fp,sp -> st r0,@fp</font></tt></pre>

<pre><tt><font size=+1>0x300008 &lt;bar+8>: ld r4,@fp || nop</font></tt></pre>

<pre><tt><font size=+1>0x30000c &lt;bar+12>: beqz r4,0x30001c &lt;bar+28></font></tt></pre>

<pre><tt><font size=+1>0x300010 &lt;bar+16>: ld24 r4,0x340000 &lt;barx></font></tt></pre>

<pre><tt><font size=+1>0x300014 &lt;bar+20>: ld r5,@r4 -> mv r0,r5</font></tt></pre>

<pre><tt><font size=+1>0x300018 &lt;bar+24>: bra 0x300020 &lt;bar+32> -> bra 0x300020 &lt;bar+32></font></tt></pre>

<pre><tt><font size=+1>0x30001c &lt;bar+28>:&nbsp;&nbsp;&nbsp; ldi r0,0 -> bra 0x300020 &lt;bar+32></font></tt></pre>

<pre><tt><font size=+1>0x300020 &lt;bar+32>:&nbsp;&nbsp;&nbsp; add3 sp,sp,4</font></tt></pre>

<pre><tt><font size=+1>0x300024 &lt;bar+36>:&nbsp;&nbsp;&nbsp; ld fp,@sp+ -> jmp lr</font></tt></pre>

<pre><tt><font size=+1>End of assembler dump.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> finish</font></pre>

<pre><tt><font size=+1>Run till exit from #0 bar (x=1) at bar.c:5</font></tt></pre>

<pre><tt><font size=+1>0x208400 in main () at maindata.c:21</font></tt></pre>
<tt><font size=+1>21b = bar(1);</font></tt>
<br><tt><font size=+1>Value returned is $4 = 309</font></tt></blockquote>

<div CLASS="Body"><a NAME="pgfId=1000326"></a><font size=+1>Also in this
example, the ‘<tt> bazx</tt>’ and ‘<tt>grbxx</tt>’ variables are both mapped
to the same runtime address. We will see that with the automatic overlay
debugging mode, GDB always knows which variable is using that address.</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000327"></a><font size=+1><tt>(gdb)</tt> info addr bazx</font></pre>

<pre><tt><font size=+1>Symbol "bazx" is static storage at address 0x3c0000,</font></tt></pre>

<pre><tt><font size=+1>loaded at 0x4c0000 in overlay section .data02.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info sym 0x3c0000</font></pre>

<pre><tt><font size=+1>bazx in unmapped overlay section .data02</font></tt></pre>

<pre><tt><font size=+1>grbxx in unmapped overlay section .data03</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info addr grbxx</font></pre>

<pre><tt><font size=+1>Symbol "grbxx" is static storage at address 0x3c0000,</font></tt></pre>

<pre><tt><font size=+1>loaded at 0x4c0004 in overlay section .data03.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> break baz</font></pre>

<pre><tt><font size=+1>Breakpoint 2 at 0x380008: file baz.c, line 5.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> break grbx</font></pre>

<pre><tt><font size=+1>Breakpoint 3 at 0x380008: file grbx.c, line 5.</font></tt></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000328"></a><font size=+1>The two breakpoints
are actually set at the same address, yet GDB will correctly distinguish
between them when it hits them. If only one overlay function has a breakpoint
on it, GDB will not stop at that address in other overlay functions.</font></div>

<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000329"></a><font size=+1><tt>(gdb)</tt> cont</font></pre>

<pre><tt><font size=+1>Continuing.</font></tt></pre>

<pre><tt><font size=+1>Breakpoint 2, baz (x=1) at baz.c:5</font></tt></pre>

<pre><tt><font size=+1>5 if (x)</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print &amp;bazx</font></pre>

<pre><tt><font size=+1>$5 = (int *) 0x3c0000</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> x /d &amp;bazx</font></pre>

<pre><tt><font size=+1>0x3c0000 &lt;bazx>: 317</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print &amp;grbxx</font></pre>

<pre><tt><font size=+1>$6 = (int *) 0x4c0004</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> cont</font></pre>

<pre><tt><font size=+1>Continuing.</font></tt></pre>

<pre><tt><font size=+1>Breakpoint 3, grbx (x=1) at grbx.c:5</font></tt></pre>

<pre><tt><font size=+1>5 if (x)</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print &amp;grbxx</font></pre>

<pre><tt><font size=+1>$7 = (int *) 0x3c0000</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> x /d &amp;grbxx</font></pre>

<pre><tt><font size=+1>0x3c0000 &lt;grbxx>: 435</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> print &amp;bazx</font></pre>

<pre><tt><font size=+1>$7 = (int *) 0x4c0000</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> x /d &amp;bazx</font></pre>

<pre><tt><font size=+1>0x4c0000 &lt;*bazx*>: 317</font></tt></pre>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000331"></a><a NAME="_Toc435604886"></a><b><i><font size=+2>GDB
overlay support for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000332"></a><font size=+1>GDB provides special functionality
for debugging a program that is linked using the overlay mechanism of the
GNU linker. In such programs, an overlay corresponds to a section with
a load address that is different from its runtime address. GDB can provide
‘<tt>manual</tt>’ overlay debugging for any program linked in such a way
(providing that the overlays all reside somewhere in memory). Automatic
overlay debugging is also provided.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000333"></a><b><i><font size=+2>Manual
mode commands for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000334"></a><font size=+1>The following commands are
for manual mode for the overlay manager.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000335"></a><tt><font size=+1>overlay manual</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000336"></a><font size=+1><tt>overlay
map
</tt><i>&lt;<tt>section-name</tt>></i></font></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000337"></a><font size=+1><tt>overlay
unmap
</tt><i>&lt;<tt>section-name</tt>></i></font></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000338"></a><tt><font size=+1>overlay
list</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000339"></a><tt><font size=+1>overlay
off</font></tt></div>

<blockquote><font size=+1>The manual mode requires input from the user
to specify what overlays are mapped into their runtime address regions
at any given time. The ‘<tt> overlay map</tt>’ command informs GDB that
the overlay has been mapped by the target into its shared runtime address
range. The ‘<tt>overlay unmap</tt>’ command informs GDB that the overlay
is no longer resident in its runtime address region, and must be accessed
from the load-time address region. If two overlays share the same runtime
address region, then mapping one implies unmapping the other.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000340"></a><b><i><font size=+2>Auto
mode commands for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000341"></a><font size=+1>The following commands are
for automatic mode for the overlay manager.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000342"></a><tt><font size=+1>overlay auto</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000343"></a><tt><font size=+1>overlay
list</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000344"></a><tt><font size=+1>overlay
off</font></tt></div>

<blockquote><font size=+1>Automatic overlay debugging support in GDB works
with the runtime overlay manager provided in the ‘<tt>examples</tt>’ directory.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000345"></a><font size=+1>When
this mode is activated, GDB will automatically read and interpret the data
structures maintained in target memory by the overlay manager. To learn
what overlays are mapped at any time, use the ‘<tt>overlay list</tt>’ command.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000346"></a><font size=+1>Whenever
the target program is allowed to run (by the ‘<tt>step</tt>’ command),
GDB will refresh its overlay map by reading from the target’s overlay tables.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000347"></a><font size=+1>The
automatic mapping may be temporarily overridden by the ‘<tt>overlay map</tt>’
and ‘<tt> overlay unmap</tt>’ commands, but these mappings will last only
until the next time the target is allowed to run. To explicitly take control
of GDB’s overlay mapping, switch to the ‘<tt>overlay manual</tt>’ mode.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000348"></a><b><i><font size=+2>Debugging
with overlays for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000349"></a><font size=+1>When GDB’s overlay support
(either manual or auto) is active, GDB’s concept of a symbol’s address
is controlled by which overlays are mapped into which memory regions. For
instance, if you ‘<tt>print</tt>’ a variable that is in an overlay which
is currently mapped (located in its runtime address region) GDB will fetch
the variable’s memory from the runtime address. If the variable’s overlay
is currently not mapped, GDB will fetch it from its load-time address.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000350"></a><font size=+1>Similarly,
if you disassemble a function that is in an unmapped overlay, or use a
symbol’s address to examine memory, GDB will fetch the memory from the
symbol’s load-time address range instead of the runtime range. If GDB’s
output contains labels that are relative to an overlay’s load-time address
instead of the runtime address, the labels will be distinguished like the
following example’s input shows.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000351"></a><font size=+1><tt>(gdb)</tt> overlay map .ovly0</font></pre>
</blockquote>
</div>

<blockquote>
<pre><font size=+1><tt>(gdb)</tt> x /x foo</font></pre>

<pre><tt><font size=+1>0x300000 &lt;foo>: 0x2d7f4ffc</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> overlay unmap .ovly0</font></pre>

<pre><font size=+1><tt>(gdb)</tt> x /x foo</font></pre>

<pre><tt><font size=+1>0x400000 &lt;*foo*>: 0x2d7f4ffc</font></tt></pre>

<pre></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000352"></a><font size=+1>The asterisks
(<tt>*</tt> ) around the ‘<tt>foo</tt>’ label may be interpreted as meaning
that this is where ‘<tt>foo</tt>’ is, but not where it will be when it
is in use by the target program.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000353"></a><font size=+1>The ‘<tt>INFO
ADDRESS</tt> ’ command can tell you what overlay a symbol is in, as well
as where it is loaded and mapped. The ‘<tt>INFO SYMBOL</tt>’ command can
list all of the symbols that are mapped to an address.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=1000354"></a><font size=+1><tt>(gdb)</tt> info addr foo</font></pre>

<pre><tt><font size=+1>Symbol "foo" is a function at address 0x300000,</font></tt></pre>

<pre><tt><font size=+1>-- loaded at 0x400000 in overlay section .ovly0.</font></tt></pre>

<pre><font size=+1><tt>(gdb)</tt> info symbol 0x300000</font></pre>

<pre><tt><font size=+1>foo in mapped overlay section .ovly0</font></tt></pre>

<pre><tt><font size=+1>bar in unmapped overlay section .ovly1</font></tt></pre>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000355"></a><b><i><font size=+2>Breakpoints
for M32R/X/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000356"></a><font size=+1>So long as the overlay sections
are located in RAM rather than ROM, GDB can set breakpoints in them. The
breakpoints work by inserting trap instructions into the load-time address
region. When the overlay is mapped into the runtime region, the trap instructions
are mapped along with it, and when executed, cause the target program to
break out to the debugger. If the overlay regions are located in ROM, you
can only set breakpoints in them after they have been mapped into the runtime
region in RAM.</font></div>

<div CLASS="Heading1">&nbsp;
<br><a NAME="pgfId=1000358"></a><a NAME="M32rd"></a><b><i><font size=+2>Developing
for the M32R/D targets</font></i></b></div>

<div CLASS="BodyAfterHead">&nbsp;
<br><a NAME="pgfId=1000360"></a><font size=+1>The following documentation
discusses the M32R/D processor.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000364"></a><font size=+1><a href="m32r.html#16627" CLASS="XRef">Compiler
support for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000368"></a><font size=+1><a href="m32r.html#_Toc442168544" CLASS="XRef">ABI
summary for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000372"></a><font size=+1><a href="m32r.html#_Toc442168551" CLASS="XRef">Assembler
features for the M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000376"></a><font size=+1><a href="m32r.html#_Toc442168561" CLASS="XRef">Linker
issues for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000380"></a><font size=+1><a href="m32r.html#15706" CLASS="XRef">Debugger
issues with M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000384"></a><font size=+1><a href="m32r.html#_Toc442168567" CLASS="XRef">Stand-alone
simulator for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000388"></a><font size=+1><a href="m32r.html#_Toc442168569" CLASS="XRef">Overlays
for M32R/D targets</a></font></li>
</ul>

<div CLASS="Heading1"><a NAME="pgfId=1000390"></a><b><i><font size=+2>Compiler
support for M32R/D targets</font></i></b><a NAME="16627"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000392"></a><font size=+1>The following documentation
discusses the GNU compiler usage for M32R/D processors.</font><a NAME="M32R/D"></a></div>

<div CLASS="Body"><a NAME="pgfId=1000396"></a><font size=+1>See also <a href="m32r.html#41106" CLASS="XRef">M32R/D-specific
attributes for compiling</a>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000397"></a><font size=+1>By default,
the compiler defines the ‘<tt>__M32R__</tt>’ preprocessor symbol.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000400"></a><font size=+1>For a list
of available generic compiler options, see <a href="../2_comp/Using_GNU_CC/gccGNU_CC_Command_Options.html" CLASS="XRef">GNU
CC command options</a> in <i><a href="../2_comp/Using_GNU_CC/gcc.html">Using
GNU CC</a> </i>in <b><i>GNUPro Compiler Tools</i></b>. The following M32R/D-specific
command-line options have support.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=1000402"></a><tt><font size=+1>-mmodel=small</font></tt></div>

<p><br><font size=+1>Assume all objects live in the lower 16MB of memory
(so that their addresses can be loaded with the ‘<tt>ld24</tt>’ instruction),
and assume all subroutines are reachable with the ‘bl’ instruction. This
is the default.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000403"></a><font size=+1>The
addressability of a particular object can be set with the ‘<tt>model</tt>’
attribute in the source code. See <a href="m32r.html#41106" CLASS="XRef">M32R/D-specific
attributes for compiling</a>.</font>

<p CLASS="BodyHang1"><a NAME="pgfId=1000407"></a><tt><font size=+1>-mmodel=medium</font></tt>
<blockquote><font size=+1>Assume objects may be anywhere in the 32 bit
address space (the compiler will generate ‘<tt>seth/add3</tt>’ instructions
to load their addresses), and assume all subroutines are reachable with
the ‘<tt>bl</tt>’ instruction.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000408"></a><tt><font size=+1>-mmodel=large</font></tt></div>

<blockquote><font size=+1>Assume objects may be anywhere in the 32 bit
address space (the compiler will generate ‘<tt>seth/add3</tt>’ instructions
to load their addresses), and assume subroutines may not be reachable with
the ‘<tt>bl</tt>’ instruction (the compiler will generate the much slower
‘<tt>seth/add3/jl</tt>’ instruction sequence).</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000409"></a><tt><font size=+1>-msdata=none</font></tt></div>

<blockquote><font size=+1>Disable use of the small data area. Variables
will be put into one of ‘<tt>.data</tt>’, ‘<tt>bss</tt>’, or ‘<tt>.rodata</tt>’
(unless the ‘<tt>section</tt>’ attribute has been specified). This is the
default. The small data area consists of sections ‘<tt>.sdata</tt>’ and
‘<tt>.sbss</tt>’. Objects may be explicitly put in the small data area
with the ‘section’ attribute using one of these sections.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000410"></a><tt><font size=+1>-msdata=sdata</font></tt></div>

<blockquote><font size=+1>Put small global and static data in the small
data area, but do not generate special code to reference them. This is
normally only used to build system libraries. It enables them to be used
with both ‘<tt>-msdata=none</tt> ’ and ‘<tt>-msdata=use</tt>’ options.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000411"></a><tt><font size=+1>-msdata=use</font></tt></div>

<blockquote><font size=+1>Put small global and static data in the small
data area, and generate special instructions to reference them.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000412"></a><tt><font size=+1>-G
<i>num</i></font></tt></div>

<blockquote><font size=+1>Put global and static objects less than or equal
to ‘<i><tt>num</tt></i>’ bytes into the small data or bss sections instead
of the normal data or bss sections. The default value of ‘<i><tt>num</tt></i>’
is 8.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000413"></a><font size=+1>The
‘<tt>-msdata</tt> ’ option must be set to one of ‘<tt>sdata</tt>’ or ‘<tt>use</tt>’
for this option to have any effect.</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000414"></a><font size=+1>All
modules should be compiled with the same ‘<tt>-G <i>num</i></tt>’ value.
Compiling with different values of ‘<tt>num</tt>’ may or may not work;
if it does not work, the linker will give an error message. Incorrect code
will not be generated.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000416"></a><b><i><font size=+2>M32R/D-specific
attributes for compiling</font></i></b><a NAME="41106"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000417"></a><font size=+1>The following M32R/D-specific
attributes are supported. Names may be surrounded with double-underscores
to avoid</font>
<br><font size=+1>namespace pollution. For example ‘<tt>__interrupt__</tt>’
can also be used for ‘<tt>interrupt</tt>’. See also <a href="../2_comp/Using_GNU_CC/gccDeclaring_Attributes_of_Function.html#Top" CLASS="XRef">Declaring
attributes of functions</a> and <a href="../2_comp/Using_GNU_CC/gccSpecifying_Attributes_of_Variabl.html#Top" CLASS="XRef">Specifying
attributes of variables</a> in <a href="../2_comp/Using_GNU_CC/gccExtensions_to_the_C_Language_Fam.html#Top" CLASS="XRef">Extensions
to the C language family</a> in <i><a href="../2_comp/Using_GNU_CC/gcc.html">Using
GNU CC</a></i> in <b><i>GNUPro Compiler Tools</i></b>.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000427"></a><tt><font size=+1>interrupt</font></tt></div>

<blockquote><font size=+1>Indicates the specified function is an interrupt
handler. The compiler will generate prologue and epilogue sequences appropriate
for an interrupt handler.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000428"></a><font size=+1><tt>model
(</tt><i>&lt;<tt>model-name</tt>></i><tt>)</tt></font></div>

<blockquote><font size=+1>Use this attribute on the M32R/D to set the addressability
of an object, and the code generated for a function. The identifier ‘<tt>&lt;<i>model-name</i>></tt>
’ is one of ‘<tt>small</tt>’, ‘<tt>medium</tt>’, or ‘<tt>large</tt> ’,
representing each of the code models.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000429"></a><font size=+1>Small
model objects live in the lower 16MB of memory (so that their addresses
can be loaded with the ‘<tt>ld24</tt>’ instruction), and are callable with
the ‘<tt> bl</tt>’ instruction.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000430"></a><font size=+1>Medium
model objects may live anywhere in the 32 bit address space (the compiler
will generate ‘<tt>seth/add3</tt>’ instructions to load their addresses),
and are callable with the ‘<tt>bl</tt>’ instruction.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000431"></a><font size=+1>Large
model objects may live anywhere in the 32 bit address space (the compiler
will generate ‘<tt>seth/add3</tt>’ instructions to load their addresses),
and may not be reachable with the ‘<tt>bl</tt>’ instruction (the compiler
will generate the much slower ‘<tt>seth/add3/jl</tt>’ instruction sequence).</font></div>
</blockquote>

<div CLASS="Heading1"><a NAME="pgfId=1000433"></a><a NAME="_Toc442168544"></a><b><i><font size=+2>ABI
summary for M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000435"></a><font size=+1>The following documentation
describes the Application Binary Interface (<a NAME="M32R/D"></a> ABI)
for the M32R/D processor.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000439"></a><font size=+1><a href="m32r.html#_Toc442168545" CLASS="XRef">Data
types and alignment for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000443"></a><font size=+1><a href="m32r.html#_Toc442168546" CLASS="XRef">Allocation
rules for structures and unions for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000447"></a><font size=+1><a href="m32r.html#_Toc442168547" CLASS="XRef">CPU
registers for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000451"></a><font size=+1><a href="m32r.html#_Toc442168548" CLASS="XRef">The
stack frame for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000455"></a><font size=+1><a href="m32r.html#_Toc442168549" CLASS="XRef">Argument
passing for M32R/D processors</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000459"></a><font size=+1><a href="m32r.html#_Toc442168550" CLASS="XRef">Function
return values for M32R/D processors</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000463"></a><font size=+1><a href="m32r.html#18966" CLASS="XRef">Startup
code for M32R/D targets</a></font></li>
</ul>

<div CLASS="Heading2"><a NAME="pgfId=1000465"></a><a NAME="_Toc442168545"></a><b><i><font size=+2>Data
types and alignment for M32R/D targets</font></i></b></div>

<div CLASS="Body"><a NAME="pgfId=1000470"></a>See <a href="m32r.html#38208" CLASS="XRef">Data
type sizes for the M32R/D processor</a>.<a NAME="M32R/D"></a></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000509"></a><a NAME="38208"></a><b><font size=+1>Data
type sizes for the M32R/D processor</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000474"></a><b><i>Type</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000476"></a><b><i>Size (bytes)</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000478"></a><tt>char</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000480"></a>1 byte</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000482"></a><tt>short</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000484"></a>2 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000486"></a><tt>int</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000488"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000490"></a><tt>long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000492"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000494"></a><tt>long long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000496"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000498"></a><tt>float</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000500"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000502"></a><tt>double</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000504"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000506"></a><i>pointer</i></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000508"></a>4 bytes</div>
</td>
</tr>
</table>


<p CLASS="Body"><a NAME="pgfId=1000510"></a><font size=+1>The stack is
aligned to a four-byte boundary. One byte is used for characters (including
structure/unions made entirely of <tt>char</tt>s), two bytes for <tt>short</tt>s
(including structure/unions made entirely of <tt>short</tt>s), and four-byte
alignment for everything else.</font>

<p CLASS="Heading2"><a NAME="pgfId=1000512"></a><a NAME="_Toc442168546"></a><b><i><font size=+2>Allocation
rules for structures and unions for M32R/D targets</font></i></b>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000513"></a><font size=+1>The following rules apply
to the allocation of structure and union members in memory.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000514"></a><font size=+1>Structure and union packing can
be controlled by attributes specified in the source code. In the absence
of any attributes however, the following rules are obeyed:</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000515"></a><font size=+1>Fields that are shorts are aligned
to 2 byte boundaries. Fields that are ints, longs, floats, doubles and
long longs are aligned to 4 byte boundaries. Char fields are not aligned.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000516"></a><font size=+1>Composite fields (ie ones that
are themselves structures or unions) are aligned to greatest alignment
requirement of any of their component fields. So if a field is a structure
that contains a char, a short and an int, the field will be aligned to
a 4-byte boundary because of the int.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000517"></a><font size=+1>Bit fields are packed in a big-endian
fashion, and they are aligned so that they will not cross boundaries of
their type.</font></li>
</ul>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000518"></a><font size=+1>So
for example this structure:</font></div>

<div CLASS="CodeExample2">
<blockquote>
<pre><a NAME="pgfId=1000519"></a><font size=+1>struct { int a:2, b:31;} s = { 0x1, 0x3};</font></pre>
</blockquote>
</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000520"></a><font size=+1>is
stored in memory as:</font></div>

<div CLASS="CodeExample2">
<blockquote>
<pre><a NAME="pgfId=1000521"></a><font size=+1>.byte 0x40</font></pre>
</blockquote>
</div>

<blockquote>
<pre><font size=+1>.zero 3</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x6</font></pre>

<pre></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000522"></a><font size=+1>So
the ‘<tt>a</tt>’ field is stored in the top two bits of the first byte;
with the most significant bit of ‘<tt>a</tt>’ being stored in the most
significant bit of the byte. The bottom six bits of that byte and the next
three bytes are all padding, so that the next bitfield ‘<tt>b</tt>’ does
not cross a word boundary.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000523"></a><font size=+1>This
structure:</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000524"></a><font size=+1>struct { short c:2, d:2, e:13; } s = { 0x2, 0x3, 0xf};</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000525"></a><font size=+1>is
stored in memory as:</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample2"><a NAME="pgfId=1000526"></a><font size=+1>.byte 0xb0</font></pre>

<pre><font size=+1>.zero 1</font></pre>

<pre><font size=+1>.byte 0x0</font></pre>

<pre><font size=+1>.byte 0x78</font></pre>
</blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000527"></a><font size=+1>So
fields ‘<tt>c</tt>’ and ‘<tt>d</tt>’ are both held in the same byte, but
field ‘<tt>e</tt>’ starts two bytes further on, so that it will not cross
a two byte boundary.</font></div>

<div CLASS="Bullet"><a NAME="pgfId=1000528"></a><font size=+1>Fields in
unions are treated in the same way as fields in structures. A union is
aligned to the greatest alignment requirement of any of its members.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000530"></a><a NAME="_Toc442168547"></a><b><i><font size=+2>CPU
registers for M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000532"></a><font size=+1>The following documentation
details the registers for M32R/D processors.</font><a NAME="M32R/D"></a></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000533"></a><font size=+1><tt>r0</tt> through
<tt>r3</tt></font></div>

<blockquote><font size=+1>Used for passing arguments to functions. Additional
arguments are passed on the stack (see <a href="m32r.html#_Toc442168548" CLASS="XRef">The
stack frame for M32R/D targets</a>). ‘<tt>r0</tt>’, ‘<tt>r1</tt>’ is also
used to return the result of function calls. The values of these registers
are not preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000537"></a><font size=+1><tt>r4</tt>
through <tt>r7</tt></font></div>

<blockquote><font size=+1>Temporary registers for expression evaluation.
The values of these registers are not preserved across function calls.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000538"></a><font size=+1>‘<tt>r4</tt>’
is reserved for use as a temporary register in the prologue.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000539"></a><font size=+1>‘<tt>r6</tt>’
is also reserved for use as a temporary in the Position Independent Code
(PIC) calling sequence (if ever necessary) and may not be used in the function
calling sequence or prologue of functions.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000540"></a><font size=+1>‘<tt>r7</tt>’
is also used as the static chain pointer in nested functions (a GNU C extension)
and may not be used in the function calling sequence or prologue of functions.
In other contexts it is used as a temporary register.</font></div>
</blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000541"></a><font size=+1><tt>r8</tt>
, <tt>r9</tt> , <tt>r10</tt> , <tt>r11</tt></font></div>

<blockquote><font size=+1>Temporary registers for expression evaluation.
The values of these registers are preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000542"></a><tt><font size=+1>r12</font></tt></div>

<blockquote><font size=+1>Temporary register for expression evaluation.
Its value is preserved across function calls. It is also reserved for use
as potential <i>global pointer</i>.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000543"></a><tt><font size=+1>r13(fp)</font></tt></div>

<blockquote><font size=+1>Reserved for use as the frame pointer if one
is needed. Otherwise it may be used for expression evaluation. Its value
is preserved across function calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000544"></a><tt><font size=+1>r14(lr)</font></tt></div>

<blockquote><font size=+1>Link register. This register contains the return
address in function calls. It may also be used for expression evaluation
if the return address has been saved.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000545"></a><tt><font size=+1>r15(sp)</font></tt></div>

<blockquote><font size=+1>Stack pointer.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000546"></a><tt><font size=+1>accumulator</font></tt></div>

<blockquote><font size=+1>This register is not preserved across function
calls.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000547"></a><tt><font size=+1>psw</font></tt></div>

<blockquote><font size=+1>The carry bit of the ‘<tt>psw</tt>’ is not preserved
across function calls.</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000550"></a><a NAME="_Toc442168548"></a><b><i><font size=+2>The
stack frame for M32R/D targets</font></i></b><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000551"></a><font size=+1>Stack frame information follows
for the M32R/D processor.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000552"></a><font size=+1>The stack grows downwards from
high addresses to low addresses.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000553"></a><font size=+1>A leaf function need not allocate
a stack frame if it does not need one.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000554"></a><font size=+1>A frame pointer need not be allocated.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000555"></a><font size=+1>The stack pointer shall always
be aligned to 4-byte boundaries.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000556"></a><font size=+1>The register save area shall
be aligned to a 4-byte boundary.</font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=1000560"></a><font size=+1>See <a href="m32r.html#23176" CLASS="XRef">Stack
frames for functions that take a fixed number of arguments for the M32R/D
processor</a>.</font></div>

<div CLASS="FigureTitle"><a NAME="pgfId=1000562"></a><a NAME="23176"></a><b><font size=+1>Stack
frames for functions that take a fixed number of arguments for the M32R/D
processor</font></b></div>

<ol>
<div CLASS="Figure"><a NAME="pgfId=1000618"></a></div>

<p><br><map NAME="m32r-3"></map><img SRC="m32r-3.gif" BORDER=3 USEMAP="#m32r-3" height=308 width=360></ol>

<div CLASS="BodyHang1"><a NAME="pgfId=1000619"></a><font size=+1><font face="Arial,Helvetica">FP</font>
points to the same location as <font face="Arial,Helvetica">SP</font>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000623"></a><font size=+1>See <a href="m32r.html#14689" CLASS="XRef">See
Stack frames for functions that take a variable number of arguments for
the M32R/D processor</a>.</font></div>

<div CLASS="FigureTitle"><a NAME="pgfId=1000625"></a><a NAME="14689"></a><b><font size=+1>Stack
frames for functions that take a variable number of arguments for the M32R/D
processor</font></b></div>

<ol>
<div CLASS="Figure"><a NAME="pgfId=1000680"></a></div>

<p><br><map NAME="m32r-4"></map><img SRC="m32r-4.gif" BORDER=3 USEMAP="#m32r-4" height=325 width=360></ol>

<div CLASS="Heading2"><a NAME="pgfId=1000683"></a><a NAME="_Toc442168549"></a><b><i><font size=+2>Argument
passing for M32R/D processors</font></i></b><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000684"></a><font size=+1>Arguments are passed to a
function using first registers and then memory if the argument passing
registers are used up. Each register is assigned an argument until all
are used. Unused argument registers have undefined values on entry. The
following rules must be adhered to.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000685"></a><font size=+1>An argument, if it is less than
or equal to 8 bytes in size, is passed in registers if available. However,
if such an argument is a composite structure (one with more than one field
and greater than 4 bytes in size) it is also passed on the stack, in addition
to being passed in the registers. An argument, which is greater than 8
bytes in size, is always passed by reference, which means that a copy of
the argument is placed on the stack and a pointer to that copy is passed
in the register.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000686"></a><font size=+1>If a data type would overflow
the register arguments, then it is passed in registers and memory. A ‘<tt>long
long</tt> ’ data type passed in ‘<tt>r3</tt>’ would be passed in ‘<tt>r3</tt>
’ and in the first 4 bytes of the stack.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000687"></a><font size=+1>Arguments passed on the stack
begin at ‘<tt> sp</tt>’ with respect to the caller.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000688"></a><font size=+1>Each argument passed on the stack
is aligned on a 4 byte boundary.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000689"></a><font size=+1>Space for all arguments is rounded
up to a multiple of 4 bytes.</font></li>
</ul>

<div CLASS="Heading2"><a NAME="pgfId=1000692"></a><a NAME="_Toc442168550"></a><b><i><font size=+2>Function
return values for M32R/D processors</font></i></b><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000693"></a><font size=+1>Integers, floating point
values, and aggregates of 8 bytes or less are returned in register ‘<tt>
r0</tt>’ (and ‘<tt>r1</tt>’ if necessary).</font></div>

<div CLASS="Body"><a NAME="pgfId=1000694"></a><font size=+1>Aggregates
larger than 8 bytes are returned by having the caller pass the address
of a buffer to hold the value in ‘<tt>r0</tt>’ as an "invisible" first
argument. All arguments are then shifted down by one. The address of this
buffer is returned in ‘<tt>r0</tt>’.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000697"></a><b><i><font size=+2>Startup
code for M32R/D targets</font></i></b><a NAME="18966"></a><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000699"></a><font size=+1>Before the ‘<tt>main<a NAME="M32R/D"></a></tt>’
function can be called, code must be run that does four things:</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000700"></a><font size=+1>Contain ‘<tt>_start</tt>’ symbol</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000701"></a><font size=+1>Initialize the stack pointer</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000702"></a><font size=+1>Zeros the ‘<tt>bss</tt>’ section</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000703"></a><font size=+1>Runs constructors for any global
objects that have them</font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=1000704"></a><font size=+1>The default
startup code is shown in the following example of the ‘<tt>libgloss/m32r/crt0.S</tt>
’ file. The best way to write your own startup code is to take this and
modify it to suit your needs.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000705"></a><tt><font size=+1>.text</font></tt></pre>
</blockquote>
</div>

<blockquote>
<pre><tt><font size=+1>.balign 4</font></tt></pre>

<pre><tt><font size=+1>.global _start</font></tt></pre>

<pre><tt><font size=+1>_start:</font></tt></pre>

<pre><tt><font size=+1>ld24 sp, _stack</font></tt></pre>

<pre><tt><font size=+1>ldi fp, #0</font></tt></pre>

<pre><tt><font size=+1># Clear the BSS. Do it in two parts for efficiency: longwords first</font></tt></pre>

<pre><tt><font size=+1># for most of it, then the remaining 0 to 3 bytes.</font></tt></pre>

<pre><tt><font size=+1>ld24 r2, __bss_start ; R2 = start of BSS</font></tt></pre>

<pre><tt><font size=+1>ld24 r3, _end ; R3 = end of BSS + 1</font></tt></pre>

<pre><tt><font size=+1>sub r3, r2 ; R3 = BSS size in bytes</font></tt></pre>

<pre><tt><font size=+1>mv r4, r3</font></tt></pre>

<pre><tt><font size=+1>srli r4, #2 ; R4 = BSS size in longwords (rounded down)</font></tt></pre>

<pre><tt><font size=+1>ldi r1, #0 ; clear R1 for longword store</font></tt></pre>

<pre><tt><font size=+1>addi r2, #-4 ; account for pre-inc store</font></tt></pre>

<pre><tt><font size=+1>beqz r4, .Lendloop1 ; any more to go?</font></tt></pre>

<pre><tt><font size=+1>.Lloop1:</font></tt></pre>

<pre><tt><font size=+1>st r1, @+r2 ; yep, zero out another longword</font></tt></pre>

<pre><tt><font size=+1>addi r4, #-1 ; decrement count</font></tt></pre>

<pre><tt><font size=+1>bnez r4, .Lloop1 ; go do some more</font></tt></pre>

<pre><tt><font size=+1>.Lendloop1:</font></tt></pre>

<pre><tt><font size=+1>and3 r4, r3, #3 ; get no. of remaining BSS bytes to clear</font></tt></pre>

<pre><tt><font size=+1>addi r2, #4 ; account for pre-inc store</font></tt></pre>

<pre><tt><font size=+1>beqz r4, .Lendloop2 ; any more to go?</font></tt></pre>

<pre><tt><font size=+1>.Lloop2:</font></tt></pre>

<pre><tt><font size=+1>stb r1, @r2 ; yep, zero out another byte</font></tt></pre>

<pre><tt><font size=+1>addi r2, #1 ; bump address</font></tt></pre>

<pre><tt><font size=+1>addi r4, #-1 ; decrement count</font></tt></pre>

<pre><tt><font size=+1>bnez r4, .Lloop2 ; go do some more</font></tt></pre>

<pre><tt><font size=+1>.Lendloop2:</font></tt></pre>

<pre><tt><font size=+1># Run code in the .init section.</font></tt></pre>

<pre><tt><font size=+1># This will queue the .fini section to be run with atexit.</font></tt></pre>

<pre><tt><font size=+1>bl __init</font></tt></pre>

<pre><tt><font size=+1># Call main, then exit.</font></tt></pre>

<pre><tt><font size=+1>bl main</font></tt></pre>

<pre><tt><font size=+1>bl exit</font></tt></pre>

<pre><tt><font size=+1># If that fails just loop.</font></tt></pre>

<pre><tt><font size=+1>.Lexit:</font></tt></pre>

<pre><tt><font size=+1>bra .Lexit</font></tt></pre>
</blockquote>

<div CLASS="Heading1"><a NAME="pgfId=1000707"></a><a NAME="_Toc442168551"></a><b><i><font size=+2>Assembler
features for the M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000709"></a><font size=+1>The following documentation
discusses the assembler issues for the M32R/D processor.</font><a NAME="M32R/D"></a></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000713"></a><font size=+1><a href="m32r.html#_Toc442168555" CLASS="XRef">Register
names for the M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000717"></a><font size=+1><a href="m32r.html#_Toc442168556" CLASS="XRef">Addressing
modes for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000721"></a><font size=+1><a href="m32r.html#_Toc442168557" CLASS="XRef">Floating
point for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000725"></a><font size=+1><a href="m32r.html#_Toc442168558" CLASS="XRef">Pseudo
opcodes for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000729"></a><font size=+1><a href="m32r.html#_Toc442168559" CLASS="XRef">Opcodes
for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000733"></a><font size=+1><a href="m32r.html#_Toc442168560" CLASS="XRef">Synthetic
instructions for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000737"></a><font size=+1><a href="m32r.html#39494" CLASS="XRef">Writing
assembler code for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000741"></a><font size=+1><a href="m32r.html#40448" CLASS="XRef">Writing
assembler code for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000745"></a><font size=+1><a href="m32r.html#24340" CLASS="XRef">Inserting
assembly instructions into C code for M32R/D targets</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=1000749"></a><font size=+1><a href="m32r.html#19548" CLASS="XRef">M32R/D-specific
assembler error messages</a></font></li>
</ul>

<div CLASS="Body"><a NAME="pgfId=1000752"></a><font size=+1>For a list
of available generic assembler options, see <a href="../5_ut/a_Using_AS/asCommandLine_Options.html" CLASS="XRef">Command-line
options</a> in <a href="../5_ut/a_Using_AS/as.html#Top"><i>Using </i><tt>as</tt></a>
in <b><i>GNUPro Utilities</i></b>. In addition, the following M32R/D-specific
command-line options are supported.</font></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000754"></a><tt><font size=+1>-warn-unmatched-high</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000755"></a><tt><font size=+1>-no-warn-unmatched-high</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000756"></a><tt><font size=+1>-Wuh</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1000757"></a><tt><font size=+1>-Wnuh</font></tt></div>

<blockquote><font size=+1>Warn (or do not warn using <tt>-no-warn-unmatched-high</tt>
or <tt>-Wnuh</tt> ), if a ‘<tt>high</tt>’ or ‘<tt>shigh</tt>’ relocation
has no matching ‘<tt>low</tt>’ relocation. The default is no warning.</font></blockquote>

<blockquote>
<div CLASS="Body"><a NAME="pgfId=1000758"></a><font size=+1>The M32R/D
assembler syntax is based on the syntax in Mitsubishi’s <b><i>M32R Family
Software Manual</i></b>.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000759"></a><font size=+1>The M32R/D
assembler supports ‘<tt>;</tt>’ (semi-colon) and ‘<tt>#</tt>’ (pound).
Both characters are line comment characters when used in column zero. The
semi-colon may also be used to start a comment anywhere within a line.</font></div>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000762"></a><a NAME="_Toc442168555"></a><b><i><font size=+2>Register
names for the M32R/D targets</font></i></b><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000764"></a><font size=+1>You can use the ‘<tt>r0</tt>
’ through ‘<tt>r15</tt>’ predefined symbols to refer to the M32R/D registers.
You can also use ‘<a NAME="M32R/D"></a> <tt>sp</tt>’ as an alias for ‘<tt>
r15</tt>’, ‘<tt>lr</tt>’ as an alias for ‘<tt>r14</tt>’, and ‘<tt>fp</tt>’
as an alias for ‘<tt>r13</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000765"></a><font size=+1>The M32R/D
also has predefined symbols for the following control registers and status
bits.</font></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000795"></a><b><font size=+1>Predefined
symbols and usage for M32R/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000768"></a><b><i>Symbol</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000770"></a><b><i>Usage</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000772"></a><tt>cr0 </tt>through
<tt>cr15</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000774"></a>Control registers</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000776"></a><tt>psw</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000778"></a>Processor status word
(alias for ‘<tt>cr0</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000780"></a><tt>cbr</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000782"></a>Condition bit register
(alias for ‘<tt>cr1</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000784"></a><tt>spi</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000786"></a>Interrupt stack pointer
(alias for ‘<tt>cr2</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000788"></a><tt>spu</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000790"></a>User stack pointer (alias
for ‘<tt>cr3</tt>’)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000792"></a><tt>bpc</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000794"></a>Backup program counter
(alias for ‘<tt>cr6</tt>’)</div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000797"></a><a NAME="_Toc442168556"></a><b><i><font size=+2>Addressing
modes for M32R/D targets</font></i></b>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000802"></a><font size=+1>See <a href="m32r.html#14817" CLASS="XRef">Symbols
and addressing modes for the M32R/D processors</a> for the addressing modes
for the M32R/D. The ‘<a NAME="M32R/D"></a><tt>Rn</tt>’ symbol in refers
to any of the specifically numbered registers or register pairs, but not
the control registers.</font></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000841"></a><a NAME="14817"></a><b><font size=+1>Symbols
and addressing modes for the M32R/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000806"></a><b><i>Symbol</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000808"></a><b><i>Addressing mode</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000810"></a><tt>R<i>n</i></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000812"></a>Register direct</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000814"></a><tt>@R<i>n</i></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000816"></a>Register indirect</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000818"></a><tt>@R<i>n</i>+</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000820"></a>Register indirect with
post-increment</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000822"></a><tt>@R<i>n</i>-</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000824"></a>Register indirect with
post-decrement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000826"></a><tt>@-R<i>n</i></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000828"></a>Register indirect with
pre-decrement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000830"></a><tt>@(disp, R<i>n</i>)</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000832"></a>Register indirect with
displacement</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000834"></a><tt>addr</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000836"></a>PC relative address (for
branch or rep)</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000838"></a><tt>#imm</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000840"></a>Immediate data</div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000843"></a><a NAME="_Toc442168557"></a><b><i><font size=+2>Floating
point for M32R/D targets</font></i></b>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000845"></a><font size=+1>Although the M32R/D has no
hardware floating point, the ‘<a NAME="M32R/D"></a> <tt>.float</tt>’ and
‘<tt>.double</tt>’ directives generate IEEE-format floating-point values
for compatibility with other development tools.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000847"></a><a NAME="_Toc442168558"></a><b><i><font size=+2>Pseudo
opcodes for M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000849"></a><font size=+1>M32R/D processors use one
pseudo opcode.</font><a NAME="M32R/D"></a></div>

<div CLASS="BodyHang1">&nbsp;
<br><a NAME="pgfId=1000850"></a><font size=+1><tt>.debugsym </tt><i>&lt;<tt>label</tt>></i></font></div>

<blockquote><font size=+1>Create a label ‘<i> &lt;<tt>label</tt>></i>’
with the value of the next instruction that follows the pseudo op. Unlike
normal labels, the label created with ‘<tt>.debugsym</tt>’ does not force
the next instruction to be aligned to a 32-bit boundary (i.e., it does
not generate a nop, if the previous instruction is a 16-bit instruction,
and the instruction that follows is also a 16-bit instruction).</font></blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000852"></a><a NAME="_Toc442168559"></a><b><i><font size=+2>Opcodes
for M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000853"></a><font size=+1>For detailed information
on the M32R/D machine instruction set, see <b><i>M32R Family Software Manual</i></b>.
The assembler implements all the standard M32R/D opcodes.</font><a NAME="M32R/D"></a></div>

<div CLASS="Body"><a NAME="pgfId=1000855"></a><font size=+1>The assembler
does not support the ‘<tt>:8</tt>’ or ‘<tt>:24</tt>’ syntax for explicitly
specifying the size of the branch instruction. Instead, the assembler supports
the ‘<tt>.s</tt>’ suffix to specify a short branch, and the ‘<tt>.l</tt>
’ suffix to specify a long branch. For example, ‘<tt>bra label:8</tt> ’
becomes ‘<tt>bra.s label</tt>’ and ‘<tt>bra label:24</tt>’ becomes ‘<tt>bra.l
label</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000856"></a><font size=+1>The assembler
does not support the ‘<tt>:8</tt>’ or ‘<tt>:16</tt>’ syntax for explicitly
specifying the size of an immediate constant. Instead, the assembler supports
the ‘<tt>ldi8</tt>’ and ‘<tt>ldi16</tt>’ mnemonics . For example, ‘<tt>ldi
r0, 1:8</tt>’ becomes ‘<tt>ldi8 r0, 1</tt>’ and ‘<tt>ldi r0, 1:16</tt>
’ becomes ‘<tt>ldi16 r0, 1</tt>’.</font></div>

<div CLASS="Heading2"><a NAME="pgfId=1000858"></a><a NAME="_Toc442168560"></a><b><i><font size=+2>Synthetic
instructions for M32R/D targets</font></i></b></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000860"></a><font size=+1>Synthetic instructions are
aliases for existing instructions. They provide an additional and often
simpler way to specify an instruction. See <a href="m32r.html#22499" CLASS="XRef">Synthetic
instructions for M32RR/D processors</a>.</font><a NAME="M32R/D"></a></div>

<div CLASS="TableTitle"><a NAME="pgfId=1000918"></a><a NAME="22499"></a><b><font size=+1>Synthetic
instructions for M32R/D processors</font></b></div>

<table BORDER >
<tr ALIGN=LEFT VALIGN=TOP BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000867"></a><b><i>Synthetic instruction</i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=1000869"></a><b><i>Real instruction</i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000871"></a><tt>bc.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000873"></a><tt>bc label</tt> [8-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000875"></a><tt>bc.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000877"></a><tt>bc label </tt>[24-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000879"></a><tt>bl.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000881"></a><tt>bl label </tt>[8-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000883"></a><tt>bl.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000885"></a><tt>bl label </tt>[24-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000887"></a><tt>bnc.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000889"></a><tt>bnc label </tt>[8-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000891"></a><tt>bnc.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000893"></a><tt>bnc label </tt>[24-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000895"></a><tt>bra.s label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000897"></a><tt>bra label </tt>[8-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000899"></a><tt>bra.l label</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000901"></a><tt>bra label </tt>[24-bit
offset]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000903"></a><tt>ldi8 reg, #const</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000905"></a><tt>ldi reg, #const </tt>[8-bit
constant]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000907"></a><tt>ldi16 reg, #const</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000909"></a><tt>ldi reg, #const </tt>[16-bit
constant]</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000911"></a><tt>push reg</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000913"></a><tt>st reg, @-sp</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=1000915"></a><tt>pop reg</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=1000917"></a><tt>ld reg, @sp+</tt></div>
</td>
</tr>
</table>


<p CLASS="Heading2"><a NAME="pgfId=1000920"></a><b><i><font size=+2>Writing
assembler code for M32R/D targets</font></i></b><a NAME="39494"></a>
<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000922"></a><font size=+1>The best way to write assembler
code is to write a small C program, compile it with the ‘<a NAME="M32R/D"></a><tt>-S</tt>’
flag, and study the assembler code GCC produces.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000923"></a><font size=+1>The assembler
code in the following example (‘<tt>hello.s</tt>’) is from the ‘<tt>hello.c</tt>’
example. It was created with ‘<tt>m32r-elf-gcc -S -O2 hello.c</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000924"></a><font size=+1>See <a href="../5_ut/a_Using_AS/as.html#Top"><i>Using
</i><tt>as</tt></a>
in <b><i>GNUPro Utilities</i></b> for more information on GNU <a href="../5_ut/a_Using_AS/asAssembler_Directives.html#Top">assembler
directives</a>, or <i><a href="../5_ut/a_Using_AS/asas_the_GNU_Assembler.html#Top">pseudo-opcodes<a NAME="marker=1000925"></a></a></i>.
See the<b> <i>M32R Family Software Manual</i></b> for more information
on the instruction set, and syntax.</font></div>

<div CLASS="CodeExample">
<blockquote>
<blockquote>
<pre><a NAME="pgfId=1000926"></a><font size=+1>gcc2_compiled.:</font></pre>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<pre><font size=+1>.section .rodata</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC0:</font></pre>

<pre><font size=+1>.string"hello world!\n"</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC1:</font></pre>

<pre><font size=+1>.string"%d + %d = %d\n"</font></pre>

<pre><font size=+1>.section .text</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.globalmain</font></pre>

<pre><font size=+1>.type main,@function</font></pre>

<pre><font size=+1>main:</font></pre>

<pre><font size=+1>; BEGIN PROLOGUE ; vars= 0, regs= 2, args= 0, extra= 0</font></pre>

<pre><font size=+1>push r8</font></pre>

<pre><font size=+1>push lr</font></pre>

<pre><font size=+1>; END PROLOGUE</font></pre>

<pre><font size=+1>ld24 r8,#a</font></pre>

<pre><font size=+1>ldi r4,#3</font></pre>

<pre><font size=+1>st r4,@(r8)</font></pre>

<pre><font size=+1>ld24 r0,#.LC0</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>ld24 r0,#.LC1</font></pre>

<pre><font size=+1>ld r1,@(r8)</font></pre>

<pre><font size=+1>ld24 r4,#c</font></pre>

<pre><font size=+1>ldi r2,#4</font></pre>

<pre><font size=+1>add3 r3,r1,#4</font></pre>

<pre><font size=+1>st r3,@(r4)</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>; EPILOGUE</font></pre>

<pre><font size=+1>pop lr</font></pre>

<pre><font size=+1>pop r8</font></pre>

<pre><font size=+1>jmp lr</font></pre>

<pre><font size=+1>.Lfe1:</font></pre>

<pre><font size=+1>.size main,.Lfe1-main</font></pre>

<pre><font size=+1>.comma,4,4</font></pre>

<pre><font size=+1>.commc,4,4</font></pre>

<pre><font size=+1>.ident"GCC: (GNU) 2.7-m32r-970408"</font></pre>
</blockquote>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000927"></a><font size=+1>To assemble
the ‘<tt>hello.s</tt> ’ file, use the following input.</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000928"></a><tt><font size=+1>m32r-elf-as
hello.s -o hello.o</font></tt></div>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000929"></a><font size=+1>The following
are some tips for assembler programmers.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000930"></a><font size=+1>To clear the ‘<tt>CBR</tt>’ register,
just one instruction can be used:</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote><a NAME="pgfId=1000931"></a><tt><font size=+1>cmp Rx,Rx total
2 bytes</font></tt></blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote><a NAME="pgfId=1000932"></a><font size=+1>Where ‘<tt>Rx</tt>
’, is an arbitrary register. Note the operation does not destroy the contents
of ‘<tt>Rx</tt>’. The previous code example is smaller than the following
code:</font></blockquote>
</blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000933"></a><tt><font size=+1>ldi Rx,#1</font></tt></blockquote>
</blockquote>
</div>

<blockquote><font size=+1><tt>cmpi Rx,#0</tt> total 6 bytes and destroys
‘<tt>Rx</tt>’.</font></blockquote>

<ul TYPE=SQUARE>
<ul TYPE=SQUARE>
<div CLASS="Bullet"><a NAME="pgfId=1000934"></a><font size=+1>To set the
‘<tt>CBR</tt>’ register, there are several methods. First, try using the
following example’s input.</font></div>
</ul>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000935"></a><tt><font size=+1>ldi Rx,#-1</font></tt>
<br><font size=+1><tt>addv R0,R0</tt> <tt>total 4 bytes</tt></font></blockquote>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000936"></a><font size=+1>Alternatively,
try using the following example’s input.</font></div>
</blockquote>
</blockquote>

<blockquote>
<blockquote>
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000937"></a><tt><font size=+1>ldi
Rx,#-2</font></tt></div>

<p><br><tt><font size=+1>addx R0,R0 total 4 bytes</font></tt></blockquote>
</blockquote>
</blockquote>

<blockquote>
<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000938"></a><font size=+1>The
previous code examples are smaller than the following code example:</font></div>

<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000939"></a><tt><font size=+1>ldi
Rx,#0</font></tt></div>

<p><br><tt><font size=+1>cmpi Rx,#1 total 6 bytes</font></tt></blockquote>

<div CLASS="Bullet"><a NAME="pgfId=1000940"></a><font size=+1>To set a
comparison result to a register, there are some idioms for the M32R.</font></div>
</blockquote>
</blockquote>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote><a NAME="pgfId=1000941"></a><font size=+1>For instance, try
using the following example’s input.</font></blockquote>
</blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000942"></a><tt><font size=+1>(a) ‘... flag
= (x == 0);...’</font></tt></blockquote>
</blockquote>
</blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000943"></a><tt><font size=+1>cmpui Rx,#1</font></tt></blockquote>
</blockquote>
</blockquote>
</div>

<blockquote>
<blockquote>
<blockquote><tt><font size=+1>mvfc Rx,CBR total 4 byte</font></tt>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000944"></a><tt><font size=+1>(b)
‘...flag = !(x op 0); ...’</font></tt></blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000945"></a><font size=+1>To
get the inverted result of comparison, first set ‘<tt>CBR</tt>’ using one
of the methods above, then, try using the following example’s input.</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000946"></a><tt><font size=+1>subx
Rx,Rx</font></tt></div>

<p><br><tt><font size=+1>addi Rx,#1 total 4 byte</font></tt></blockquote>
</blockquote>
</blockquote>

<blockquote>
<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000947"></a><font size=+1>The
previous example will provide better results than than the following code.</font></div>
</blockquote>
</blockquote>

<blockquote>
<blockquote>
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000948"></a><tt><font size=+1>mvfc
Rx,CBR</font></tt></div>

<p><br><tt><font size=+1>xor3 Rx,Rx,#1 total 6-byte</font></tt></blockquote>

<div CLASS="Label"><a NAME="pgfId=1000949"></a><font size=+1>Note:</font></div>

<div CLASS="Label"><a NAME="pgfId=1000950"></a><font size=+1>The ‘<tt>subx
Rx,Rx</tt> ’ operation is equivalent to the following code.</font></div>
</blockquote>
</blockquote>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000951"></a><tt><font size=+1>mvfc Rx,CBR</font></tt>
<br><tt><font size=+1>neg Rx,Rx</font></tt></blockquote>
</blockquote>
</blockquote>
</div>

<div CLASS="Heading2"><a NAME="pgfId=1000953"></a><b><i><font size=+2>Writing
assembler code for M32R/D targets</font></i></b><a NAME="40448"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000954"></a><font size=+1>The best way to write assembler
code is to write a small C program, compile it with the ‘<tt>-S</tt>’ flag,
and study the assembler code GCC produces.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000955"></a><font size=+1>See <a href="../5_ut/a_Using_AS/as.html#Top"><i>Using
</i><tt>as</tt></a>
in <b><i>GNUPro Utilities</i></b> for more information on GNU <a href="../5_ut/a_Using_AS/asAssembler_Directives.html#Top">assembler
directives</a>, or <i><a href="../5_ut/a_Using_AS/asas_the_GNU_Assembler.html#Top">pseudo-opcodes</a></i>.
See the<b> <i>M32R Family Software Manual</i></b> for more information
on the instruction set, and syntax.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000956"></a><font size=+1>The following
example shows the ‘<tt>hello.s</tt>’ assembler code from the ‘<tt>hello.c</tt>’
example. It was created with ‘<tt>m32r-elf-gcc -S -O2 hello.c</tt>’.</font></div>

<div CLASS="CodeExample">
<blockquote>
<pre><a NAME="pgfId=1000957"></a><font size=+1>gcc2_compiled.:</font></pre>
</blockquote>
</div>

<blockquote>
<pre><font size=+1>.section .rodata</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC0:</font></pre>

<pre><font size=+1>.string"hello world!\n"</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.LC1:</font></pre>

<pre><font size=+1>.string"%d + %d = %d\n"</font></pre>

<pre><font size=+1>.section .text</font></pre>

<pre><font size=+1>.balign 4</font></pre>

<pre><font size=+1>.globalmain</font></pre>

<pre><font size=+1>.type main,@function</font></pre>

<pre><font size=+1>main:</font></pre>

<pre><font size=+1>; BEGIN PROLOGUE ; vars= 0, regs= 2, args= 0, extra= 0</font></pre>

<pre><font size=+1>push r8</font></pre>

<pre><font size=+1>push lr</font></pre>

<pre><font size=+1>; END PROLOGUE</font></pre>

<pre><font size=+1>ld24 r8,#a</font></pre>

<pre><font size=+1>ldi r4,#3</font></pre>

<pre><font size=+1>st r4,@(r8)</font></pre>

<pre><font size=+1>ld24 r0,#.LC0</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>ld24 r0,#.LC1</font></pre>

<pre><font size=+1>ld r1,@(r8)</font></pre>

<pre><font size=+1>ld24 r4,#c</font></pre>

<pre><font size=+1>ldi r2,#4</font></pre>

<pre><font size=+1>add3 r3,r1,#4</font></pre>

<pre><font size=+1>st r3,@(r4)</font></pre>

<pre><font size=+1>bl printf</font></pre>

<pre><font size=+1>; EPILOGUE</font></pre>

<pre><font size=+1>pop lr</font></pre>

<pre><font size=+1>pop r8</font></pre>

<pre><font size=+1>jmp lr</font></pre>

<pre><font size=+1>.Lfe1:</font></pre>

<pre><font size=+1>.size main,.Lfe1-main</font></pre>

<pre><font size=+1>.comma,4,4</font></pre>

<pre><font size=+1>.commc,4,4</font></pre>

<pre><font size=+1>.ident"GCC: (GNU) 2.7-m32r-970408"</font></pre>

<pre></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000958"></a><font size=+1>To assemble
the ‘<tt>hello.s</tt> ’ file, enter:</font></div>

<br>&nbsp;
<blockquote>
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000959"></a><tt><font size=+1>m32r-elf-as
hello.s -o hello.o</font></tt></div>
</blockquote>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=1000960"></a><font size=+1>The following
are some tips for assembler programmers:</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000961"></a><font size=+1>To clear the ‘<tt>CBR</tt>’ register,
just one instruction can be used:</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000962"></a><tt><font size=+1>cmp Rx,Rx total
2 bytes</font></tt></blockquote>
</blockquote>
</blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote><a NAME="pgfId=1000963"></a><font size=+1>Where ‘<tt>Rx</tt>
’, is an arbitrary register. Note the operation does not destroy the contents
of ‘<tt>Rx</tt>’. The previous code example is smaller than the following
code:</font></blockquote>
</blockquote>
</div>

<div CLASS="CodeExample2">
<blockquote>
<blockquote>
<blockquote><a NAME="pgfId=1000964"></a><tt><font size=+1>ldi Rx,#1</font></tt>
<br><tt><font size=+1>cmpi Rx,#0 total 6 bytes and destroys ‘Rx’.</font></tt></blockquote>
</blockquote>
</blockquote>
</div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1000965"></a><font size=+1>To set the ‘<tt>CBR</tt>’ register,
there are several methods:</font></li>
</ul>

<div CLASS="CodeExample2">
<blockquote>
<blockquote><a NAME="pgfId=1000966"></a><tt><font size=+1>ldi Rx,#-1</font></tt>
<br><font size=+1><tt>addv R0,R0</tt> <tt>total 4 bytes</tt></font></blockquote>
</blockquote>
</div>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000967"></a><font size=+1>or</font></div>

<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000968"></a><tt><font size=+1>ldi
Rx,#-2</font></tt></div>

<p><br><tt><font size=+1>addx R0,R0 total 4 bytes</font></tt></blockquote>
</blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=1000969"></a><font size=+1>The
previous code examples are smaller than the following code example:</font></div>

<div CLASS="CodeExample2"><a NAME="pgfId=1000970"></a><tt><font size=+1>ldi
Rx,#0</font></tt></div>

<p><br><tt><font size=+1>cmpi Rx,#1 total 6 bytes</font></tt>
<li CLASS="Bullet">
<a NAME="pgfId=1000971"></a><font size=+1>To set a comparison result to
a register, there are some idioms for the M32R.</font></li>
</blockquote>

<div CLASS="BodyListFollow">
<blockquote><a NAME="pgfId=1000972"></a><font size=+1>For instance:</font></blockquote>
</div>

<div CLASS="BodyListFollow">
<blockquote>
<blockquote><a NAME="pgfId=1000973"></a><tt><font size=+1>(a) ‘... flag
= (x == 0);...’</font></tt>
<br><a NAME="pgfId=1000974"></a><tt><font size=+1>cmpui Rx,#1</font></tt></blockquote>
</blockquote>
</div>

<blockquote>
<blockquote><tt><font size=+1>mvfc Rx,CBR total 4 byte</font></tt>

<p CLASS="BodyListFollow"><a NAME="pgfId=1000975"></a><tt><font size=+1>(b)
‘...flag = !(x op 0); ...’</font></tt></blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000976"></a><font size=+1>To
get the inverted result of comparison, first set ‘<tt>CBR</tt>’ using one
of the methods above, then:</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000977"></a><tt><font size=+1>subx
Rx,Rx</font></tt></div>

<p><br><tt><font size=+1>addi Rx,#1 total 4 byte</font></tt></blockquote>

<div CLASS="BodyListFollow"><a NAME="pgfId=1000978"></a><font size=+1>rather
than the following code</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000979"></a><tt><font size=+1>mvfc
Rx,CBR</font></tt></div>

<p><br><tt><font size=+1>xor3 Rx,Rx,#1 total 6-byte</font></tt></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=1000980"></a><i><font size=+1>Note:</font></i></div>

<p><br><font size=+1>The ‘<tt>subx Rx,Rx</tt>’ operation is equivalent
to:</font>
<br>&nbsp;
<blockquote>
<div CLASS="CodeExample2"><a NAME="pgfId=1000981"></a><tt><font size=+1>mvfc
Rx,CBR</font></tt></div>

<p><br><tt><font size=+1>neg Rx,Rx</font></tt></blockquote>
</blockquote>

<div CLASS="Heading2"><a NAME="pgfId=1000985"></a><b><i><font size=+2>Inserting
assembly instructions into C code for M32R/D targets</font></i></b><a NAME="24340"></a><a NAME="M32R/D"></a><a NAME="M32R/D"></a></div>

<div CLASS="Body">&nbsp;
<br><a NAME="pgfId=1000986"></a><font size=+1>Assembly code can be embedded
in C or C++ code with the ‘<tt>asm</tt>’ keyword. There are two forms of
‘<tt>asm</tt>’: <b><i>simple</i></b> and <b><i>extended</i></b>. The syntax
uses the following form.</font></div>

<div CLASS="CodeExample">
<blockquote><a NAME="pgfId=1000987"></a><font size=+1><tt>asm</tt> <tt>("assembly
code");</tt></font></blockquote>
</div>

<div CLASS="Body"><a NAME="pgfId=1000988"></a><font size=+1>For instance,
consider the following example’s input.</font></div>

<div CLASS="CodeExample">
<blockquote><a NAME="pgfId=1000989"></a><font size=+1><tt>asm</tt> <tt>("nop");</tt></font></blockquote>
</div>

<div CLASS="Body"><a NAME="pgfId=1000990"></a><font size=+1>C string concatenation
works with ‘<tt>asm</tt>’ so more complicated expressions can be spread
out over several lines.</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000991"></a><tt><font size=+1>asm
(</font></tt></div>

<p><br><tt><font size=+1>".global foo\n"</font></tt>
<br><tt><font size=+1>"foo:\n"</font></tt>
<br><tt><font size=+1>".word 42\n"</font></tt>
<br><tt><font size=+1>);</font></tt></blockquote>

<div CLASS="Body"><a NAME="pgfId=1000992"></a><font size=+1>This example
creates a variable called ‘<tt>foo</tt>’ with the value of 42, and is obviously
intended to be compiled outside of any function definition.</font></div>

<div CLASS="Body"><a NAME="pgfId=1000993"></a><font size=+1>Another way
to write that would be:</font></div>

<br>&nbsp;
<blockquote>
<div CLASS="CodeExample"><a NAME="pgfId=1000994"></a><tt><font size=+1>asm
("\</font></tt></div>

<p><br><tt><font size=+1>.global foo</font></tt>
<br><tt><font size=+1>foo:</font></tt>
<br><tt><font size=+1>.word 42</font></tt>
<br><tt><font size=+1>");</font></tt>
<h6 CLASS="Label">
<a NAME="pgfId=1000995"></a><font size=+1>Warning!</font></h6>
</blockquote>

<div CLASS="Note">
<blockquote><a NAME="pgfId=1000996"></a><font size=+1>The simple form is
only for cases where the compiler doesn’t need to know what values are
being used and what values are being modified by the assembly code. This
is because the contents of the assembly code are hidden from GCC’s data-flow
analysis. GCC does not parse the assembly code, it merely copies it verbatim
to the output file.</font></blockquote>
</div>

<div CLASS="Body"><a NAME="pgfId=1000997"></a><font size=+1>Using the extended
form of ‘<tt>asm</tt>’, you can specify the operands of the instruction
using C expressions. You need not guess which registers or memory locations
will contain the data you want to use. Its syntax has the following form.</font></div>

<div CLASS="CodeExample">
<blockquote><a NAME="pgfId=1000998"></a><tt><font size=+1>asm ("assembly
code" : outputs : inputs : clobbers);s</font></tt></blockquote>
</div>

<div CLASS="Body"><a NAME="pgfId=1000999"></a><font size=+1>The inputs
and clobbers are optional in an extended asm. The outputs are optional
too, but then the asm is no longer an "extended asm" and is rather a "simple
asm".</font></div>

<div CLASS="Body"><a NAME="pgfId=1001000"></a><font size=+1>‘<tt>outputs</tt>’
is a comma separated list of C expressions that are the results of the
assembly code. The syntax is a string containing the "operand constraint"
followed by a C expression in parentheses.</font></div>

<div CLASS="Body"><a NAME="pgfId=1001001"></a><font size=+1>‘<tt>inputs</tt>’
syntax is identical to the syntax of ‘<tt>outputs</tt>’.</font></div>

<div CLASS="Body"><a NAME="pgfId=1001002"></a><font size=+1>‘<tt>clobbers</tt>’
is a comma separated list of registers that are modified by the assembly
code but aren’t listed in the outputs. If memory is or may be modified,
specify "memory" in the ‘<tt>clobbers</tt>’ section.</font></div>

<div CLASS="Body"><a NAME="pgfId=1001003"></a><font size=+1>The following
example shows an ‘<tt>asm</tt>’ statement that adds two values together.</font></div>

<div CLASS="CodeExample"><a NAME="pgfId=1001004"></a><tt><font size=+1>int
add (int arg1, int arg2)</font></tt></div>

<br><tt><font size=+1>{</font></tt>
<br><tt><font size=+1>asm ("add %0, %1" : "+r" (arg1) : "r" (arg2));</font></tt>
<br><tt><font size=+1>return arg1;</font></tt>
<br><tt><font size=+1>}</font></tt>

<p CLASS="Body"><a NAME="pgfId=1001005"></a><font size=+1>The statement
was constructed with the following procedure.</font>
<ol>
<li CLASS="Numbered">
<a NAME="pgfId=1001006"></a>1. The text to create the assembler instruction
is the first part of the ‘<tt>asm</tt>’ statement, as in the following
example.</li>
</ol>

<div CLASS="CodeExample2"><a NAME="pgfId=1001007"></a>"add r1, r2"</div>

<div CLASS="NumberedNext"><a NAME="pgfId=1001008"></a><font size=+1>The
registers containing the arguments, however, if unknown to the programmer,
are given placeholders, as in the following example.</font></div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001009"></a>"add %0, %1"</div>

<div CLASS="NumberedNext"><a NAME="pgfId=1001010"></a><font size=+1>Specify
the values of these placeholders in numerical order, starting from 0, immediately
after the assembler instruction, as in the following example.</font></div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001011"></a>"add %0, %1" arg1
arg2</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001012"></a>This is wrong in
several ways. First, the syntax specifies, that C variables and expressions
must be enclosed in parentheses, as in the following example.</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001013"></a>"add %0, %1" (arg1)
(arg2)</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001014"></a>Second, there must
be a colon between the assembler text and the placeholders, as in the following
example.</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001015"></a>"add %0, %1" : (arg1)
(arg2)</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001016"></a>Third, each placeholder
should be separated from the next by a comma, as in the following example.</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001017"></a>"add %0, %1" : (arg1)
, (arg2)</div>

<div CLASS="NumberedNext"><a NAME="pgfId=1001018"></a><font size=+1>Specify
the constraints for the placeholders. These constraints use the same syntax
as the constraints found on machine patterns in the ‘<tt>m32r.md</tt>’
file. A constraint is a sequence of letters enclosed within double quotes
that specifies what kind of thing the placeholder can be. For a complete
list of letters, see <a href="../2_comp/Using_GNU_CC/gccSimple_Constraints.html" CLASS="XRef">Simple
constraints</a>.</font></div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001022"></a>Both arguments
should be in registers (since the add instruction only takes register arguments),
so it now resembles the following example’s input.</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001023"></a>"add %0, %1" : "r"
(arg1) , "r" (arg2)</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001024"></a>Use extra constrain
on (arg1) to let the compiler know that not only is (arg1) used as an input
to the instruction, but that it is also used to hold the instruction’s
output. This is done in two parts.</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001025"></a>First, the constraint
must include the ‘<tt>+</tt>’ character to show that the register is both
read and written by the instruction (use the following example’s input).</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001026"></a>"add %0, %1" : "+r"
(arg1) , "r" (arg2)</div>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001027"></a>Second, the syntax
specifies that all placeholders that are outputs of the instruction must
be specified first; then a colon must appear and then any placeholders
that are just inputs can appear, as in the following example’s input. The
comma is removed, since the colon takes its place.</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001028"></a>"add %0, %1" : "+r"
(arg1) : "r" (arg2)</div>

<div CLASS="Body"><a NAME="pgfId=1001029"></a>That is the complete ‘<tt>
asm</tt>’ statement.</div>

<div CLASS="Body"><a NAME="pgfId=1001033"></a>For more information on extended
asm, see <a href="../2_comp/Using_GNU_CC/gccAlternate_Keywords.html" CLASS="XRef">Alternate
keywords</a> in <i><a href="../2_comp/Using_GNU_CC/gcc.html">Using GNU
CC</a></i> in <b><i>GNUPro Compiler Tools</i></b>.</div>

<h4 CLASS="Heading2">
<a NAME="pgfId=1001036"></a>M32R/D-specific assembler error messages<a NAME="19548"></a>&nbsp;<a NAME="M32R/D"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001037"></a>The following error messages
may occur for M32R/X/D processors during assembly implementation.</div>

<div CLASS="BodyHang1"><a NAME="pgfId=1001038"></a><tt>Error: bad instruction</tt></div>

<p><br>The instruction is misspelled or there is a syntax error somewhere.

<p CLASS="BodyHang1"><a NAME="pgfId=1001039"></a><tt>Error: expression
too complex</tt>

<p CLASS="BodyHang1List"><a NAME="pgfId=1001040"></a><tt>Error: unresolved
expression that must be resolved</tt>
<br>The instruction contains an expression that is too complex; no relocation
exists to handle it.

<p CLASS="BodyHang1"><a NAME="pgfId=1001041"></a><tt>Error: relocation
overflow</tt>
<br>The instruction contains an expression that is too large to fit in
the field.
<h4 CLASS="Heading2">
<a NAME="pgfId=1001043"></a>Producing S-records for M32R/D targets<a NAME="M32R/D"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001044"></a>The following command reads
the contents of the ‘<tt>hello.x</tt>’ file, converts the code and data
into S-records, and puts the result into the ‘<tt>hello.srec</tt>’ file.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001045"></a><tt>m32r-elf-objcopy
-O srec hello.x hello.srec</tt></div>

<div CLASS="Body"><a NAME="pgfId=1001046"></a>The first few lines of ‘<tt>
hello.srec</tt>’ are in the following example.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001047"></a><tt>S00D000068656C6C6F2E7372656303</tt></div>

<p><br><tt>S11801002D7F2E7F1D8FF000E0006DF4FE0000FEFE001B281F54</tt>
<br><tt>S11801158D2EEF2DEF1FCEEF1000006D00F000E20075C0E300C8</tt>
<br><tt>S118012A75F4032214835402610042FCF000B0840003216244B4</tt>
<br><tt>S118013FFFB094FFFF84C300034204F000B08400042102420148</tt>
<h3 CLASS="Heading1">
<a NAME="pgfId=1001049"></a><a NAME="_Toc442168561"></a>Linker issues for
M32R/D targets</h3>

<div CLASS="Body"><a NAME="pgfId=1001054"></a>For a list of available generic
linker options, see <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Top" CLASS="XRef">Linker
scripts</a> in&nbsp;<a NAME="M32R/D"></a><a href="../5_ut/b_Usingld/ld.html"><i>Using
</i><tt>ld</tt></a>
in <b><i>GNUPro Utilities</i></b>. In addition, the following M32R/D-specific
command-line option is supported.</div>

<div CLASS="BodyHang1"><a NAME="pgfId=1001055"></a><tt>--defsym _stack=0xnnnn</tt></div>

<p><br>Specify the initial value for the stack pointer. This assumes the
application loads the stack pointer with the value of ‘<tt>_stack</tt>’
in the start up code.

<p CLASS="BodyListFollow"><a NAME="pgfId=1001056"></a>The initial value
for the stack pointer is defined in the linker script with the <tt>PROVIDE</tt>
linker command. This allows the user to specify a new value on the command
line with the standard linker option ‘--<tt>defsym</tt>’.
<h4 CLASS="Heading2">
<a NAME="pgfId=1001058"></a><a NAME="_Toc442168563"></a>Linker script for
the M32R/D targets</h4>

<div CLASS="Body"><a NAME="pgfId=1001059"></a>The GNU linker uses a linker
script to determine how to process each section in an object file, and
how to lay out the executable. The linker script is a declarative program
consisting of a number of directives. For instance, the ‘<tt>ENTRY()</tt>
’ directive specifies the symbol in the executable that will be the executable’s
entry point. Since linker scripts can be complicated to write, the linker
includes one built-in script that defines the default linking process.</div>

<div CLASS="Body"><a NAME="pgfId=1001060"></a>For the M32R/D tools, the
following example shows the default script. Although the script is somewhat
lengthy, it is a generic script that will support all ELF situations. In
practice, generation of sections like ‘<tt>.rela.dtors</tt>’ are unlikely
when compiling using embedded ELF tools.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001061"></a>OUTPUT_FORMAT("elf32-m32r",
"elf32-m32r", "elf32-m32r")</div>

<p><br>OUTPUT_ARCH(m32r)
<br>ENTRY(_start)
<br>SEARCH_DIR( <i>&lt;installation directory path></i> );
<p>SECTIONS
<br>{
<br>/* Read-only sections, merged into text segment: */
<br>. = 0x200000;
<br>.interp : { *(.interp) }
<br>.hash : { *(.hash) }
<br>.dynsym : { *(.dynsym) }
<br>.dynstr : { *(.dynstr) }
<br>.rel.text : { *(.rel.text) }
<br>.rela.text : { *(.rela.text) }
<br>.rel.data : { *(.rel.data) }
<br>.rela.data : { *(.rela.data) }
<br>.rel.rodata : { *(.rel.rodata) }
<br>.rela.rodata : { *(.rela.rodata) }
<br>.rel.got : { *(.rel.got) }
<br>.rela.got : { *(.rela.got) }
<br>.rel.ctors : { *(.rel.ctors) }
<br>.rela.ctors : { *(.rela.ctors) }
<br>.rel.dtors : { *(.rel.dtors) }
<br>.rela.dtors : { *(.rela.dtors) }
<br>.rel.init : { *(.rel.init) }
<br>.rela.init : { *(.rela.init) }
<br>.rel.fini : { *(.rel.fini) }
<br>.rela.fini : { *(.rela.fini) }
<br>.rel.bss : { *(.rel.bss) }
<br>.rela.bss : { *(.rela.bss) }
<br>.rel.plt : { *(.rel.plt) }
<br>.rela.plt : { *(.rela.plt) }
<br>.init : { *(.init) } =0
<br>.plt : { *(.plt) }
<br>.text :
<br>{
<br>*(.text)
<br>/* .gnu.warning sections are handled specially by
<br>elf32.em. */
<br>*(.gnu.warning)
<br>*(.gnu.linkonce.t*)
<br>} =0
<p>_etext = .;
<br>PROVIDE (etext = .);
<br>.fini : { *(.fini) } =0
<br>.rodata : { *(.rodata) *(.gnu.linkonce.r*) }
<br>.rodata1 : { *(.rodata1) }
<br>/* Adjust the address for the data segment. We want to
<br>adjust up to the same address within the page on the
<br>next page up. */
<p>. = ALIGN(32) + (ALIGN(8) &amp; (32 - 1));
<br>.data :
<br>{
<br>*(.data)
<br>*(.gnu.linkonce.d*)
<br>CONSTRUCTORS
<br>}
<br>.data1 : { *(.data1) }
<br>.ctors : { *(.ctors) }
<br>.dtors : { *(.dtors) }
<br>.got : { *(.got.plt) *(.got) }
<br>.dynamic : { *(.dynamic) }
<br>/* We want the small data sections together, so
<br>single-instruction offsets can access them all, and
<br>initialized data all before uninitialized, so we can
<br>shorten the on-disk segment size. */
<p>.sdata : { *(.sdata) }
<br>_edata = .;
<br>PROVIDE (edata = .);
<br>__bss_start = .;
<br>.sbss : { *(.sbss) *(.scommon) }
<br>.bss : { *(.dynbss) *(.bss) *(COMMON) }
<br>_end = . ;
<br>PROVIDE (end = .);
<br>/* Stabs debugging sections. */
<br>.stab 0 : { *(.stab) }
<br>.stabstr 0 : { *(.stabstr) }
<br>.stab.excl 0 : { *(.stab.excl) }
<br>.stab.exclstr 0 : { *(.stab.exclstr) }
<br>.stab.index 0 : { *(.stab.index) }
<br>.stab.indexstr 0 : { *(.stab.indexstr) }
<br>.comment 0 : { *(.comment) }
<p>/* DWARF debug sections.
<br>Symbols in the .debug DWARF section are relative to the
<br>beginning of the section so we begin .debug at 0. It’s
<br>not clear yet what needs to happen for the others. */
<p>.debug 0 : { *(.debug) }
<br>.debug_srcinfo 0 : { *(.debug_srcinfo) }
<br>.debug_aranges 0 : { *(.debug_aranges) }
<br>.debug_pubnames 0 : { *(.debug_pubnames) }
<br>.debug_sfnames 0 : { *(.debug_sfnames) }
<br>.line 0 : { *(.line) }
<p>PROVIDE (_stack = 0x3ffffc);
<p>}
<h3 CLASS="Heading1">
<a NAME="pgfId=1001063"></a>Debugger issues with M32R/D targets<a NAME="15706"></a></h3>

<div CLASS="Body"><a NAME="pgfId=1001065"></a>For the available generic
debugger options, see&nbsp;<a NAME="M32R/D"></a><i><a href="../3_dbug/b_Debugging_with_GDB/gdb.html#Top">Debugging
with GDB</a></i> in <b><i>GNUPro Debugging Tools</i></b>. There are no
M32R/D specific debugger command-line options.</div>

<div CLASS="Body"><a NAME="pgfId=1001066"></a>Cygnus Insight is the graphic
user interface (GUI) for the GNUPro debugger. See <a href="../1_GS/int06.html#Top">Working
with Cygnus Insight, the visual debugger</a> in <b><i><a href="../1_GS/gsintro.html">GETTING
STARTED</a></i></b>.</div>

<div CLASS="Body"><a NAME="pgfId=1001070"></a>There are three ways for
GDB to talk to an M32R/D target: through the built-in simulator, through
a remote target board with a remote stub linked directly to the user program
and through a remote target board with the remote stub already loaded independently.
See the following documentation for details.</div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001071"></a><b>Simulator</b></li>

<br>GDB’s built-in software simulation of the M32R/D processor allows the
debugging of programs compiled for the M32R/D without requiring any access
to actual hardware. Activate this mode in GDB by using the ‘<tt>target
sim</tt>’ command. Then load code into the simulator by using the ‘<tt>
load</tt>’ command and debug it in the normal fashion.
<li CLASS="Bullet">
<a NAME="pgfId=1001072"></a><b>Remote target board, with remote stub linked
directly to user program</b></li>

<br>The program being debugged must have the remote debugging protocol
subprogram linked directly into it, to use this mode.</ul>

<div CLASS="BodyListFollow"><a NAME="pgfId=1001073"></a>The program is
then downloaded to the target board by GDB, using the ‘<tt>target mon2000
</tt><i>&lt;devicename></i>’
command where ‘<i> &lt;devicename></i>’ will be a serial device such as
‘<tt>/dev/ttya</tt>’ (Unix) or ‘<tt>com2</tt>’ (Windows 95). After being
downloaded, the program must be running and it must execute the following
function calls into the remote debugging subprogram:</div>

<div CLASS="CodeExample2"><a NAME="pgfId=1001074"></a><tt>set_debug_traps();</tt></div>

<p><br><tt>breakpoint();</tt>

<p CLASS="BodyListFollow"><a NAME="pgfId=1001075"></a>If GDB is running
on a Unix host computer, start the target program by simply using the ‘<tt>
run</tt>’ command at the ‘<tt>(gdb)</tt>’ prompt. Then GDB must be interrupted
by using several <i>Ctrl-c</i> (<tt>^C</tt> ) characters. However, if GDB
is being run on a Microsoft Windows 95 host computer, you must exit from
GDB and connect to the M32R/D EVA target board with a terminal program
such as Kermit or HyperTerminal. Use the <i>Return</i> key to get the ROM
monitor’s ‘<tt>ok</tt>’ prompt; then use the ‘<tt>go</tt>’ command and
use the <i>Return</i> key, as the following example input shows.

<p CLASS="CodeExample2"><a NAME="pgfId=1001076"></a><tt>ok</tt> go

<p CLASS="BodyListFollow"><a NAME="pgfId=1001077"></a>Then exit from the
terminal program and start up GDB again. It is then possible to connect
GDB to the target using GDB’s remote protocol, with the command ‘<tt>target
remote </tt><i>&lt;devicename></i>’ where ‘<i> &lt;devicename></i>’, as
before, is the name of a serial device. The debugging session can then
proceed. GDB will initially report that the program has received a ‘<tt>
SIGTRAP</tt>’ while executing the call to the ‘<tt>breakpoint( )</tt> ’
function . From there you can continue or single-step to get back into
your own program.
<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001078"></a><b>Remote target board, remote stub already
loaded independently</b></li>

<br>In this mode, it is assumed that the remote protocol subprogram is
already running on the target board. With the remote stub already running
on the target board, use the ‘<tt>gdb</tt>’command to start the debugging,
then use the ‘<tt>target remote </tt><i>&lt;devicename></i>’ command, where
‘<i> &lt;devicename></i>’ will be a serial device such as ‘<tt>/dev/ttya</tt>’(Unix)
or ‘<tt>com2</tt>’ (Windows 95), and then download your program and begin
debugging it. Downloading is from six to seven times faster using this
method.</ul>

<h6 CLASS="Label">
<a NAME="pgfId=1001079"></a>Note:</h6>

<div CLASS="Note"><a NAME="pgfId=1001080"></a>When using the remote target,
GDB does not accept the ‘<tt>run</tt>’ command. However, since downloading
the program has the side effect of setting the PC to the start address,
you can start your program by using the ‘<tt>continue</tt>’ command.</div>

<h3 CLASS="Heading1">
<a NAME="pgfId=1001082"></a><a NAME="_Toc442168567"></a>Stand-alone simulator
for M32R/D targets</h3>

<div CLASS="Body"><a NAME="pgfId=1001084"></a>The simulator supports the
‘<a NAME="M32R/D"></a> <tt>r0</tt>’ to ‘<tt>r15</tt>’ <i>general-registers</i>
, the ‘<tt>psw</tt>’, ‘<tt>cbr</tt>’, ‘<tt>spi</tt>’, ‘<tt>spu</tt> ’,
‘<tt>bpc</tt>’ <i>control-registers</i> , and the <i>accumulator</i> .
The simulator allocates a contiguous chunk of memory starting at the ‘<tt>0</tt>’
address. Default memory size is 8 MB.</div>

<div CLASS="Body"><a NAME="pgfId=1001085"></a>Three run-time command-line
options are available with the simulator: <tt>-t</tt> , <tt>-v</tt> , and
<tt>-p</tt>
.</div>

<h6 CLASS="Label">
<a NAME="pgfId=1001086"></a>warning!</h6>

<div CLASS="Note"><a NAME="pgfId=1001087"></a>Simulator cycle counts are
not intended to be extremely accurate in the following script examples.
Use them with caution.</div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001088"></a>The ‘<tt>-t</tt>’ command-line option to the
stand-alone simulator turns on instruction level tracing as shown in the
following segment:</li>
</ul>

<div CLASS="CodeExample2"><a NAME="pgfId=1001089"></a><tt>%m32r-elf-run
-t hello.x</tt></div>
<tt>0x00011c ld24 sp,0x100000 dr &lt;- 0x100000</tt>
<br><tt>0x000120 ldi fp,0 dr &lt;- 0x0</tt>
<br><tt>0x000122 nop</tt>
<br><tt>0x000124 ld24 r2,0x75c0 dr &lt;- 0x75c0</tt>
<br><tt>0x000128 ld24 r3,0x75f4 dr &lt;- 0x75f4</tt>
<br><tt>0x00012c sub r3,r2 dr &lt;- 0x34</tt>
<br><tt>0x00012e mv r4,r3 dr &lt;- 0x34</tt>
<br><tt>0x000130 srli r4,0x2 dr &lt;- 0xd</tt>
<br><tt>0x000132 ldi r1,0 dr &lt;- 0x0</tt>
<br><tt>0x000134 addi r2,-4 dr &lt;- 0x75bc</tt>
<br><tt>0x000136 nop</tt>
<br><tt>0x000138 . . .</tt>
<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001090"></a>The ‘<tt>-v</tt>’ command-line option prints
some simple statistics:</li>
</ul>

<div CLASS="CodeExample2"><a NAME="pgfId=1001091"></a><tt>%m32r-elf-run
-v hello.x</tt></div>

<p><br><tt>hello world!</tt>
<br><tt>3 + 4 = 7</tt>
<br><tt>Total: 3808 insns</tt>
<br><tt>Fill nops: 609</tt>
<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001092"></a>The ‘<tt>-p</tt>’ command prints profiling
statistics.</li>
</ul>

<div CLASS="CodeExample2"><a NAME="pgfId=1001093"></a><tt>%</tt> m32r-elf-run
-p hello.x</div>

<p><br><tt>Hello world!</tt>
<br><tt>3 + 4 = 7</tt>
<br><tt>Instruction Statistics</tt>
<p><tt>Total: 3796 insns</tt>
<p><tt>add: 75: *****</tt>
<br><tt>add3: 123: ********</tt>
<br><tt>and: 3:</tt>
<br><tt>and3: 61: ****</tt>
<br><tt>or: 28: *</tt>
<br><tt>or3: 3:</tt>
<br><tt>addi: 222: ***************</tt>
<br><tt>bc8: 9:</tt>
<br><tt>bc24: 3:</tt>
<br><tt>beq: 23: *</tt>
<br><tt>beqz: 131: ********</tt>
<br><tt>bgez: 8:</tt>
<br><tt>bgtz: 2:</tt>
<br><tt>blez: 42: **</tt>
<br><tt>bltz: 6:</tt>
<br><tt>bnez: 252: *****************</tt>
<br><tt>bl8: 11:</tt>
<br><tt>bl24: 82: *****</tt>
<br><tt>bnc8: 52: ***</tt>
<br><tt>bne: 1:</tt>
<br><tt>bra8: 29: *</tt>
<br><tt>bra24: 9:</tt>
<br><tt>cmp: 28: *</tt>
<br><tt>cmpu: 34: **</tt>
<br><tt>cmpui: 2:</tt>
<br><tt>jl: 7:</tt>
<br><tt>jmp: 100: ******</tt>
<br><tt>ld: 93: ******</tt>
<br><tt>ld-d: 277: ******************</tt>
<br><tt>ldb: 77: *****</tt>
<br><tt>ldb-d: 6:</tt>
<br><tt>ldh-d: 38: **</tt>
<br><tt>ldub: 23: *</tt>
<br><tt>lduh-d: 23: *</tt>
<br><tt>ld-plus: 158: **********</tt>
<br><tt>ld24: 55: ***</tt>
<br><tt>ldi8: 163: ***********</tt>
<br><tt>ldi16: 5:</tt>
<br><tt>mv: 282: *******************</tt>
<br><tt>neg: 26: *</tt>
<br><tt>nop: 584: ****************************************</tt>
<br><tt>sll: 3:</tt>
<br><tt>sll3: 7:</tt>
<br><tt>slli: 25: *</tt>
<br><tt>srai: 25: *</tt>
<br><tt>srli: 35: **</tt>
<br><tt>st: 52: ***</tt>
<br><tt>st-d: 195: *************</tt>
<br><tt>stb: 27: *</tt>
<br><tt>stb-d: 4:</tt>
<br><tt>sth: 25: *</tt>
<br><tt>sth-d: 11:</tt>
<br><tt>st-plus: 13:</tt>
<br><tt>st-minus: 164: ***********</tt>
<br><tt>sub: 52: ***</tt>
<br><tt>trap: 2:</tt>
<p><tt>Memory Access Statistics</tt>
<p><tt>Total read: 1891 accesses</tt>
<br><tt>Total write: 491 accesses</tt>
<p><tt>QI read: 83: **</tt>
<br><tt>QI write: 31: *</tt>
<br><tt>HI read: 38: *</tt>
<br><tt>HI write: 36: *</tt>
<br><tt>SI read: 528: *****************</tt>
<br><tt>SI write: 424: **************</tt>
<br><tt>UQI read: 23:</tt>
<br><tt>UHI read: 23:</tt>
<br><tt>USI read: 1196: ****************************************</tt>
<p><tt>Model m32r/d timing information:</tt>
<p><tt>Taken branches: 532</tt>
<br><tt>Untaken branches: 237</tt>
<br><tt>Cycles stalled due to branches: 1064</tt>
<br><tt>Cycles stalled due to loads: 670</tt>
<br><tt>Total cycles (approx): 4946</tt>
<p><tt>Fill nops: 584</tt>
<h3 CLASS="Heading1">
<a NAME="pgfId=1001095"></a><a NAME="_Toc442168569"></a>Overlays for M32R/D
targets</h3>

<div CLASS="Body"><a NAME="pgfId=1001097"></a>Overlays are sections of
code or data, which are to be loaded as part of a single memory image,
but are to be run or used at a common memory address. At run time, an overlay
manager will copy the sections in and out of the runtime memory address.
This approach can be useful, for example, when a certain region of memory
is faster than another section.<a NAME="M32R/D"></a></div>

<div CLASS="Body"><a NAME="pgfId=1001098"></a>See the following documentation
for more details on using overlays for the M32R/D processor.</div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=1001102"></a><a href="m32r.html#_Toc442168570" CLASS="XRef">Sample
runtime overlay manager for M32R/D</a> (below)</li>

<li CLASS="Bullet">
<a NAME="pgfId=1001106"></a><a href="m32r.html#_Toc442168571" CLASS="XRef">Linker
script for overlays for the M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001110"></a><a href="m32r.html#29281" CLASS="XRef">Debugging
the example program for M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001114"></a><a href="m32r.html#_Toc442168572" CLASS="XRef">GDB
overlay support for M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001118"></a><a href="m32r.html#39538" CLASS="XRef">Manual
mode commands for M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001122"></a><a href="m32r.html#41636" CLASS="XRef">Auto
mode commands for M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001126"></a><a href="m32r.html#11134" CLASS="XRef">Debugging
with overlays for M32R/D targets</a></li>

<li CLASS="Bullet">
<a NAME="pgfId=1001130"></a><a href="m32r.html#10106" CLASS="XRef">Breakpoints
for M32R/D targets</a></li>
</ul>

<h4 CLASS="Heading2">
<a NAME="pgfId=1001132"></a><a NAME="_Toc442168570"></a>Sample runtime
overlay manager for M32R/D</h4>

<div CLASS="Body"><a NAME="pgfId=1001133"></a>A simple, portable runtime
overlay manager is provided in the ‘<tt>examples</tt>’ directory. To access
the examples directory, use the following path (‘<i> &lt;yymmdd></i> ’
is replaced with the release date found on the CD).</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001134"></a><tt>/usr/cygnus/m32r-</tt><i>&lt;yymmdd></i><tt>/src/examples</tt></div>

<div CLASS="Body"><a NAME="pgfId=1001135"></a>The sample overlay manager
may be used as is, or as a prototype to develop a third party overlay manager
(or adapt an existing one for use with the GDB debugger). It is intended
to be extremely simple, easy to understand, and not particularly sophisticated.</div>

<div CLASS="Body"><a NAME="pgfId=1001136"></a>The overlay manager has a
single entry point: the ‘<tt>OverlayLoad(ovly_number)</tt>’ function. It
looks up the overlay in a ‘<tt>ovly_table</tt>’ table to find the corresponding
section’s load address and runtime address; then it copies the section
from its load address into its runtime address. ‘<tt>OverlayLoad</tt> ’
must be called before code, or data in an overlay section can be used by
the program. It is up to the programmer to keep track of which overlays
have been loaded. The ‘<i> _ovly_table</i>’ table is built by the linker
from information provided by the programmer in the linker script; see <a href="m32r.html#_Toc442168571" CLASS="XRef">Linker
script for overlays for the M32R/D targets</a> .</div>

<div CLASS="Body"><a NAME="pgfId=1001140"></a>The example program contains
four overlay sections, which are mapped into two runtime regions of memory.
Sections ‘<tt>.ovly0</tt>’ and ‘<tt>.ovly1</tt>’ are both mapped into the
region starting at ‘<tt>0x300000</tt>’, and sections ‘<tt>.ovly2</tt> ’
and ‘<tt>.ovly3</tt>’ are both mapped into the region starting at ‘<tt>
0x380000</tt>’.</div>

<h4 CLASS="Heading2">
<a NAME="pgfId=1001142"></a><a NAME="_Toc442168571"></a>Linker script for
overlays for the M32R/D targets</h4>

<div CLASS="Body"><a NAME="pgfId=1001143"></a>To build a program with overlays
requires a customized linker script. An example program is built with the
‘<tt>m32rtext.ld</tt>’ script, found in the ‘<tt>examples/overlay</tt>
’ directory. It is a modified version of the default linker script, with
two parts added.</div>

<div CLASS="Body"><a NAME="pgfId=1001144"></a>The first added part describes
the overlay sections, and must be located in the ‘<tt>SECTIONS</tt>’ block,
before the ‘<tt>.text</tt>’ and ‘<tt>.data</tt>’ sections. It uses the
‘<tt>OVERLAY</tt>’ linker command, which allows the specification of groups
of sections sharing a common runtime address range.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001145"></a>SECTIONS</div>
{
<br>OVERLAY 0x300000 : AT (0x400000)
<br>{
<br>.ovly0 { foo.o(.text) }
<br>.ovly1 { bar.o(.text) }
<br>}
<br>OVERLAY 0x380000 : AT (0x480000)
<br>{
<br>.ovly2 { baz.o(.text) }
<br>.ovly3 { grbx.o(.text) }
<br>}
<br>[...]

<p CLASS="Body"><a NAME="pgfId=1001146"></a>The ‘<tt>OVERLAY</tt>’ command
has two arguments: first, the base address where all of the overlay sections
link and run; second, the address where the first overlay section loads.
In the example, the ‘<tt>.ovly1</tt>’ section will load at ‘<tt>0x400000
+ SIZEOF(.ovly0)</tt>’. For a full description of the ‘<tt>OVERLAY</tt>
’ linker command, see <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Output_section_type" CLASS="XRef">Output
section type</a> and <a href="../5_ut/b_Usingld/ldLinker_scripts.html#Overlay_description" CLASS="XRef">Overlay
description</a> in <a href="../5_ut/b_Usingld/ld.html#Top"><i>Using </i><tt>ld</tt></a>
in <b><i>GNUPro Utilities</i></b>.

<p CLASS="Body"><a NAME="pgfId=1001153"></a>The ‘<tt>OVERLAY</tt>’ command
is really just a syntactic convenience. For finer control over where the
individual sections will load, use the following example’s syntax

<p CLASS="CodeExample"><a NAME="pgfId=1001154"></a>SECTIONS
<p>{
<br>.ovly0 0x300000 : AT (0x400000) { foo.o(.text) }
<br>.ovly1 0x300000 : AT (0x410000) { bar.o(.text) }
<br>.ovly2 0x380000 : AT (0x420000) { baz.o(.text) }
<br>.ovly3 0x380000 : AT (0x430000) { grbx.o(.text) }
<br>[...]

<p CLASS="Body"><a NAME="pgfId=1001155"></a>The second addition to the
linker script actually builds the ‘<tt>_ovly_table</tt>’ table, which the
sample runtime overlay manager uses. This table has several entries for
each overlay, and must be located somewhere in the ‘<tt>.data</tt> ’ section.

<p CLASS="CodeExample"><a NAME="pgfId=1001156"></a>.data :
<br>{
<br>[...]
<br>_ovly_table = .;
<br>LONG(ABSOLUTE(ADDR(.ovly0)));
<br>LONG(SIZEOF(.ovly0));
<br>LONG(LOADADDR(.ovly0));
<br>LONG(0);
<br>LONG(ABSOLUTE(ADDR(.ovly1)));
<br>LONG(SIZEOF(.ovly1));
<br>LONG(LOADADDR(.ovly1));
<br>LONG(0);
<br>LONG(ABSOLUTE(ADDR(.ovly2)));
<br>LONG(SIZEOF(.ovly2));
<br>LONG(LOADADDR(.ovly2));
<br>LONG(0);
<br>LONG(ABSOLUTE(ADDR(.ovly3)));
<br>LONG(SIZEOF(.ovly3));
<br>LONG(LOADADDR(.ovly3));
<br>LONG(0);
<br>_novlys = .;
<br>LONG((_novlys - _ovly_table) / 16);
<br>[...]
<br>}

<p CLASS="Body"><a NAME="pgfId=1001157"></a>The example program has four
functions; ‘<tt>foo</tt>’, ‘<tt>bar</tt>’, ‘<tt>baz</tt>’, and ‘<tt> grbx</tt>’.
Each is in a separate overlay section. Functions ‘<tt>foo</tt> ’ and ‘<tt>bar</tt>’
are both linked to run at address ‘<tt>0x300000</tt> ’, while functions
‘<tt>baz</tt>’ and ‘<tt>grbx</tt>’ are both linked to run at ‘<tt>0x380000</tt>’.

<p CLASS="Body"><a NAME="pgfId=1001158"></a>The main program calls ‘<tt>
OverlayLoad</tt>’ once before calling each of the overlaid functions, giving
it the overlay number of the respective overlay. The overlay manager, using
the ‘<tt>_ovly_table</tt>’ table that was built up by the linker script,
copies each overlayed function into the appropriate region of memory before
it is called.

<p CLASS="Body"><a NAME="pgfId=1001159"></a>In order to compile and link
the example overlay manager, use the following example’s input.

<p CLASS="CodeExample"><a NAME="pgfId=1001160"></a>m32r-elf-gcc -g -Tm32rdata.ld
-oovlydata maindata.c ovlymgr.c
<h4 CLASS="Heading2">
<a NAME="pgfId=1001162"></a>Debugging the example program for M32R/D targets<a NAME="29281"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001163"></a>Using GDB’s built-in overlay
support, we can debug this program even though several of the functions
share an address range. After loading the program, give GDB the command
‘<tt>overlay auto</tt>’. GDB then detects the actions of the overlay manager
on the target, and can step into overlayed functions, show appropriate
backtraces, etc. If a symbol is in an overlay that is not currently mapped,
GDB will access the symbol from its load address instead of the mapped
runtime address (which would currently be holding something else from another
overlay).</div>

<div CLASS="Body"><a NAME="pgfId=1001164"></a>In the following example,
the ‘<tt>foo</tt>’ and ‘<tt>bar</tt>’ functions are in different overlays
that run at the same address. We will use GDB’s overlay debugging to step
into and debug them.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001165"></a><tt>(gdb)</tt> file
ovlydata</div>

<p><br><tt>Reading symbols from ovlydata...done.</tt>
<p><tt>(gdb)</tt> target sim
<br><tt>Connected to the simulator.</tt>
<p><tt>(gdb)</tt> load
<br><tt>Loading section .ovly0, size 0x28 lma 0x400000</tt>
<br><tt>Loading section .ovly1, size 0x28 lma 0x400028</tt>
<br><tt>Loading section .ovly2, size 0x28 lma 0x480000</tt>
<br><tt>Loading section .ovly3, size 0x28 lma 0x480028</tt>
<br><tt>Loading section .data00, size 0x4 lma 0x440000</tt>
<br><tt>Loading section .data01, size 0x4 lma 0x440004</tt>
<br><tt>Loading section .data02, size 0x4 lma 0x4c0000</tt>
<br><tt>Loading section .data03, size 0x4 lma 0x4c0004</tt>
<br><tt>Loading section .init, size 0x1c lma 0x208000</tt>
<br><tt>Loading section .text, size 0xa3c lma 0x20801c</tt>
<br><tt>Loading section .fini, size 0x14 lma 0x208a58</tt>
<br><tt>Loading section .rodata, size 0x24 lma 0x208a6c</tt>
<br><tt>Loading section .data, size 0x374 lma 0x208ab0</tt>
<br><tt>Loading section .ctors, size 0x8 lma 0x208e24</tt>
<br><tt>Loading section .dtors, size 0x8 lma 0x208e2c</tt>
<br><tt>Start address 0x20801c</tt>
<br><tt>Transfer rate: 30240 bits in &lt;1 sec.</tt>
<p><tt>(gdb)</tt> overlay auto
<p><tt>(gdb)</tt> overlay list
<br><tt>No sections are mapped.</tt>
<p><tt>(gdb)</tt> info address foo
<br><tt>Symbol "foo" is a function at address 0x300000,</tt>
<br><tt>loaded at 0x400000 in overlay section .ovly0.</tt>
<p><tt>(gdb)</tt> info symbol 0x300000
<br><tt>foo in unmapped overlay section .ovly0</tt>
<br><tt>bar in unmapped overlay section .ovly1</tt>
<p><tt>(gdb)</tt> info address bar
<br><tt>Symbol "bar" is a function at address 0x300000,</tt>
<br><tt>loaded at 0x400028 in overlay section .ovly1.</tt>
<p><tt>(gdb)</tt> break main
<br><tt>Breakpoint 1 at 0x20839c: file maindata.c, line 12.</tt>
<br>&nbsp;
<p><tt>(gdb)</tt> run
<br><tt>Starting program: ovlydata</tt>
<br><tt>Breakpoint 1, main () at maindata.c:12</tt>
<br><tt>12 if (!OverlayLoad(0))</tt>
<p><tt>(gdb)</tt> next
<br><tt>14 if (!OverlayLoad(4))</tt>
<p><tt>(gdb)</tt> next
<br><tt>16 a = foo(1);</tt>
<p><tt>(gdb)</tt> overlay list
<br><tt>Section .ovly0, loaded at 00400000 - 00400028, mapped at 00300000
- 00300028</tt>
<br><tt>Section .data00, loaded at 00440000 - 00440004, mapped at 00340000
- 00340004</tt>
<p><tt>(gdb)</tt> info symbol 0x300000
<br><tt>foo in mapped overlay section .ovly0</tt>
<br><tt>bar in unmapped overlay section .ovly1</tt>

<p CLASS="Body"><a NAME="pgfId=1001166"></a>The overlay containing the
‘<tt>foo</tt>’ function is now mapped.

<p CLASS="CodeExample"><a NAME="pgfId=1001167"></a><tt>(gdb)</tt> step
<br><tt>foo (x=1) at foo.c:5</tt>
<br><tt>5 if (x)</tt>
<p><tt>(gdb)</tt> x /i $pc
<br><tt>0x300008 &lt;foo+8>: ld r4, @fp || nop</tt>
<p><tt>(gdb)</tt> print foo
<br><tt>$1 = {int (int)} 0x300000 &lt;foo></tt>
<p><tt>(gdb)</tt> print bar
<br><tt>$2 = {int (int)} 0x400028 &lt;*bar*></tt>

<p CLASS="Body"><a NAME="pgfId=1001168"></a>GDB uses labels such as ‘<tt>
&lt;*bar*></tt>’ (with asterisks) to distinguish overlay load addresses
from the symbol’s runtime address (where it will be when used by the program).

<p CLASS="CodeExample"><a NAME="pgfId=1001169"></a><tt>(gdb)</tt> disassemble
<br><tt>Dump of assembler code for function foo:</tt>
<br><tt>0x300000 &lt;foo>: st fp,@-sp -> addi sp,-4</tt>
<br><tt>0x300004 &lt;foo+4>: mv fp,sp -> st r0,@fp</tt>
<br><tt>0x300008 &lt;foo+8>: ld r4,@fp || nop</tt>
<br><tt>0x30000c &lt;foo+12>: beqz r4,0x30001c &lt;foo+28></tt>
<br><tt>0x300010 &lt;foo+16>: ld24 r4,0x340000 &lt;foox></tt>
<br><tt>0x300014 &lt;foo+20>: ld r5,@r4 -> mv r0,r5</tt>
<br><tt>0x300018 &lt;foo+24>: bra 0x300020 &lt;foo+32> -> bra 0x300020
&lt;foo+32></tt>
<br><tt>0x30001c &lt;foo+28>: ldi r0,0 -> bra 0x300020 &lt;foo+32></tt>
<br><tt>0x300020 &lt;foo+32>: add3 sp,sp,4</tt>
<br><tt>0x300024 &lt;foo+36>: ld fp,@sp+ -> jmp lr</tt>
<br><tt>End of assembler dump.</tt>
<p><tt>(gdb)</tt> disassemble bar
<br><tt>Dump of assembler code for function bar:</tt>
<br><tt>0x400028 &lt;*bar*>: st fp,@-sp -> addi sp,-4</tt>
<br><tt>0x40002c &lt;*bar+4*>: mv fp,sp -> st r0,@fp</tt>
<br><tt>0x400030 &lt;*bar+8*>: ld r4,@fp || nop</tt>
<br><tt>0x400034 &lt;*bar+12*>: beqz r4,0x400044 &lt;*bar+28*></tt>
<br><tt>0x400038 &lt;*bar+16*>: ld24 r4,0x340000 &lt;foox></tt>
<br><tt>0x40003c &lt;*bar+20*>: ld r5,@r4 -> mv r0,r5</tt>
<br><tt>0x400040 &lt;*bar+24*>: bra 0x400048 &lt;*bar+32*> -> bra 0x400048
&lt;*bar+32*></tt>
<br><tt>0x400044 &lt;*bar+28*>: ldi r0,0 -> bra 0x400048 &lt;*bar+32*></tt>
<br><tt>0x400048 &lt;*bar+32*>: add3 sp,sp,4</tt>
<br><tt>0x40004c &lt;*bar+36*>: ld fp,@sp+ -> jmp lr</tt>
<br><tt>End of assembler dump.</tt>

<p CLASS="Body"><a NAME="pgfId=1001170"></a>Since the overlay containing
‘<tt>bar</tt>’ is not currently mapped, GDB finds ‘<tt>bar</tt>’ at its
load address, and disassembles it there.

<p CLASS="CodeExample"><a NAME="pgfId=1001171"></a><tt>(gdb)</tt> finish
<br><tt>Run till exit from #0 foo (x=1) at foo.c:5</tt>
<br><tt>0x2083cc in main () at maindata.c:16</tt>
<br><tt>16a = foo(1);</tt>
<br><tt>Value returned is $3 = 324</tt>
<p><tt>(gdb)</tt> next
<br><tt>17if (!OverlayLoad(1))</tt>
<p><tt>(gdb)</tt> next
<br><tt>19if (!OverlayLoad(5))</tt>
<p><tt>(gdb)</tt> next
<br><tt>21b = bar(1);</tt>
<p><tt>(gdb)</tt> overlay list
<br><tt>Section .ovly1, loaded at 00400028 - 00400050, mapped at 00300000
- 00300028</tt>
<br><tt>Section .data01, loaded at 00440004 - 00440008, mapped at 00340000
- 00340004</tt>
<p><tt>(gdb)</tt> info symbol 0x300000
<br><tt>foo in unmapped overlay section .ovly0</tt>
<br><tt>bar in mapped overlay section .ovly1</tt>
<p><tt>(gdb)</tt> step
<br><tt>bar (x=1) at bar.c:5</tt>
<br><tt>5 if (x)</tt>
<p><tt>(gdb)</tt> x /i $pc
<br><tt>0x300008 &lt;bar+8>: ld r4,@fp || nop</tt>

<p CLASS="Body"><a NAME="pgfId=1001172"></a>Now ‘<tt>bar</tt>’ is mapped,
and ‘<tt>foo</tt>’ is not. Even though the PC is at the same address as
before, GDB recognizes that we are in ‘<tt>bar</tt>’ rather than ‘<tt>
foo</tt>’.

<p CLASS="CodeExample"><a NAME="pgfId=1001173"></a><tt>(gdb)</tt> disassemble
<br><tt>Dump of assembler code for function bar:</tt>
<br><tt>0x300000 &lt;bar>: st fp,@-sp -> addi sp,-4</tt>
<br><tt>0x300004 &lt;bar+4>: mv fp,sp -> st r0,@fp</tt>
<br><tt>0x300008 &lt;bar+8>: ld r4,@fp || nop</tt>
<br><tt>0x30000c &lt;bar+12>: beqz r4,0x30001c &lt;bar+28></tt>
<br><tt>0x300010 &lt;bar+16>: ld24 r4,0x340000 &lt;barx></tt>
<br><tt>0x300014 &lt;bar+20>: ld r5,@r4 -> mv r0,r5</tt>
<br><tt>0x300018 &lt;bar+24>: bra 0x300020 &lt;bar+32> -> bra 0x300020
&lt;bar+32></tt>
<br><tt>0x30001c &lt;bar+28>: ldi r0,0 -> bra 0x300020 &lt;bar+32></tt>
<br><tt>0x300020 &lt;bar+32>: add3 sp,sp,4</tt>
<br><tt>0x300024 &lt;bar+36>: ld fp,@sp+ -> jmp lr</tt>
<br><tt>End of assembler dump.</tt>
<p><tt>(gdb)</tt> finish
<br><tt>Run till exit from #0 bar (x=1) at bar.c:5</tt>
<br><tt>0x208400 in main () at maindata.c:21</tt>
<br><tt>21b = bar(1);</tt>
<br><tt>Value returned is $4 = 309</tt>

<p CLASS="Body"><a NAME="pgfId=1001174"></a>The ‘<tt>bazx</tt>’ and ‘<tt>
grbxx</tt>’ variables are now both mapped to the same runtime address.
With the automatic overlay debugging mode, GDB always knows which variable
is using an address.

<p CLASS="CodeExample"><a NAME="pgfId=1001175"></a><tt>(gdb)</tt> info
addr bazx
<br><tt>Symbol "bazx" is static storage at address 0x3c0000,</tt>
<br><tt>loaded at 0x4c0000 in overlay section .data02.</tt>
<p><tt>(gdb)</tt> info sym 0x3c0000
<br><tt>bazx in unmapped overlay section .data02</tt>
<br><tt>grbxx in unmapped overlay section .data03</tt>
<p><tt>(gdb)</tt> info addr grbxx
<br><tt>Symbol "grbxx" is static storage at address 0x3c0000,</tt>
<br><tt>loaded at 0x4c0004 in overlay section .data03.</tt>
<p><tt>(gdb)</tt> break baz
<br><tt>Breakpoint 2 at 0x380008: file baz.c, line 5.</tt>
<p><tt>(gdb)</tt> break grbx
<br><tt>Breakpoint 3 at 0x380008: file grbx.c, line 5.</tt>

<p CLASS="Body"><a NAME="pgfId=1001176"></a>The two breakpoints are actually
set at the same address, yet GDB will correctly distinguish between them
when it hits them. If only one overlay function has a breakpoint on it,
GDB will not stop at that address in other overlay functions.

<p CLASS="CodeExample"><a NAME="pgfId=1001177"></a><tt>(gdb)</tt> cont
<br><tt>Continuing.</tt>
<p><tt>Breakpoint 2, baz (x=1) at baz.c:5</tt>
<br><tt>5 if (x)</tt>
<p><tt>(gdb)</tt> print &amp;bazx
<br><tt>$5 = (int *) 0x3c0000</tt>
<p><tt>(gdb)</tt> x /d &amp;bazx
<br><tt>0x3c0000 &lt;bazx>: 317</tt>
<p><tt>(gdb)</tt> print &amp;grbxx
<br><tt>$6 = (int *) 0x4c0004</tt>
<p><tt>(gdb)</tt> cont
<br><tt>Continuing.</tt>
<p><tt>Breakpoint 3, grbx (x=1) at grbx.c:5</tt>
<br><tt>5 if (x)</tt>
<p><tt>(gdb)</tt> print &amp;grbxx
<br><tt>$7 = (int *) 0x3c0000</tt>
<p><tt>(gdb)</tt> x /d &amp;grbxx
<br><tt>0x3c0000 &lt;grbxx>: 435</tt>
<p><tt>(gdb)</tt> print &amp;bazx
<br><tt>$7 = (int *) 0x4c0000</tt>
<p><tt>(gdb)</tt> x /d &amp;bazx
<br><tt>0x4c0000 &lt;*bazx*>: 317</tt>
<h4 CLASS="Heading2">
<a NAME="pgfId=1001179"></a><a NAME="_Toc442168572"></a>GDB overlay support
for M32R/D targets</h4>

<div CLASS="Body"><a NAME="pgfId=1001180"></a>GDB provides special functionality
for debugging a program that is linked using the overlay mechanism of <tt>ld</tt>
, the GNU linker. In such programs, an overlay corresponds to a section
with a load address that is different from its runtime address. GDB can
provide ‘<tt>manual</tt>’ overlay debugging for any program linked in such
a way (providing that the overlays all reside somewhere in memory). Automatic
overlay debugging is also provided.</div>

<h4 CLASS="Heading2">
<a NAME="pgfId=1001182"></a>Manual mode commands for M32R/D targets<a NAME="39538"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001183"></a>The following commands are
for manual mode for the overlay manager.</div>

<div CLASS="BodyHang1"><a NAME="pgfId=1001184"></a><tt>overlay manual</tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001185"></a><tt>overlay map
</tt><i>&lt;section-name></i></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001186"></a><tt>overlay unmap
</tt><i>&lt;section-name></i></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001187"></a><tt>overlay list</tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001188"></a><tt>overlay off</tt></div>

<p><br>The manual mode requires input from the user to specify what overlays
are mapped into their runtime address regions at any given time. The ‘<tt>
overlay map</tt>’ command informs GDB that the overlay has been mapped
by the target into its shared runtime address range. The ‘<tt>overlay unmap</tt>’
command informs GDB that the overlay is no longer resident in its runtime
address region, and must be accessed from the load-time address region.
If two overlays share the same runtime address region, then mapping one
implies unmapping the other.
<h4 CLASS="Heading2">
<a NAME="pgfId=1001190"></a>Auto mode commands for M32R/D targets<a NAME="41636"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001192"></a>The following commands are
for&nbsp;<a NAME="automatic mode for the overlay"></a>automatic mode for
the overlay manager.</div>

<div CLASS="BodyHang1"><a NAME="pgfId=1001193"></a><tt>overlay auto</tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001194"></a><tt>overlay list</tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=1001195"></a><tt>overlay off</tt></div>

<p><br>Automatic overlay debugging support in GDB works with the runtime
overlay manager provided in the ‘<tt>examples</tt>’ directory.

<p CLASS="BodyListFollow"><a NAME="pgfId=1001196"></a>When this mode is
activated, GDB will automatically read and interpret the data structures
maintained in target memory by the overlay manager. To learn what overlays
are mapped at any time, use the ‘<tt>overlay list</tt>’ command.

<p CLASS="BodyListFollow"><a NAME="pgfId=1001197"></a>Whenever the target
program is allowed to run (by the ‘<tt>step</tt>’ command), GDB will refresh
its overlay map by reading from the target’s overlay tables.

<p CLASS="BodyListFollow"><a NAME="pgfId=1001198"></a>The automatic mapping
may be temporarily overridden by the ‘<tt>overlay map</tt>’ and ‘<tt> overlay
unmap</tt>’ commands, but these mappings will last only until the next
time the target is allowed to run. To explicitly take control of GDB’s
overlay mapping, switch to the ‘<tt>overlay manual</tt>’ mode.
<h4 CLASS="Heading2">
<a NAME="pgfId=1001200"></a>Debugging with overlays for M32R/D targets<a NAME="11134"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001201"></a>When GDB’s overlay support
(either manual or auto) is active, GDB’s concept of a symbol’s address
is controlled by which overlays are mapped into which memory regions. For
instance, if you ‘<tt>print</tt>’ a variable that is in an overlay which
is currently mapped (located in its runtime address region) GDB will fetch
the variable’s memory from the runtime address. If the variable’s overlay
is currently not mapped, GDB will fetch it from its load-time address.</div>

<div CLASS="Body"><a NAME="pgfId=1001202"></a>Similarly, if you disassemble
a function that is in an unmapped overlay, or use a symbol’s address to
examine memory, GDB will fetch the memory from the symbol’s load-time address
range instead of the runtime range. If GDB’s output contains labels that
are relative to an overlay’s load-time address instead of the runtime address,
the labels will be distinguished like the following example’s input shows.</div>

<div CLASS="CodeExample"><a NAME="pgfId=1001203"></a><tt>(gdb)</tt> overlay
map .ovly0</div>
<tt>(gdb)</tt> x /x foo
<br><tt>0x300000 &lt;foo>: 0x2d7f4ffc</tt>
<p><tt>(gdb)</tt> overlay unmap .ovly0
<p><tt>(gdb)</tt> x /x foo
<br><tt>0x400000 &lt;*foo*>: 0x2d7f4ffc</tt>

<p CLASS="Body"><a NAME="pgfId=1001204"></a>The asterisks (<tt>*</tt> )
around the ‘<tt>foo</tt>’ label may be interpreted as meaning that this
is where ‘<tt>foo</tt>’ is, but not where it will be when it is in use
by the target program.

<p CLASS="Body"><a NAME="pgfId=1001205"></a>The ‘<tt>INFO ADDRESS</tt>
’ command can tell you what overlay a symbol is in, as well as where it
is loaded and mapped. The ‘<tt>INFO SYMBOL</tt>’ command can list all of
the symbols that are mapped to an address.

<p CLASS="CodeExample"><a NAME="pgfId=1001206"></a><tt>(gdb)</tt> info
addr foo
<br><tt>Symbol "foo" is a function at address 0x300000,</tt>
<br><tt>-- loaded at 0x400000 in overlay section .ovly0.</tt>
<p><tt>(gdb)</tt> info symbol 0x300000
<br><tt>foo in mapped overlay section .ovly0</tt>
<br><tt>bar in unmapped overlay section .ovly1</tt>
<h4 CLASS="Heading2">
<a NAME="pgfId=1001208"></a>Breakpoints for M32R/D targets<a NAME="10106"></a></h4>

<div CLASS="Body"><a NAME="pgfId=1001209"></a>So long as the overlay sections
are located in RAM rather than ROM, GDB can set breakpoints in them. The
breakpoints work by inserting trap instructions into the load-time address
region. When the overlay is mapped into the runtime region, the trap instructions
are mapped along with it, and when executed, cause the target program to
break out to the debugger. If the overlay regions are in ROM, you can only
set breakpoints in them after they have been mapped into the runtime region
in RAM.</div>

<div CLASS="Body"><a NAME="pgfId=997347"></a>
<br>
<hr SIZE=5 WIDTH="100%">
<center><a href="#Top">Top</a>|<a href="emb.html">Contents</a>|<a href="embindex.html">Index</a>|<a href="embD10V.html">Previous</a>|<a href="embMotorola_m68k_targets.html#Top">Next</a></center>
</div>

</body>
</html>
