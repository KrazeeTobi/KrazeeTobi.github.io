<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (Win95; I) [Netscape]">
   <title> LSI TinyRisc development</title>
</head>
<body bgcolor="#FFFFFF">

<div CLASS="ChapterTitle"><a NAME="Top"></a><a NAME="31562"></a><a href="emb.html">Contents</a>|<a href="embindex.html">Index</a>|<a href="emb08.html">Previous</a>|<a href="emb10.html#Top">Next</a>
<br><font face="Futura Md BT"><font size=+3>LSI TinyRisc development</font></font></div>

<hr SIZE=5 WIDTH="100%">
<div CLASS="BodyAfterHead"><a NAME="pgfId=461665"></a><font size=+1>The
following documentation describes information pertinent only to LSI TinyRISC
processors using GNUPro Toolkit software.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=461874"></a><font size=+1><a href="#14810" CLASS="XRef">Compiler
features for LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=461875"></a><font size=+1><a href="#25416" CLASS="XRef">ABI
summary for LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=461876"></a><font size=+1><a href="#35892" CLASS="XRef">Assembler
features for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=461877"></a><font size=+1><a href="#29067" CLASS="XRef">Linker
features for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=461878"></a><font size=+1><a href="#37616" CLASS="XRef">Debugger
features for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=461879"></a><font size=+1><a href="#16138" CLASS="XRef">Stand-alone
simulator issues for LSI TinyRISC</a></font></li>
</ul>

<h3 CLASS="Heading1">
<a NAME="pgfId=461891"></a><a NAME="14810"></a><b><i><font size=+2>Compiler
features for LSI TinyRISC</font></i></b><a NAME="marker=464540"></a></h3>

<div CLASS="Body"><a NAME="pgfId=462475"></a><font size=+1>The following
features for the GNUPro compiler have support for the LSI TinyRISC processor.</font></div>

<div CLASS="Body"><a NAME="pgfId=462685"></a><font size=+1>The following
MIPS16-specific command-line options are supported. For a list of all the
available generic compiler options, see <a href="../2_comp/Using_GNU_CC/gccGNU_CC_Command_Options.html">GNU
CC command options</a> in <i><a href="../2_comp/Using_GNU_CC/gcc.html">Using
GNU CC</a></i> in <b><i>GNUPro Compiler Tools</i></b>.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=461897"></a><tt><font size=+1>-mips16</font></tt></div>

<blockquote><font size=+1>Compile code for the processor in mips16 mode.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=461898"></a><tt><font size=+1>-mentry</font></tt></div>

<blockquote><font size=+1>The <tt>-mentry</tt> option tells the compiler
to use the entry and exit pseudo-instructions for function entry and exit.
The pseudo-instructions save and restore registers at function entry and
exit. These work by triggering an unimplemented instruction trap. Your
exception handler must handle these instructions correctly. This is a time/space
tradeoff; code using the entry and exit instructions is smaller, but takes
longer to execute.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=461899"></a><tt><font size=+1>-EB</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=461900"></a><tt><font size=+1>-EL</font></tt></div>

<blockquote><font size=+1>Any MIPS configuration of the compiler can select
big-endian or little-endian output at run time. Use <tt>-EB</tt> to select
big-endian output and <tt>-EL</tt> for little-endian. If neither <tt>-EL</tt>
nor <tt>-EB</tt> are defined, big-endian is the default.</font></blockquote>

<div CLASS="Body"><a NAME="pgfId=461961"></a><font size=+1>See <a href="emb09.html#15416" CLASS="XRef">Preprocessor
symbols</a> for the preprocessor symbols and the compiler options that
define them.</font></div>

<div CLASS="TableTitle"><a NAME="pgfId=462665"></a><a NAME="15416"></a><b><i><font size=+1>Preprocessor
symbols</font></i></b></div>

<table BORDER >
<tr BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=461910"></a><b><i><font size=+1>Symbol</font></i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=461912"></a><b><i><font size=+1>Compiler
options that define symbol</font></i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461914"></a><tt><font size=+1>_mips16</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461916"></a><font size=+1>Only if
<tt>-mips16</tt>
is used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461918"></a><tt><font size=+1>mips</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461920"></a><font size=+1>Only if
<tt>-ansi</tt>
not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461922"></a><tt><font size=+1>_mips</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461924"></a><font size=+1>Only if
<tt>-ansi</tt>
not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461926"></a><tt><font size=+1>_ _mips</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461928"></a><font size=+1>Always defined</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461930"></a><tt><font size=+1>MIPSEB</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461932"></a><font size=+1>Only if
<tt>-ansi</tt>
and <tt>-EL</tt> are not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461934"></a><tt><font size=+1>_MIPSEB</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461936"></a><font size=+1>Only if
<tt>-EL</tt>
is not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461938"></a><tt><font size=+1>_ _MIPSEB</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461940"></a><font size=+1>Only if
<tt>-EL</tt>
is not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461942"></a><tt><font size=+1>_ _MIPSEB_
_</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461944"></a><font size=+1>Only if
<tt>-EL</tt>
is not used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461946"></a><tt><font size=+1>MIPSEL</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461948"></a><font size=+1>Only if
<tt>-ansi</tt>
is not used and <tt>-EL</tt> is used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461950"></a><tt><font size=+1>_MIPSEL</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461952"></a><font size=+1>only if
<tt>-EL</tt>
is used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461954"></a><tt><font size=+1>__MIPSEL</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461956"></a><font size=+1>only if
<tt>-EL</tt>
is used</font></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461958"></a><tt><font size=+1>__MIPSEL__</font></tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461960"></a><font size=+1>only if
<tt>-EL</tt>
is used</font></div>
</td>
</tr>
</table>

<h3 CLASS="Heading1">
<a NAME="pgfId=461966"></a><a NAME="25416"></a><i><font size=+2>ABI summary
for LSI TinyRISC</font></i></h3>

<div CLASS="Body"><a NAME="pgfId=462700"></a>T<font size=+1>he following
documentation details the Application Binary Interface (ABI) for the&nbsp;<a NAME="marker=464541"></a>LSI
TinyRISC processor.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=464285"></a><font size=+1><a href="emb09.html#32246" CLASS="XRef">Data
type sizes and alignments for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=464290"></a><font size=+1><a href="emb09.html#32246" CLASS="XRef">Register
allocation definitions for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=464295"></a><font size=+1><a href="emb09.html#10460" CLASS="XRef">Stack
frame features for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=464305"></a><font size=+1><a href="emb09.html#32246" CLASS="XRef">Calling
conventions</a><a href="emb09.html#18190" CLASS="XRef"> for LSI TinyRISC</a></font></li>
</ul>

<h4 CLASS="Heading2">
<a NAME="pgfId=461972"></a><i><font size=+2>Data type sizes and alignments
for the LSI TinyRISC</font></i><a NAME="32246"></a></h4>

<div CLASS="Body"><a NAME="pgfId=464276"></a><font size=+1>The following
information defines the data type sizes and alignments. The stack is aligned
on eight-byte boundaries.</font><a NAME="marker=464542"></a></div>

<br>&nbsp;
<table BORDER >
<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462792"></a><tt>char</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462794"></a>1 byte</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462796"></a><tt>short</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462798"></a>2 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462800"></a><tt>int</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462802"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462804"></a><tt>long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462806"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462808"></a><tt>long long</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462810"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462812"></a><tt>float</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462814"></a>4 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462816"></a><tt>double</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462818"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462820"></a><tt>long double</tt></div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462822"></a>8 bytes</div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462824"></a>pointer</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462826"></a>4 bytes</div>
</td>
</tr>
</table>

<h4 CLASS="Heading2">
<a NAME="pgfId=462017"></a><a NAME="13815"></a><i><font size=+2>Register
allocation definitions for the LSI TinyRISC</font></i></h4>

<div CLASS="Body"><a NAME="pgfId=464259"></a><a NAME="marker=464543"></a><font size=+1>See
<a href="emb09.html#37057" CLASS="XRef">Register
allocation definitions</a>.</font></div>

<h6 CLASS="TableTitle">
<a NAME="pgfId=462854"></a><a NAME="37057"></a><i><font size=+1>Register
allocation definitions</font></i></h6>

<table BORDER >
<tr BGCOLOR="#C0C0C0">
<td>
<div CLASS="CellHeading"><a NAME="pgfId=461978"></a><b><i><font size=+1>General
purpose (integer) register</font></i></b></div>
</td>

<td>
<div CLASS="CellHeading"><a NAME="pgfId=461980"></a><b><i><font size=+1>Usage</font></i></b></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461982"></a>Constant zero</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461984"></a><tt>$0</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461986"></a>Volatile</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461988"></a><tt>$1</tt> through <tt>$15</tt>
, <tt>$24</tt> , <tt>$25</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461990"></a>Saved</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461992"></a><tt>$16</tt> through <tt>$23</tt>
, <tt>$30</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461994"></a>Parameters</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=461996"></a><tt>$4</tt> through <tt>$7</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=461998"></a>Kernel reserved</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462000"></a><tt>$26</tt> , <tt>$27</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462002"></a>Global pointer</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462004"></a><tt>$28</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462006"></a>Stack pointer</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462008"></a><tt>$29</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462010"></a>Frame pointer</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462012"></a><tt>$30</tt></div>
</td>
</tr>

<tr>
<td>
<div CLASS="CellBody"><a NAME="pgfId=462014"></a>Return address</div>
</td>

<td>
<div CLASS="CellBody"><a NAME="pgfId=462016"></a><tt>$31</tt></div>
</td>
</tr>
</table>

<blockquote>
<div CLASS="Label"><a NAME="pgfId=462018"></a><font size=+1>Note:</font></div>

<div CLASS="Note"><a NAME="pgfId=463001"></a><font size=+1>Do not depend
on the order of the registers shown in <a href="emb09.html#37057" CLASS="XRef">Register
allocation definitions</a>. Instead, use GCC’s <tt>asm( )</tt> extension
and allow the compiler to schedule registers.</font></div>
</blockquote>

<h4 CLASS="Heading2">
<a NAME="pgfId=462023"></a><i><font size=+2>Stack frame features for the
LSI TinyRISC</font></i><a NAME="10460"></a><a NAME="marker=464544"></a></h4>

<div CLASS="Body"><a NAME="pgfId=462024"></a><font size=+1>The following
specific issues for the stack frame have support for the LSI TinrRISC processor.
See also <a href="emb09.html#32285" CLASS="XRef">Stack frame for LSI TinyRISC</a>
(below).</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=462025"></a><font size=+1>The stack grows downwards from
high addresses to low addresses.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=462026"></a><font size=+1>A leaf function need not allocate
a stack frame if it does not need one.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=462027"></a><font size=+1>A frame pointer need not be allocated.</font></li>

<li CLASS="Bullet">
<a NAME="pgfId=462028"></a><font size=+1>The stack pointer shall always
be aligned to 8 byte boundaries.</font></li>
</ul>

<h6 CLASS="FigureTitle">
<a NAME="pgfId=464025"></a><a NAME="32285"></a><b><i><font size=+1>Stack
frame for LSI TinyRISC</font></i></b></h6>

<ol><map NAME="emb09-2"></map><img SRC="emb0-2.gif" BORDER=3 USEMAP="#emb0-2" height=381 width=379></ol>

<h4 CLASS="Heading2">
<a NAME="pgfId=464171"></a><a NAME="18190"></a><b><i><font size=+2>Calling
conventions for LSI TinyRISC</font></i></b></h4>

<div CLASS="Body"><a NAME="pgfId=463055"></a><font size=+1>The following
documentation defines the&nbsp;<a NAME="marker=464545"></a>calling conventions
for the LSI TinyRISC processor.</font></div>

<ul TYPE=SQUARE>
<li CLASS="Bullet">
<a NAME="pgfId=463548"></a><font size=+1><a href="emb09.html#36908" CLASS="XRef">Argument
passing for the LSI TinyRISC</a></font></li>

<li CLASS="Bullet">
<a NAME="pgfId=463554"></a><font size=+1><a href="emb09.html#15421" CLASS="XRef">Function
return values for the LSI TinyRISC</a></font></li>
</ul>

<h5 CLASS="Heading3">
<a NAME="pgfId=462036"></a><a NAME="36908"></a><b><i><font size=+2>Argument
passing for the&nbsp;<a NAME="marker=464546"></a>LSI TinyRISC</font></i></b></h5>

<div CLASS="Body"><a NAME="pgfId=462037"></a><font size=+1>When compiling
in mips16 mode, the floating point registers are not available. A function
compiled in mips16 mode expects floating point arguments in the general
registers, and it returns a floating point value in the general registers.
The compiler and the linker cooperate to make this happen transparently
when a function compiled in mips16 mode calls a function compiled in mips32
mode, or vice-versa. If you write your own assembly language code, and
plan to call between mips16 code and mips32 code, you must arrange for
the function arguments and return values to be in the right place for both
the caller and the callee.</font></div>

<div CLASS="Body"><a NAME="pgfId=462039"></a><font size=+1>On the mips16,
floating point values are returned as though they were integer values.
A single precision floating point value is returned in general register
`<tt> $2</tt>'. A double precision floating point value is returned in
general registers `<tt>$2</tt>' and `<tt>$3</tt>'.</font></div>

<div CLASS="Body"><a NAME="pgfId=462041"></a><font size=+1>The compiler
passes arguments to a function using a combination of integer general registers,
and the stack. The number, type, and relative position of arguments in
the calling functions argument list define the combination of registers
and memory used. The general registers `<tt>$4..$7</tt>' pass the first
few arguments.</font></div>

<div CLASS="Body"><a NAME="pgfId=462042"></a><font size=+1>If the function
being called returns a structure or union, the calling function passes
the address of an area large enough to hold the structure to the function
in `<tt>$4</tt>'. The function being called copies the returned structure
into this area before returning. The address in `<tt>$4</tt>' becomes the
first argument to the function for the purpose of argument register allocation.
All user arguments are then shifted down by one.</font></div>


<p CLASS="Body"><a NAME="pgfId=462043"></a><font size=+1>The compiler always
allocates space on the stack for all arguments even when some or all of
the arguments to a function are passed in registers. This stack space is
a large enough structure to contain all the arguments. After promotion
and structure return pointer insertion, the arguments are aligned according
to normal structure rules. Locations used for arguments within the stack
frame are referred to as the home locations. Whenever possible, arguments
declared in variable argument lists, as with those defined using a `<tt>va_list</tt>'
declaration, are passed in the integer registers, even when they are floating-point
numbers.</font>

<p CLASS="Body"><a NAME="pgfId=462045"></a><font size=+1>If the first argument
is an integer, remaining arguments are passed in the integer registers.</font>

<p CLASS="Body"><a NAME="pgfId=462046"></a><font size=+1>The compiler passes
structures and unions as if they were very wide integers with their size
rounded up to an integral number of words. The "fill bits" necessary for
rounding up are undefined. A structure can be split so that a portion is
passed in registers and the remainder passed on the stack. In this case,
the first words are passed in `<tt>$4</tt>', `<tt>$5</tt>', `<tt>$6</tt>',
and `<tt>$7</tt>' as needed, with additional words passed on the stack.</font>

<p CLASS="Body"><a NAME="pgfId=462047"></a><font size=+1>The rules for
assigning which arguments go into registers and which arguments must be
passed on the stack can be explained by considering the list of arguments
itself as a structure, aligned according to normal structure rules. Mapping
of this structure into the combination of registers and stack is as follows;
everything with a structure offset greater than or equal to 32 is passed
on the stack. The remainder of the arguments are passed in `<tt>$4..$7</tt>'
based on their structure offset. Any holes left in the structure for alignment
are unused, whether in registers or on the stack.</font>
<h5 CLASS="Heading3">
<a NAME="pgfId=462048"></a><b><i><font size=+2>Function return values for
the LSI TinyRISC</font></i></b><a NAME="15421"></a><a NAME="marker=464548"></a></h5>

<div CLASS="Body"><a NAME="pgfId=462049"></a><font size=+1>A function can
return no value, an integral or pointer value, a floating-point value (single
or double precision), or a structure; unions are treated the same as structures.</font></div>

<div CLASS="Body"><a NAME="pgfId=462050"></a><font size=+1>A function that
returns no value puts no particular value in any register.</font></div>

<div CLASS="Body"><a NAME="pgfId=462051"></a><font size=+1>A function that
returns an integral or pointer value places its result in register `<tt>$2</tt>'.</font></div>

<div CLASS="Body"><a NAME="pgfId=462052"></a><font size=+1>A function that
returns a floating-point value places its result in general register `<tt>$2</tt>'.</font></div>


<p CLASS="Body"><a NAME="pgfId=462053"></a><font size=+1>The caller to
a function that returns a structure or a union passes the address of an
area large enough to hold the structure in register `<tt>$4</tt>'. The
function returns a pointer to the returned structure in register `<tt>$2</tt>'.</font>
<h3 CLASS="Heading1">
<a NAME="pgfId=462056"></a><a NAME="35892"></a><b><i><font size=+2>Assembler
features for the LSI TinyRISC</font></i></b><a NAME="marker=464547"></a></h3>

<div CLASS="Body"><a NAME="pgfId=462059"></a><font size=+1>The following
documentation defines the specific assembler options for the LSI TinyRISC
processor. For a list of available generic assembler options, see <a href="../5_ut/a_Using_AS/asCommandLine_Options.html" CLASS="XRef">Command-line
options</a> in <i>Using</i> <tt>as </tt>in <b><i>GNUPro Utilities</i></b>.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=462060"></a><tt><font size=+1>-mips16</font></tt></div>

<blockquote><font size=+1>Assemble code for the processor in mips16 mode.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=462061"></a><tt><font size=+1>-EB</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=462062"></a><tt><font size=+1>-EL</font></tt></div>

<blockquote><font size=+1>Any MIPS configuration of the assembler can select
big-endian or little-endian output at run time.</font>
<p><a NAME="pgfId=463606"></a><font size=+1>Use `<tt>-EB</tt>' to select
big-endian output, and `<tt>-EL</tt>' for little-endian. The default is
big-endian.</font>
<p><a NAME="pgfId=463625"></a><font size=+1>For information about the MIPS
instruction set, see <b><i>MIPS RISC Architecture </i></b>(Kane and Heindrich,
Prentice-Hall). For an overview of MIPS assembly conventions, see "<i>Appendix
D: Assembly Language Programming</i>" in the same volume.</font>
<p><a NAME="pgfId=462071"></a><font size=+1>There are 32 64-bit general
(integer) registers, named `<tt>$0..$31</tt>'. There are 32 64-bit floating
point registers, named `<tt>$f0..$f31</tt>'.</font></blockquote>

<div CLASS="Body"><a NAME="pgfId=462074"></a><font size=+1>For assembler
mnemonics, see <b><i>MIPS16 ASE Reference Manual</i></b>.</font></div>

<h3 CLASS="Heading1">
<a NAME="pgfId=462077"></a><a NAME="29067"></a><i><font size=+2>Linker
features for the LSI TinyRISC</font></i><a NAME="marker=464549"></a></h3>

<div CLASS="Body"><a NAME="pgfId=462080"></a><font size=+1>For a list of
available generic linker options, see <a href="../5_ut/b_Usingld/ldLinker_scripts.html" CLASS="XRef">Linker
scripts</a> in <i>Using</i> <tt>ld </tt>in <b><i>GNUPro Utilities</i></b>.
In addition, the following MIPS-specific command-line options have support.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=462081"></a><tt><font size=+1>-EL</font></tt></div>

<blockquote><font size=+1>Link objects for the processor in little endian
mode.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=462082"></a><tt><font size=+1>-EB</font></tt></div>

<blockquote><font size=+1>Link objects for the processor in big-endian
mode.</font></blockquote>

<h4 CLASS="Heading2">
<a NAME="pgfId=462084"></a><b><i><font size=+2>Linker script for LSI TinyRISC</font></i></b></h4>

<div CLASS="Body"><a NAME="pgfId=462085"></a><font size=+1>The GNU linker
uses a linker script to determine how to process each section in an object
file, and how to lay out the executable. The linker script is a declarative
program consisting of a number of directives. For instance, the directive
`<tt>ENTRY( )</tt>' specifies which symbol in the executable is designated
the executable’s <i>entry point</i>. Since linker scripts can be complicated
to write, the linker includes one built-in script that defines the default
linking process.</font></div>

<div CLASS="Body"><a NAME="pgfId=462086"></a><font size=+1>Use the following
linker script (`<tt>lsi.ld</tt>') when linking programs for the TinyRISC
board. Also, use it to link programs for execution in the MIPS simulator.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=462087"></a><font size=+1>/* The following TEXT start address leaves space for the monitor</font></pre>

<pre><font size=+1>workspace. */</font></pre>

<pre><font size=+1>ENTRY(_start)</font></pre>

<pre><font size=+1>OUTPUT_ARCH("mips:4000")</font></pre>

<pre><font size=+1>OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-littlemips")</font></pre>

<pre><font size=+1>GROUP(-lc -llsi -lgcc)</font></pre>

<pre><font size=+1>SEARCH_DIR(.)</font></pre>

<pre><font size=+1>__DYNAMIC = 0;</font></pre>

<pre><font size=+1>/*</font></pre>

<pre><font size=+1>* Allocate the stack to be at the top of memory, since the</font></pre>

<pre><font size=+1>* stack grows down</font></pre>

<pre><font size=+1>*/</font></pre>

<pre><font size=+1>PROVIDE (__stack = 0);</font></pre>

<pre><font size=+1>/* PROVIDE (__global = 0); */</font></pre>

<pre><font size=+1>/*</font></pre>

<pre><font size=+1>* Initalize some symbols to be zero so we can reference them</font></pre>

<pre><font size=+1>* in the crt0 without core dumping. These functions are all</font></pre>

<pre><font size=+1>* optional, but we do this so we can have our crt0 always use</font></pre>

<pre><font size=+1>* them if they exist. This is so BSPs work better when using</font></pre>

<pre><font size=+1>* the crt0 installed with gcc. We must initalize them twice,</font></pre>

<pre><font size=+1>* so we multiple object file formats, as some prepend an</font></pre>

<pre><font size=+1>* underscore. */</font></pre>

<pre><font size=+1>PROVIDE (hardware_init_hook = 0);</font></pre>

<pre><font size=+1>PROVIDE (software_init_hook = 0);</font></pre>

<pre><font size=+1>SECTIONS</font></pre>

<pre><font size=+1>{</font></pre>

<pre><font size=+1>. = 0xA0020000;</font></pre>

<pre><font size=+1>.text : {</font></pre>

<pre><font size=+1>_ftext = . ;</font></pre>

<pre><font size=+1>*(.init)</font></pre>

<pre><font size=+1>eprol = .;</font></pre>

<pre><font size=+1>*(.text)</font></pre>

<pre><font size=+1>PROVIDE (__runtime_reloc_start = .);</font></pre>

<pre><font size=+1>*(.rel.sdata)</font></pre>

<pre><font size=+1>PROVIDE (__runtime_reloc_stop = .);</font></pre>

<pre><font size=+1>*(.fini)</font></pre>

<pre><font size=+1>etext = .;</font></pre>

<pre><font size=+1>_etext = .;</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>. = .;</font></pre>

<pre><font size=+1>.rdata : {</font></pre>

<pre><font size=+1>*(.rdata)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>_fdata = ALIGN(16);</font></pre>

<pre><font size=+1>.data : {</font></pre>

<pre><font size=+1>*(.data)</font></pre>

<pre><font size=+1>CONSTRUCTORS</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>. = ALIGN(8);</font></pre>

<pre><font size=+1>_gp = . + 0x8000;</font></pre>

<pre><font size=+1>__global = _gp;</font></pre>

<pre><font size=+1>.lit8 : {</font></pre>

<pre><font size=+1>*(.lit8)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>.lit4 : {</font></pre>

<pre><font size=+1>*(.lit4)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>.sdata : {</font></pre>

<pre><font size=+1>*(.sdata)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>edata = .;</font></pre>

<pre><font size=+1>_edata = .;</font></pre>

<pre><font size=+1>_fbss = .;</font></pre>

<pre><font size=+1>.sbss : {</font></pre>

<pre><font size=+1>*(.sbss)</font></pre>

<pre><font size=+1>*(.scommon)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>.bss : {</font></pre>

<pre><font size=+1>_bss_start = . ;</font></pre>

<pre><font size=+1>*(.bss)</font></pre>

<pre><font size=+1>*(COMMON)</font></pre>

<pre><font size=+1>}</font></pre>

<pre><font size=+1>end = .;</font></pre>

<pre><font size=+1>_end = .;</font></pre>

<pre><font size=+1>}</font></pre>
</blockquote>

<h3 CLASS="Heading1">
<a NAME="pgfId=462092"></a><a NAME="37616"></a><b><i><font size=+2>Debugger
features for the LSI TinyRISC</font></i></b><a NAME="marker=464550"></a></h3>

<div CLASS="Body"><a NAME="pgfId=462094"></a><a NAME="marker=462093"></a><font size=+1>GDB
uses the MIPS remote debugging protocol to talk to a target via a serial
port. To run a program on the TinyRISC board, start up GDB with the name
of your program as the argument to the GDB call: <tt>mips-lsi-elf-gdb</tt>&lt;<i><tt>program</tt></i>>,
for example.</font></div>

<div CLASS="Body"><a NAME="pgfId=462096"></a><font size=+1>Use the `<tt>target
lsi </tt>&lt;<i><tt>port</tt></i>>' command to specify the connection to
your target board, where `&lt;<i><tt>port</tt></i>>'is the name of the
serial port connected to the board. If the program has not already been
downloaded to the board, use the `<tt>load</tt>' command to download it.
You can then use all the usual GDB commands. For example, the following
sequence connects to the target board through a Unix serial port, and loads
and runs a program called `<tt>prog</tt>' through the debugger.</font></div>

<br>&nbsp;
<pre CLASS="CodeExample"><a NAME="pgfId=462099"></a><font size=+1><tt>mips-lsi-elf-gdb </tt>prog</font></pre>

<pre><font size=+1>GDB is free software and . . .</font></pre>

<pre><font size=+1><b>(gdb)</b>target lsi /dev/ttyb</font></pre>

<pre><font size=+1><b>(gdb)</b>load prog</font></pre>

<pre><font size=+1><b>(gdb)</b>run</font></pre>

<pre CLASS="Body"><a NAME="pgfId=462100"></a><font size=+1>On PC platforms, substitute the specific COM port:</font></pre>

<pre CLASS="CodeExample"><a NAME="pgfId=462101"></a><font size=+1><b>C:\</b>> <tt>mips-lsi-elf-gdb</tt>prog</font></pre>

<pre><font size=+1>GDB is free software and . . .</font></pre>

<pre><font size=+1><b>(gdb)</b>target lsi com3</font></pre>

<pre><font size=+1><b>(gdb)</b>load prog</font></pre>

<pre><font size=+1><b>(gdb)</b>run</font></pre>

<h4 CLASS="Heading2">
<a NAME="pgfId=462104"></a><b><i><font size=+2>Special commands for LSI
TinyRISC</font></i></b><a NAME="marker=464552"></a></h4>

<div CLASS="Body"><a NAME="pgfId=462105"></a><font size=+1>GDB also supports
the following special commands for MIPS targets.</font></div>

<div CLASS="BodyHang1"><a NAME="pgfId=462106"></a><tt><font size=+1>set
remotedebug num</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=462107"></a><tt><font size=+1>show
remotedebug</font></tt></div>

<blockquote><font size=+1>For this to be useful, you must know something
about the MIPS debugging protocol, also called `<tt>rmtdbg</tt>'. An informal
description can be found in the GDB source files, specifically in the `<tt>remote-mips.c</tt>'
file .</font>

<p CLASS="BodyListFollow"><a NAME="pgfId=462108"></a><font size=+1>You
can see some debugging information about communications with the board
by setting the `<tt>remotedebug</tt>'variable. If you set it to 1 using
the `<tt>set remotedebug 1</tt>' command, every packet is displayed. If
you set it to 2, every character is displayed. You can check the current
value at any time with the `<tt>showremotedebug</tt>' command.</font></blockquote>

<div CLASS="BodyHang1"><a NAME="pgfId=462109"></a><tt><font size=+1>set
timeout seconds</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=462110"></a><tt><font size=+1>set
retranjut</font></tt></div>

<div CLASS="BodyHang1List"><a NAME="pgfId=462112"></a><tt><font size=+1>show
retransmit-timeout</font></tt></div>

<blockquote><font size=+1>You can control the timeout used while waiting
for a packet, in the MIPS debugging protocol, with the `<tt>set timeout
seconds</tt>' command. The default is 5 seconds. Similarly, you can control
the timeout used while waiting for an acknowledgment of a packet with the
<tt>set
retransmit-timeout seconds </tt>command. The default is 3 seconds. You
can inspect both values with the `<tt>show timeout</tt>' and `<tt>show
retransmit-timeout</tt>' commands.</font></blockquote>

<blockquote>
<div CLASS="BodyListFollow"><a NAME="pgfId=462114"></a><font size=+1>The
timeout set by `<tt>set timeout</tt>' does not apply when GDB is waiting
for your program to stop. In that case, GDB waits forever because it has
no way of knowing how long the program is going to run before stopping.</font></div>
</blockquote>

<h3 CLASS="Heading1">
<a NAME="pgfId=462117"></a><a NAME="16138"></a><i><font size=+2>Stand-alone
simulator issues for LSI TinyRISC</font></i><a NAME="marker=464551"></a></h3>

<div CLASS="Body"><a NAME="pgfId=462118"></a><font size=+1>Three run-time
command-line options are available with the stand-alone simulator: <tt>-t</tt>,
<tt>-v</tt>,
and <tt>-m</tt>, as the following documentation describes.</font></div>

<div CLASS="Body"><a NAME="pgfId=462119"></a><font size=+1>The `<tt>-t</tt>'
command-line option to the stand-alone simulator turns on tracing of all
memory fetching and storing in the simulator, as the following example
shows.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=462120"></a><font size=+1>C:\><tt>mips-lsi-elf-run -t hello.xb</tt></font></pre>

<pre><font size=+1>C:\></font></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=462121"></a><font size=+1>The simulator
writes the trace information to the file `<tt>trace.din</tt>'. The following
example shows the first few lines of a trace file.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=462122"></a><font size=+1>2 a0020000 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020004 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020008 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a002000c ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020010 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020014 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020018 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a002001c ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020020 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>2 a0020024 ; width 4 ; load instruction</font></pre>

<pre><font size=+1>. . .</font></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=462123"></a><font size=+1>The `<tt>-v</tt>'
command-line option prints some simple statistics, as the following example
shows.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=462125"></a><font size=+1>%mips-lsi-elf-run -v hello.xb</font></pre>

<pre><font size=+1>mips-lsi-elf-run hello</font></pre>

<pre><font size=+1>Hello, world!</font></pre>

<pre><font size=+1>3 + 4 = 7</font></pre>

<pre><font size=+1>MIPS 32-bit simulator</font></pre>

<pre><font size=+1>Big endian memory model</font></pre>

<pre><font size=+1>0x00200000 bytes of memory at 0xa0000000</font></pre>

<pre><font size=+1>Instruction fetches = 4138</font></pre>

<pre><font size=+1>Pipeline ticks = 4138</font></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=462127"></a><font size=+1>The `<tt>-m</tt>'
command-line option sets the size of the simulated memory area. The default
size is 1048576 bytes (1 megabyte). The simulator rounds up the size you
request to the next power of two. See the following example script for
details.</font></div>

<br>&nbsp;
<blockquote>
<pre CLASS="CodeExample"><a NAME="pgfId=462129"></a><font size=+1>%mips-lsi-elf-run -v -m 200000 hello.xb</font></pre>

<pre><font size=+1>mips-lsi-elf-run hello</font></pre>

<pre><font size=+1>Hello, world!</font></pre>

<pre><font size=+1>3 + 4 = 7</font></pre>

<pre><font size=+1>MIPS 32-bit simulator</font></pre>

<pre><font size=+1>Big endian memory model</font></pre>

<pre><font size=+1>0x00040000 bytes of memory at 0xa0000000</font></pre>

<pre><font size=+1>Instruction fetches = 4138</font></pre>

<pre><font size=+1>Pipeline ticks = 4138</font></pre>
</blockquote>

<div CLASS="Body"><a NAME="pgfId=461624"></a></div>

<div CLASS="Body">
<hr SIZE=5 WIDTH="100%"></div>

<center><a href="#Top">Top</a>|<a href="emb.html">Contents</a>|<a href="embindex.html">Index</a>|<a href="emb08.html">Previous</a>|<a href="emb10.html">Next</a></center>

</body>
</html>
