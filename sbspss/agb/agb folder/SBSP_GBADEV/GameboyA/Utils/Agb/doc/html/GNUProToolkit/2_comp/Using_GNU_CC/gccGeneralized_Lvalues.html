<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Generalized Lvalues</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccReferring_to_a_Type_with_typeof.html">Previous</A>|<A HREF="gccConditionals_with_Omitted_Operan.html">Next</A>
<BR><FONT FACE="Futura Md BT"><FONT COLOR="#000000">&nbsp;<A NAME="off_3375187"></A><A NAME="c3f3a9d7"></A><B><FONT SIZE=+3>Generalized
lvalues&nbsp;</FONT></B>&nbsp;</FONT></FONT>&nbsp;
<HR SIZE=6 WIDTH="100%">
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>Compound expressions, conditional
expressions and casts are allowed as lvalues provided their operands are
lvalues. This means that you can take their addresses or store values into
them.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Standard C++ allows compound
expressions and conditional expressions as lvalues, and permits casts to
reference type, so use of this extension is deprecated for C++ code.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>For example, a compound expression
can be assigned, provided the last expression in the sequence is an lvalue.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The following two expressions
are equivalent.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>(a, b) += 5&nbsp;
a, (b += 5)</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>Similarly, the address of the
compound expression can be taken. The following two expressions are equivalent.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>&amp;(a, b)&nbsp;
a, &amp;b</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>A conditional expression is
a valid lvalue if its type is not void and the true and false branches
are both valid lvalue. For example, the following two expressions are equivalent.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>(a ? b :c)=5&nbsp;
(a ? b =5 :(c=5))</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>A cast is a valid lvalue if
its operand is an lvalue. A simple assignment whose left-hand side is a
cast works by converting the right-hand side first to the specified type,
then to the type of the inner left-hand side expression. After this is
stored, the value is converted back to the specified type to become the
value of the assignment. Thus, if ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
has type </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>char *</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
the following two expressions are equivalent.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>(int)a = 5&nbsp;
(int)(a = (char *)(int)5)</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>An assignment-with-arithmetic
operation such as ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>+=</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
applied to a cast performs the arithmetic using the type resulting from
the cast, and then continues as in the previous case. Therefore, the following
two expressions are equivalent.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>(int)a += 5&nbsp;
(int)(a = (char *)(int) ((int)a + 5))</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>You cannot take the address
of an lvalue cast, because the use of its address would not work out coherently.
Suppose that ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>&amp;(int)f</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
were permitted, where ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>f</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
has type </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>float</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
Then the following statement would try to store an integer bit-pattern
where a floating point number belongs.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>*&amp;(int)f = 1;</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>This is quite different from
what </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>(int)f = 1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
would do—that would convert 1 to floating point and store it. Rather than
cause this inconsistency, we think it is better to prohibit use of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>&amp;</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
on a cast. If you really do want an ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>int
*</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’ pointer with
the address of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>f</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
you can simply write ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>(int
*)&amp;f</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>
<BR>
<HR SIZE=3 WIDTH="100%">
<CENTER><A HREF="#Top">Top</A>|<A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccReferring_to_a_Type_with_typeof.html">Previous</A>|<A HREF="gccConditionals_with_Omitted_Operan.html">Next</A></CENTER>

</BODY>
</HTML>
