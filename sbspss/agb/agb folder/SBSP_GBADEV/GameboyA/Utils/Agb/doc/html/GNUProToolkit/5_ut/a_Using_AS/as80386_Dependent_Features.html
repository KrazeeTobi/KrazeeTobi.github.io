<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>80386 Dependent Features</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="as.html">Contents</A>|<A HREF="asindex.html">Index</A>|<A HREF="asARM.html">Previous</A>|<A HREF="asD10V.html">Next</A>
<BR><A NAME="off_1606723"></A><A NAME="b286ca4d"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>AT&amp;T/Intel
dependent features</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>See
the following documentation for the the AT&amp;T/Intel architecture’s features
and options for the assembler.</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">AT&amp;T
syntax versus Intel syntax</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Options
for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Opcode
naming for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Register
naming for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Opcode
prefixes for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Memory
references for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Handling
of jump instructions for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Floating
point for 80386</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Writing
16-bit code</A></FONT></FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT COLOR="#008000"><FONT SIZE=+1><A HREF="as80386_Dependent_Features.html#f913fc4e">Notes
for 80386</A></FONT></FONT></FONT></LI>
</UL>
</UL>
</UL>
<FONT SIZE=+1>See also <A HREF="asIntel_960_Dependent_Features.html">Intel
960 dependent features</A>.</FONT>

<P><A NAME="a3948271"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>AT&amp;T
syntax versus Intel syntax</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>In
order to maintain compatibility with the output of GCC, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
supports AT&amp;T System V/386 assembler syntax. This is quite different
from Intel syntax. We mention these differences because almost all 80386
documents used only Intel syntax. Notable differences between the two syntaxes
are:</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T immediate operands
are preceded by </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>;
Intel immediate operands are undelimited (Intel </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>push
4</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> is AT&amp;T
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>pushl $4</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>).
AT&amp;T register operands are preceded by </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>;
Intel register operands are undelimited. AT&amp;T absolute (as opposed
to PC relative) </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>jump/call</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
operands are prefixed by </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>;
they are undelimited in Intel syntax.</FONT></FONT></LI>
</UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T and Intel syntax use
the opposite order for source and destination operands. Intel </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>add
eax, 4</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> is </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>addl
$4, %eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>. The
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>source, dest</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
convention is maintained for compatibility with previous Unix assemblers.</FONT></FONT></LI>
</UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>In AT&amp;T syntax the size
of memory operands is determined from the last character of the opcode
name. Opcode suffixes of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>b</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>w</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>l </FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>specify
byte (8-bit), word (16-bit), and long (32-bit) memory references. Intel
syntax accomplishes this by prefixes memory operands (<I>not</I> the opcodes
themselves) with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>byte
ptr</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>word
ptr</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>, and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dword
ptr</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>. Thus, Intel
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>mov al, byte ptr <I>foo</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movb <I>foo</I>,
%al</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> in AT&amp;T
syntax.</FONT></FONT></LI>
</UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>Immediate form long jumps and
calls are </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>lcall/ljmp
$ <I>section</I>, $<I>offset</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in AT&amp;T syntax; the Intel syntax </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>is
call/jmp far <I>section</I>: <I>offset</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
Also, the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>far return</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
instruction is </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>lret
$<I>stack-adjust</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in AT&amp;T syntax; Intel syntax is </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ret
far <I>stack-adjust</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></LI>
</UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The AT&amp;T assembler does
not provide support for multiple section programs. Unix style systems expect
all programs to be single sections.</FONT></FONT></LI>
</UL>
</UL>
</UL>
<A NAME="f913fc4e"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Options
for 80386</FONT></FONT></I></B>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The
80386 has no machine dependent options.</FONT></FONT></FONT>

<P><A NAME="45d81956"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Opcode
naming for 80386</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Opcode
names are suffixed with one character modifiers which specify the size
of operands. The letters </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>b</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>w</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>l</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
specify byte, word, and long operands. If no suffix is specified by an
instruction and it contains no memory operands then as tries to fill in
the missing suffix based on the destination register operand (the last
one by convention). Thus, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>mov
%ax, %bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> is equivalent
to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movw %ax, %bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>;
also, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>mov $1, %bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is equivalent to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movw
$1, %bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>. Note
that this is incompatible with the AT&amp;T Unix assembler which assumes
that a missing opcode suffix implies long operand size. (This incompatibility
does not affect compiler output since compilers always explicitly specify
the opcode suffix.)</FONT></FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>Almost
all opcodes have the same names in AT&amp;T and Intel format. There are
a few exceptions.</FONT></FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The
sign extend and zero extend instructions need two sizes to specify them.
They need a size to sign/zero extend from and a size to zero extend <I>to</I>.
This is accomplished by using two opcode suffixes in AT&amp;T syntax.</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Base
names for </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sign extend</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>zero extend</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
are </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movs...</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>and
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movz...</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in AT&amp;T syntax (</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movsx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movzx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in Intel syntax).</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>The
opcode suffixes are tacked on to this base name, the <I>from</I> suffix
before the <I>to</I> suffix. Thus, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>movsbl
%al, %edx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> is AT&amp;T
syntax for “move sign extend <I>from</I> </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%al</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
<I>to</I> </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.”
Possible suffixes, thus, are </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>bl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(from byte to long), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>bw</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(from byte to word), and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>wl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(from word to long).</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>The
following Intel-syntax conversion instructions are called </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>cbtw</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>cwtl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>cwtd</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>cltd</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in AT&amp;T naming. </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
accepts either naming for the following instructions.</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Courier New"><FONT SIZE=+0>cbw</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>sign-extend byte in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%al</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to word in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ax</FONT></FONT></UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Courier New"><FONT SIZE=+0>cwde</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>sign-extend word in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to long in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%eax</FONT></FONT></UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Courier New"><FONT SIZE=+0>cwd</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>sign-extend word in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to long in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%dx:%ax</FONT></FONT></UL>
</UL>
</UL>

<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Courier New"><FONT SIZE=+0>cdq</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>sign-extend dword in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to quad in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edx:%eax</FONT></FONT></UL>
</UL>
</UL>
<FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Far call/jump
instructions are </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>lcall</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ljmp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in AT&amp;T syntax, but </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>call</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>far</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>jump</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>far</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in Intel convention.</FONT></FONT></FONT>

<P><A NAME="b52a113d"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Register
naming for 80386</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Register
operands are always prefixes with </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>%</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></FONT>
<FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The 80386
registers consist of the following components:</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>8 32-<I>bit registers</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(the accumulator), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ebx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ecx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edi</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%esi</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ebp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(the frame pointer), and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%esp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(the stack pointer).</FONT></FONT>
<LI>
&nbsp;<FONT FACE="Times New Roman"><FONT SIZE=+1>8 16-<I>bit low-ends</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%ax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%cx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%dx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%di</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%si</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%bp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%sp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>8 8-<I>bit registers</I></FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%ah</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%al</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%bh</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%bl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ch</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%cl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%dh</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%dl</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
(These are the high-bytes and low-bytes of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%bx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%cx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%dx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.)</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>6 <I>section registers</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%cs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>code section</I>), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ds</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>data section</I>), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ss</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>stack section</I>), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%es</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%fs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%gs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>3 <I>processor control registers</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%cr0</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%cr2</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%cr3</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>6 <I>debug registers</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%db0</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%db1</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%db2</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%db3</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%db6</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%db7</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>2 <I>test registers</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%tr6</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%tr7</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>8 <I>floating point register
stack</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>%st</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
or, equivalently, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(0)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(1)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(2)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(3)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(4)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(5)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(6)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%st(7)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></UL>
</UL>
</UL>
<A NAME="d2a21442"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Opcode
prefixes for 80386</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Opcode
prefixes are used to modify the following opcode. They are used to repeat
string instructions, to provide section overrides, to per-form bus lock
operations, and to give operand and address size (16-bit operands are specified
in an instruction by prefixing what would nor-mally be 32-bit operands
with a <I>operand size</I> opcode prefix). Opcode prefixes are usually
given as single-line instructions with no operands, and must directly precede
the instruction they act upon. For example, the ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>scas</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
scan string is repeated with the following&nbsp; instruction.</FONT></FONT></FONT>
<UL>
<PRE><FONT SIZE=+1><FONT FACE="Courier New">repne</FONT>&nbsp;
<FONT FACE="Courier New">scas</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The following
is a list of opcode prefixes:</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1><I>Section override prefixes</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>cs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ds</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ss</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>es</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>gs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
These are automatically added by using the </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>section:
memory-operand</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
form for memory references.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1><I>Operand/Address size prefixes</I>:</FONT></FONT></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>data16</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>addr16</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
change 32-<I>bit operands/addresses</I> into 16-<I>bit operands/addresses</I>.</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:16-<I>bit addressing</I>
modes are not yet supported (i.e., 8086 and 80286 addressing modes).</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The <I>bus lock prefix</I>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>lock</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
inhibits interrupts during execution of the instruction it precedes. (This
is only valid with certain instructions; see a 80386 manual for details).</FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The <I>wait for coprocessor</I>
prefix, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>wait</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
waits for the coprocessor to complete the current instruction. This should
never be needed for the 80386/80387 combination.</FONT></FONT></LI>

<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>rep</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>repe</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>repne</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
prefixes are added to string instructions to make them repeat </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ecx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
times.</FONT></FONT></LI>
</UL>
</UL>
</UL>
<A NAME="630fb2a3"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Memory
references for 80386</FONT></FONT></I></B>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>An
Intel syntax indirect memory reference of the following form translates
into the AT&amp;T syntax.</FONT></FONT></FONT>
<UL><FONT FACE="Courier New"><FONT SIZE=+0><I>section</I>:[<I>base</I>
+ <I>index</I>*<I>scale</I> + <I>disp</I>]</FONT></FONT></UL>
<FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The following
is the AT&amp;T syntax.</FONT></FONT></FONT>
<UL><FONT FACE="Courier New"><FONT SIZE=+0><I>section</I>:<I>disp</I>(<I>base</I>,
<I>index</I>, <I>scale</I>)</FONT></FONT></UL>
<FONT COLOR="#000000"><I><FONT FACE="Courier New"><FONT SIZE=+0>base</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>index</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
are the optional 32-bit base and index registers, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>disp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is the optional displacement, and </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>scale</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>,
taking the values 1, 2, 4, and 8, multiplies </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>index</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
to calculate the address of the operand. If no </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>scale</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is specified, </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>scale</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is taken to be 1. </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>section</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
specifies the optional section register for the memory operand, and may
override the default section register (see a 80386 manual for section register
defaults). Section overrides in AT&amp;T syntax <I>must</I> have be preceded
by a </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>%</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.
If you specify a section override which coincides with the default section
register, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
does <I>not</I> output any section register override prefixes to assemble
the given instruction. Thus, section overrides can be specified to emphasize
which section register is used for a given memory operand.</FONT></FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>The
following are some examples of Intel and AT&amp;T style memory references:</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-4(%ebp)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
Intel: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>[ebp - 4]</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT></LI>

<BR><I><FONT FACE="Courier New"><FONT SIZE=+0>base</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ebp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>disp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is ‘-4’. </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>section</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is missing, and the default section is used (‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ss</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
for addressing with ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ebp</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
as the base register). </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>index</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>scale</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
are both missing.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo(,%eax,4)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
Intel: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>[foo + eax*4]</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT></LI>

<BR><I><FONT FACE="Courier New"><FONT SIZE=+0>index</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
(scaled by a scale4); </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>disp</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
All other fields are missing. The section register here defaults to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%ds</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo(,1)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
Intel ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>[foo]</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>This uses the value pointed
to by ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
as a memory operand. Note that </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>base</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>index</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
are both missing, but there is only <I>one</I> ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>,</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
This is a syntactic exception.</FONT></FONT>
<LI>
<FONT FACE="Times New Roman"><FONT SIZE=+1>AT&amp;T: ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%gs:foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
Intel ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>gs:foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT></LI>

<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>This selects the contents
of the variable ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
with section register </FONT></FONT><I><FONT FACE="Courier New"><FONT SIZE=+0>section</FONT></FONT></I><FONT FACE="Times New Roman"><FONT SIZE=+1>
being ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%gs</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>
<LI>
<FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Absolute
(as opposed to PC relative) call and jump operands must be prefixed with
</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.
If no </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
is specified, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
always chooses PC relative addressing for jump/call labels.</FONT></FONT></FONT></LI>

<LI>
<FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Any instruction
that has a memory operand <I>must</I> specify its size (byte, word, or
long) with an opcode suffix (</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>b</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>w</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
or</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0> l</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
respectively).</FONT></FONT></FONT></LI>
</UL>
</UL>
</UL>
<A NAME="1f5d5d39"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Handling
of jump instructions for 80386</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Jump
instructions are always optimized to use the smallest possible displacements.
This is accomplished by using byte (8-bit) displacement jumps whenever
the target is sufficiently close. If a byte displacement is insufficient
a long (32-bit) displacement is used. We do not support word (16-bit) displacement
jumps (i.e., prefixing the jump instruction with the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>addr16</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
opcode prefix), since the 80386 insists upon masking </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%eip</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to 16 bits after the word displacement is added.</FONT></FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>jcxz</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>jecxz</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>loop</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>loopz</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>loope</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>loopnz</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>loopne</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
instructions only come in byte displacements, so that if you use these
instructions (GCC does not use them) you may get an error message (and
incorrect code). The AT&amp;T 80386 assembler tries to get around this
problem by expanding </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>jcxz
foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> to the following.</FONT></FONT></UL>

<UL>
<UL>
<PRE><FONT FACE="Courier New,Courier"><FONT SIZE=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz cx_zero</FONT></FONT></PRE>

<PRE><FONT FACE="Courier New,Courier"><FONT SIZE=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp cx_nonzero</FONT></FONT></PRE>

<PRE><FONT FACE="Courier New,Courier"><FONT SIZE=+1>cx_zero:&nbsp;&nbsp;&nbsp; jmp foo</FONT></FONT></PRE>

<PRE><FONT FACE="Courier New,Courier"><FONT SIZE=+1>cx_nonzero:</FONT></FONT></PRE>
</UL>
</UL>
<A NAME="40156152"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Floating
point for 80386</FONT></FONT></I></B>

<P><FONT FACE="Times New Roman"><FONT COLOR="#000000"><FONT SIZE=+1>All
80387 floating point types except packed BCD are supported. (BCD support
may be added without much difficulty). These data types are 16-, 32-, and
64- bit integers, and single (32-bit), double (64-bit), and extended (80-bit)
precision floating point. Each supported type has an opcode suffix and
a constructor associated with it. Opcode suffixes specify operand’s data
types. Constructors build these data types into memory.</FONT></FONT></FONT>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<UL TYPE=SQUARE>
<LI>
<B><I><FONT FACE="Times New Roman"><FONT SIZE=+1>Floating point constructors</FONT></FONT></I></B></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>.float</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.single</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.double</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.tfloat</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
for 32-, 64-, and 80-bit formats. These correspond to opcode suffixes,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>s</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>l</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>t</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>t</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
stands for <I>temporary real</I>, and that the 80387 only supports this
format via the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fldt</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>load temporary real</I> to <I>stack top</I>) and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fstpt</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>store temporary real</I> and <I>pop stack</I>) instructions.</FONT></FONT>
<LI>
<B><I><FONT FACE="Times New Roman"><FONT SIZE=+1>Integer constructors</FONT></FONT></I></B></LI>

<BR><FONT FACE="Courier New"><FONT SIZE=+0>.word</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.long</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.int</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.quad</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
for the 16-, 32-, and 64-bit integer formats.</FONT></FONT></UL>
</UL>
</UL>
<FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>The corresponding
<I>opcode suffixes</I> are </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>s</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(single), </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>l</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(long), and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>q</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(quad). As with the <I>temporary real</I> format, the 64-bit </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>q</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
format is only present in the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fildq</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>load quad integer</I> to <I>stack top</I>) and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fistpq</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
(<I>store quad integer</I> and <I>pop stack</I>) instructions.</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Register
to register operations do not require opcode suffixes, so that the statement,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fst %st, %st(1)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
is equivalent to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fstl
%st, %st(1)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>Since
the 80387 automatically synchronizes with the 80386, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fwait</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
instructions are almost never needed (this is not the case for the 80286/80287
and 8086/8087 combinations). Therefore, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
suppresses the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fwait</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
instruction whenever it is implicitly selected by one of the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fn</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
the instructions. For example, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fsave</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fnsave</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
are treated identically. In general, all the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fn</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
the instructions are made equivalent to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>f</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
the instructions. If </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fwait</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is desired, it must be explicitly coded.</FONT></FONT></FONT>

<P><A NAME="73498178"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Writing
16-bit code</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>While
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
normally writes only <I>pure</I> 32-bit i386 code, it has limited support
for writing code to run in real mode or in 16-bit protected mode code segments.
To do this, insert a </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.code16</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
directive before the assembly language instructions to be run in 16-bit
mode. You can switch </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
back to writing normal 32-bit code with the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.code32</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
directive.</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
understands exactly the same assembly language syntax in 16- bit mode as
in 32-bit mode. The function of any given instruction is exactly the same
regardless of mode, as long as the resulting object code is executed in
the mode for which </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
wrote it. So, for example, the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>ret</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
mnemonic produces a 32-bit return instruction regardless of whether it
is to be run in 16-bit or 32-bit mode. (If </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is in 16-bit mode, it will add an operand size prefix to the instruction
to force it to be a 32-bit return.)</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>This
means, for one thing, that you can use GNU CC to write code to be run in
real mode or 16-bit protected mode. Just insert the statement </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>asm(".code16");</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
at the beginning of your C source file, and while GNU CC will still be
generating 32-bit code, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
will automatically add all the necessary size prefixes to make that code
run in 16-bit mode. Of course, since GNU CC only writes small-model code
(it doesn’t know how to attach segment selectors to pointers like native
x86 compilers do), any 16-bit code you write with GNU CC will essentially
be limited to a 64K address space. Also, there will be a code size and
performance penalty due to all the extra address and operand size prefixes
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
has to add to the instructions.</FONT></FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>Placing </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in 16-bit mode does not mean that the resulting code will necessarily run
on a 16-bit pre-80386 processor. To write code that runs on such a processor,
you would have to refrain from using <I>any</I> 32-bit constructs which
require </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to output address or operand size prefixes. At the moment this would be
rather difficult, because </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>as</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
currently supports <I>only</I> 32-bit addressing modes: when writing 16-bit
code, it <I>always</I> outputs address size prefixes for any instruction
that uses a non-register addressing mode. So you can write code that runs
on 16-bit processors, but only if that code never references memory.</FONT></FONT></UL>
<A NAME="9c6fb305"></A><B><I><FONT FACE="Times New Roman"><FONT SIZE=+2>Notes
for 80386</FONT></FONT></I></B>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>There
is some trickery concerning the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>mul</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
instructions that deserves mention. The 16-, 32-, and 64-bit expanding
multiplies (base opcode </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>0xf6</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>;
extension 4 for </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>mul</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and 5 for </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
can be output only in the one operand form. Thus, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul
%ebx, %eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> does
<I>not</I> select the expanding multiply; the expanding multiply would
clobber the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
register, and this would confuse GNU CC output. Use </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul
%ebx</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> to get the
64-bit product in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%edx:%eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></FONT>

<P><FONT COLOR="#000000"><FONT FACE="Times New Roman"><FONT SIZE=+1>We
have added a two operand form of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
when the first operand is an immediate mode expression and the second operand
is a register. This is just a shorthand, so that, multiplying </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>%eax
</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>by 69, for example,
can be done with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul
$69, %eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> rather
than </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>imul $69, %eax,
%eax</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT></FONT>
<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="as.html">Contents</A>|<A HREF="asindex.html">Index</A>|<A HREF="asARM.html">Previous</A>|<A HREF="asD10V.html">Next</A></CENTER>

</BODY>
</HTML>
