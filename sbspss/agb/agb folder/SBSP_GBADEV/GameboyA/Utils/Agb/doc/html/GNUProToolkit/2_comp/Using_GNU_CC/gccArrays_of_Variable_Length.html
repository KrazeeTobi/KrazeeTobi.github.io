<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Arrays of Variable Length</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccArrays_of_Length_Zero.html">Previous</A>|<A HREF="gccMacros_with_Variable_Numbers_of_.html">Next</A>
<BR><FONT FACE="Futura Md BT"><FONT COLOR="#000000">&nbsp;<A NAME="off_3441153"></A><A NAME="2a2b574a"></A><B><FONT SIZE=+3>Arrays
of variable length&nbsp;</FONT></B>&nbsp;</FONT></FONT>&nbsp;
<HR SIZE=6 WIDTH="100%">
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>Variable-length automatic
arrays are allowed in GNU C. These arrays are declared like any other automatic
arrays, but with a length that is not a constant expression. The storage
is allocated at the point of declaration and deallocated when the brace-level
is exited. Use the following for example.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>FILE *&nbsp;
concat_fopen (char *s1, char *s2, char *mode)&nbsp;
{&nbsp;
&nbsp;&nbsp; char str[strlen (s1) + strlen (s2) + 1];&nbsp;
&nbsp;&nbsp; strcpy (str, s1);&nbsp;
&nbsp;&nbsp; strcat (str, s2);&nbsp;
&nbsp;&nbsp; return fopen (str, mode);&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>Jumping or breaking out of the
scope of the array name deallocates the storage. Jumping into the scope
is not allowed; you get an error message for it.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can use the function
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>alloca</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
to get an effect much like variable-length arrays. The function </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>alloca</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is available in many other C implementations (but not in all).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>On the other hand, variable-length
arrays are more elegant.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>There are other differences
between these two methods. Space allocated with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>alloca</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
exists until the containing <I>function</I> returns. The space for a variable-length
array is deallocated as soon as the array name’s scope ends. (If you use
both variable-length arrays and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>alloca</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in the same function, deallocation of a variable-length array will also
deallocate anything more recently allocated with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>alloca</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.)</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can also use variable-length
arrays as arguments to functions, as in the following example.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>struct entry&nbsp;
tester (int len, char data[len][len])&nbsp;
{&nbsp;
&nbsp;&nbsp; ...&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The length of an array is computed
once when the storage is allocated and is remembered for the scope of the
array in case you access it with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sizeof</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If you want to pass the array
first and the length afterward, you can use a forward declaration in the
parameter list—another GNU extension.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>struct entry&nbsp;
tester (int len; char data[len][len], int len)&nbsp;
{&nbsp;
&nbsp;&nbsp; ...&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>int</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>len</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
before the semicolon is a <I>parameter forward declaration</I>, and it
serves the purpose of making the name </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>len</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
known when the declaration of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>data</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
is parsed. You can write any number of such parameter forward declarations
in the parameter list. They can be separated by commas or semicolons, but
the last one must end with a semicolon, which is followed by the “real”<I>
</I>parameter declarations. Each forward declaration must match a “real”<I>
</I>declaration in parameter name and data type.</FONT></FONT>
<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccArrays_of_Length_Zero.html">Previous</A>|<A HREF="gccMacros_with_Variable_Numbers_of_.html">Next</A></CENTER>

</BODY>
</HTML>
