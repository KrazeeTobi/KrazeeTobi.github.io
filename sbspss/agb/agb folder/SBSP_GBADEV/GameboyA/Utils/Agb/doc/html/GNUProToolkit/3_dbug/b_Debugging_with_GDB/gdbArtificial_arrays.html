<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Artificial arrays</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gdb.html">Contents</A>|<A HREF="gdbindex.html">Index</A>|<A HREF="gdbProgram_variables.html">Previous</A>|<A HREF="gdbOutput_formats.html">Next</A>
<BR><A NAME="off_1409024"></A><A NAME="25a6b1d9"></A><B><FONT FACE="Futura Md BT"><FONT COLOR="#000000"><FONT SIZE=+3>Artificial
arrays</FONT></FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>It is
often useful to print out several successive objects of the same type in
memory; a section of an array, or an array of dynamically determined size
for which only a pointer exists in the program.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can do this by referring
to a contiguous span of memory as an <I>artificial array</I>, using the
binary operator, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
The left operand of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
should be the first element of the desired array and be an individual object.
The right operand should be the desired length of the array. The result
is an array value whose elements are all of the type of the left argument.
The first element is actually the left argument; the second element comes
from bytes of memory immediately following those holding the first element,
and so on.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If a program says </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>int
*array = (int *) malloc (len * sizeof (int));</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
you can print the contents of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>array</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
with </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>p *array@len</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The left operand of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
must reside in memory. Array values made with ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
in this way behave just like other arrays in terms of subscripting, and
are coerced to pointers when used in expressions. Artificial arrays most
often appear in expressions via the value history (see <FONT COLOR="#008000"><A HREF="gdbValue_history.html">Value
history</A></FONT>), after printing one out.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Another way to create an
artificial array is to use a cast. This re-interprets a value as if it
were an array. The value need not be in memory as the following example
shows.</FONT></FONT>
<BR>&nbsp;
<UL><B><FONT FACE="Courier New"><FONT SIZE=+0>(gdb) <I>p/x (short[2])0x12345678</I></FONT></FONT></B>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>$1 = {0x1234, 0x5678}</FONT></FONT></B></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>As a convenience, if you
leave the array length out, as in ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>(<I>type</I>)[])<I>value</I></FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
GDB calculates the size to fill the value, as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>sizeof(<I>value</I>)/sizeof(<I>type</I>)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
as the following example shows.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0><B>(gdb) </B>p/x (short[])0x12345678<B></B></FONT></FONT>
<BR><B><FONT FACE="Courier New"><FONT SIZE=+0>$2 = {0x1234, 0x5678}</FONT></FONT></B></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Sometimes the artificial
array mechanism is not quite enough; in moderately complex data structures,
the elements of interest may not actually be adjacent—for example, if you
are interested in the values of pointers in an array. One useful work-around
in this situation is to use a convenience variable (see <FONT COLOR="#008000"><A HREF="gdbConvenience_variables.html">Convenience
variables</A></FONT>) as a counter in an expression that prints the first
interesting value, and then repeat that expression using </FONT></FONT><B><FONT FACE="Arial"><FONT SIZE=+0>Return</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.
For instance, suppose you have an array, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dtab</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
of pointers to structures, and you are interested in the values of a field,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>fv</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
in each structure. The following is an example of what you might use as
a declaration.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>set $i = 0</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>p dtab[$i++]->fv</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>(At this point, use the </FONT></FONT><B><FONT FACE="Arial"><FONT SIZE=+0>Return</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
key twice.)</FONT></FONT>

<P>
<HR SIZE=3 WIDTH="100%">
<CENTER><A HREF="#Top">Top</A>|<A HREF="gdb.html">Contents</A>|<A HREF="gdbindex.html">Index</A>|<A HREF="gdbProgram_variables.html">Previous</A>|<A HREF="gdbOutput_formats.html">Next</A></CENTER>

</BODY>
</HTML>
