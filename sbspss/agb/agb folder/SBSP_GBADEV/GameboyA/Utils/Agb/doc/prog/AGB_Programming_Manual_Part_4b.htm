<html>

	<head>
		<link rel="stylesheet" type="text/css" href="style.css">
		<!--
Editors' comments:
mm/dd/yy  Created by * using w2w 2.0
mm/dd/yy Edited by * -->
		<title>Interrupt Control</title>
	</head>

	<body bgcolor="white">
		<h1>
		<h1><a name="T36"></a>15 Interrupt Control</h1>
		</h1>
		<p>AGB can use 14 types of maskable hardware interrupts. If an interrupt request signal is received from a hardware item, the corresponding interrupt request flag is set in the IF register. Masking can be performed individually for interrupt request signals received from each hardware item by means of the interrupt request flag register IE.</p>
		<ul>
			<h2><b><a name="T37"></a>1) Interrupt Master Enable Register</b></h2>
			<ul>
				<p><font size="3">The entire interrupt can be masked.</font></p>
			</ul>
		</ul>
		<ul>
			<ul>
				<p><font size="3">When this flag is 0, all interrupts are disabled.</font></p>
			</ul>
		</ul>
		<ul>
			<ul>
				<p><font size="3">When 1, the setting for interrupt enable register IE is enabled.</font></p>
			</ul>
		</ul>
		<center>
			<p><img src="Image124.gif" width="570" height="91"></p>
		</center>
		<ul>
			<h2>
			<h2><b><a name="T38"></a>2) Interrupt Enable Register </b></h2>
			</h2>
			<ul>
				<p><font size="3">With the interrupt enable register, each hardware interrupt can be individually masked.</font></p>
			</ul>
		</ul>
		<center>
			<p><img src="Image125.gif" width="573" height="283"></p>
		</center>
		<ul>
			<ul>
				<p>By resetting the bit, the corresponding interrupt can be prohibited. Setting this to 1 enables the corresponding interrupt.</p>
			</ul>
		</ul>
		<ul>
			<h2>
			<h2><b><a name="T39"></a>3) Interrupt Request Register</b></h2>
			</h2>
			<ul>
				<p><font size="3">When an interrupt request signal is generated from each hardware device, the corresponding interrupt request flag is set in the IF Register.</font></p>
			</ul>
		</ul>
		<center>
			<p><img src="Image126.gif" width="570" height="234"></p>
		</center>
		<ul>
			<ul>
				<p>If a 1 is written to the bit which the interrupt request flag is set in, that interrupt request flag can be reset.</p>
			</ul>
		</ul>
		<h2>
		<h2>
		<h2>
		<h2><a name="T40"></a>15.1 System-Allocated Area in Work RAM</h2>
		</h2>
		</h2>
		</h2>
		<ul>
			<p>Controlling interrupts entails, along with clearing the IF register and setting the IE register, first writing an interrupt jump address at addresses $7FFC-$7FFF (total of 32 bits; see figure below) in the system allocated area of Work RAM. Processing is executed in 32-bit mode for the user interrupt. To return control from the interrupt routine to the user program, the instruction &quot;BX LR&quot; is used.</p>
		</ul>
		<center>
			<p><img src="Image127.gif" width="451" height="555"></p>
		</center>
		<ul>
			<p>By changing each CPU Mode SP Initial-value, they can be set to an arbitrary memory map.<b> </b></p>
		</ul>
		<h2>
		<h2><b><a name="T41"></a>15.2 Interrupt Operation</b></h2>
		</h2>
		<ul>
			<p>The user can arbitrarily define the Interrupt Processing Routine, but as a general rule, the Monitor ROM handles this processing. For further details on each register, please refer to &quot;ARM7TDMI Data Sheet&quot;.</p>
		</ul>
		<ul>
			<h3>
			<h3><b><a name="T42"></a>15.2.1 Normal Interrupt</b></h3>
			</h3>
		</ul>
		<ol>
			<ol>
				<li>If an interrupt occurs, the CPU enters IRQ mode and control shifts to the Monitor ROM. In Monitor ROM, save each register (R0~R3, R12, LR_irq (former PC)) to the Interrupt Stack. The total is 6 words. Next, call the user interrupt processing set up in 03007FFCh. Commands called from the monitor directly must be in 32bit code format.
			</ol>
			<center>
				<p><img src="Image128.gif" width="533" height="89"></p>
			</center>
			<ol>
				<li>User interrupt processing is done (you can reference the cause of the interrupt with the IF Register). Also solve* problems with a stack, if necessary.<br>
				<br>
				<li>Restore the registers (total of 6 words) saved to the Interrupt Stack and return to user main processing.
			</ol>
		</ol>
		<center>
			<p><img src="Image129.gif" width="533" height="89"></p>
		</center>
		<ul>
			<ul>
				<p><b>*[Note]</b></p>
				<p>Only the interrupt stack is used for normal interrupt processing. Therefore, there is a possibility of stack overflow in some cases. To solve this problem, you can either allocate a larger interrupt stack by moving SP_usr in advance or use user stack for both, by switching the CPU mode to the user mode in user interrupt processing. For the latter method, see the explanation of multiple interrupts that is discussed in the following paragraphs.</p>
			</ul>
		</ul>
		<ul>
			<h3>
			<h3><b><a name="T43"></a>15.2.2 Multiple Interrupts</b></h3>
			</h3>
		</ul>
		<ol>
			<ol>
				<li>If an interrupt occurs, the CPU enters IRQ mode and control shifts to the Monitor ROM. In Monitor ROM, save each register (R0~R3, R12, LR_irq (former PC)) to the Interrupt Stack. The total is 6 words. Next, call the user interrupt processing set up in 03007FFCh. Commands called from the monitor directly must be in 32bit code format.
				<center>
					<p><img src="Image130.gif" width="533" height="89"></p>
				</center>
				<li>User interrupt processing is done (you can reference the cause of the interrupt with the IF Register).
			</ol>
		</ol>
		<ul>
			<ul>
				<p><img src="rightarrow.gif"> If multiple interrupts occur, SPSR_irq will be overwritten, so you must save before enabling IRQ.</p>
			</ul>
		</ul>
		<center>
			<p><img src="Image131.gif" width="533" height="98"></p>
		</center>
		<ul>
			<ul>
				<p><img src="rightarrow.gif"> The Stack problem is solved* (CPU mode is changed to user mode with system mode<img src="rightarrow.gif">privilege here.) and IRQ is enabled.</p>
			</ul>
		</ul>
		<ul>
			<ul>
				<p><img src="rightarrow.gif"> With user interrupt processing, user stack is used because the CPU is in system mode. When calling the subroutine, save LSR_usr as well.</p>
			</ul>
		</ul>
		<center>
			<p><img src="Image132.gif" width="533" height="98"></p>
		</center>
		<ul>
			<ul>
				<p><img src="rightarrow.gif"> When an interrupt occurs, Monitor ROM does the processing (1) again, and loads each register to the interrupt stack.</p>
			</ul>
		</ul>
		<center>
			<p><img src="Image133.gif" width="533" height="98"></p>
		</center>
		<ul>
			<ul>
				<p><img src="rightarrow.gif"> Continue processing (2).
			</ul>
		</ul>
	</body>

</html>
