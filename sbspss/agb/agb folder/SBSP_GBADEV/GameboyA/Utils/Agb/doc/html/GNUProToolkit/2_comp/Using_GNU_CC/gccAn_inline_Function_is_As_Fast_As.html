<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>An inline Function is As Fast As a Macro</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccSpecifying_Attributes_of_Types.html">Previous</A>|<A HREF="gccAssembler_Instructions_with_C_Ex.html">Next</A>
<BR><FONT COLOR="#000000"><FONT FACE="Futura Md BT">&nbsp;<A NAME="off_3899536"></A><A NAME="4b386b1b"></A><B><FONT SIZE=+3>An
</FONT></B></FONT><B><FONT SIZE=+3><FONT FACE="Courier New">inline</FONT><FONT FACE="Futura Md BT">
function is as fast as a macro&nbsp;</FONT></FONT></B><FONT FACE="Futura Md BT">&nbsp;</FONT></FONT>&nbsp;
<HR SIZE=6 WIDTH="100%">
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>By declaring a function,
</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
you can direct GNU CC to integrate that function’s code into the code for
its callers. This makes execution faster by eliminating the function-call
overhead; in addition, if any of the actual argument values are constant,
their known values may permit simplifications at compile time so that not
all of the inline function’s code needs to be included.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The effect on code size is
less predictable; object code may be larger or smaller with function inlining,
depending on the particular case. Inlining of functions is an optimization
and it really “works” only in optimizing compilation. If you don’t use
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-O</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
no function is really inline.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>To declare a function inline,
use the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
keyword in its declaration, like the following example shows.</FONT></FONT>
<UL>
<PRE><FONT FACE="Courier New"><FONT SIZE=+1>inline int&nbsp;
inc (int *a)&nbsp;
{&nbsp;
&nbsp;&nbsp; (*a)++;&nbsp;
}</FONT></FONT></PRE>
</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>(If you are writing a header
file to be included in ANSI C programs, write </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>__inline__</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
instead of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
See <A HREF="gccAlternate_Keywords.html">Alternate keywords</A>.)</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can also make all “simple
enough” functions inline with the option, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-finline-functions</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
Note that certain usage in a function definition can make it unsuitable
for inline substitution.</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Note</I>:</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>In C and Objective C, unlike
C++, the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
keyword does not affect the linkage of the function.</FONT></FONT></UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>GNU CC automatically inlines
member functions defined within the class body of C++ programs even if
they are not explicitly declared </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
(You can override this with ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-fno-default-inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
see <A HREF="gccOptions_Controlling_C_Dialect.html">Options controlling
C++ dialect</A>.)</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>When a function is both </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>static</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
if all calls to the function are integrated into the caller, and the function’s
address is never used, then the function’s own assembler code is never
referenced. In this case, GNU CC does not actually output assembler code
for the function, unless you specify the option, ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-fkeep-inline-functions</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
Some calls cannot be integrated for various reasons (in particular, calls
that precede the function’s definition cannot be integrated, and neither
can recursive calls within the definition). If there is a nonintegrated
call, then the function is compiled to assembler code as usual. The function
must also be compiled as usual if the program refers to its address, because
that can’t be inlined.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>When an </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
function is not </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>static</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
then the compiler must assume that there may be calls from other source
files; since a global symbol can be defined only once in any program, the
function must not be defined in the other source files, so the calls therein
cannot be integrated. Therefore, a non-</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>static
inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1> function
is always compiled on its own in the usual fashion.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If you specify both </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>extern</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
in the function definition, then the definition is used only for inlining.
In no case is the function compiled on its own, not even if you refer to
its address explicitly. Such an address becomes an external reference,
as if you had only declared the function, and had not defined it.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This combination of </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>extern</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
has almost the effect of a macro. The way to use it is to put a function
definition in a header file with these keywords, and put another copy of
the definition (lacking </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>extern</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>)
in a library file. The definition in the header file will cause most calls
to the function to be inlined. If any uses of the function remain, they
will refer to the single copy in the library.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>GNU C does not </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
any functions when not optimizing. It is not clear whether it is better
to </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>inline</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
or not, in this case, but we found that a correct implementation when not
optimizing was difficult. So we did the easy thing, and turned it off.</FONT></FONT>
<BR>
<HR SIZE=3 WIDTH="100%">
<CENTER><A HREF="#Top">Top</A>|<A HREF="gcc.html">Contents</A>|<A HREF="gccindex.html">Index</A>|<A HREF="gccSpecifying_Attributes_of_Types.html">Previous</A>|<A HREF="gccAssembler_Instructions_with_C_Ex.html">Next</A></CENTER>

</BODY>
</HTML>
