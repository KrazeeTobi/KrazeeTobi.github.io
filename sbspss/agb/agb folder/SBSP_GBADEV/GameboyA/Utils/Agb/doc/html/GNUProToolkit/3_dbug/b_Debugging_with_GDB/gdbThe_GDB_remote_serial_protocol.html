<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (Win95; I) [Netscape]">
   <title>The GDB remote serial protocol</title>
</head>
<body>
<a NAME="Top"></a><a href="gdb.html">Contents</a>|<a href="gdbindex.html">Index</a>|<a href="gdbRemote_debugging.html">Previous</a>|<a href="gdbThe_UDI_protocol_for_AMD29K.html">Next</a>
<br><a NAME="off_2457702"></a><a NAME="6830e012"></a><b><font face="Futura Md BT"><font color="#000000"><font size=+3>The
GDB remote serial protocol</font></font></font></b>
<br>
<hr SIZE=3 WIDTH="100%"><font face="Times New Roman"><font size=+1>The
following documentation discusses the remote serial protocol for hosts
and targets.</font></font>
<ul>
<ul>
<ul>
<li>
<font face="Times New Roman"><font size=+1><a href="#What_stub_can_do">What
the stub can do for you</a></font></font></li>

<li>
<font face="Times New Roman"><font size=+1><a href="#What_you_must_do_for_stub">What
you must do for the stub</a></font></font></li>

<li>
<font face="Times New Roman"><font size=+1><a href="#Putting_it_all_together">Putting
it all together</a></font></font></li>

<li>
<font face="Times New Roman"><font size=+1><a href="#Communication_protocol">Communication
protocol</a></font></font></li>

<li>
<font size=+1><a href="#Using_gdbserver"><font face="Times New Roman">Using
the </font><tt>gdbserver</tt><font face="Times New Roman"> program</font></a></font></li>

<li>
<font size=+1><a href="#Using_gdbservnlm"><font face="Times New Roman">Using
the </font><tt>gdbserve.nlm</tt><font face="Times New Roman"> program</font></a></font></li>

<li>
<font face="Times New Roman"><font size=+1><a href="#GDB_i960">GDB with
a remote i960 (Nindy)</a></font></font></li>

<ul>
<li>
<i><font face="Times New Roman"><font size=+1><a href="#Nindy_startup">Startup
with Nindy</a></font></font></i></li>

<li>
<i><font face="Times New Roman"><font size=+1><a href="#Nindy_options">Options
for Nindy</a></font></font></i></li>

<li>
<i><font face="Times New Roman"><font size=+1><a href="#Nindy_reset">Nindy
rest commands</a></font></font></i></li>
</ul>
</ul>
</ul>
</ul>
<font face="Times New Roman"><font size=+1>To debug a program running on
another machine (the debugging <i>target</i> machine), you must first arrange
for all the usual prerequisites for the program to run by itself. For example,
for a C program, you need:</font></font>
<ul>
<ul>
<ul>
<li>
<font face="Times New Roman"><font size=+1>A startup routine to set up
the C runtime environment; these usually have a name like ‘</font></font><font face="Courier New"><font size=+0>crt0</font></font><font face="Times New Roman"><font size=+1>’.
The startup routine may be supplied by your hardware supplier, or you may
have to write your own.</font></font></li>

<li>
<font face="Times New Roman"><font size=+1>You probably need a C subroutine
library to support your program’s subroutine calls, notably managing input
and output.</font></font></li>

<li>
<font face="Times New Roman"><font size=+1>A way of getting your program
to the other machine—for example, a download program. These are often supplied
by the hardware manufacturer, but you may have to write your own from hardware
documentation.</font></font></li>
</ul>
</ul>
</ul>
<font face="Times New Roman"><font size=+1>The next step is to arrange
for your program to use a serial port to communicate with the machine where
GDB is running (the <i>host</i> machine). In general terms, the scheme
has the following protocol.</font></font>
<ul>
<ul>
<ul>
<li>
<font face="Times New Roman"><font size=+1>On the <i>host</i></font></font></li>

<br><font face="Times New Roman"><font size=+1>GDB already understands
how to use this protocol; when everything else is set up, you can simply
use the ‘</font></font><font face="Courier New"><font size=+0>target remote</font></font><font face="Times New Roman"><font size=+1>’
command (see <font color="#008000"><a href="gdbSpecifying_a_Debugging_Target.html">Specifying
a debugging target</a></font>).</font></font></ul>

<ul>
<li>
<font face="Times New Roman"><font size=+1>On the <i>target</i></font></font></li>

<br><font face="Times New Roman"><font size=+1>You must link with your
program a few special-purpose subroutines that implement the GDB remote
serial protocol. The file containing these subroutines is called a debugging
stub. On certain remote targets, you can use an auxiliary program </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font size=+1><font face="Times New Roman">
instead of linking a stub into your program. See <a href="#Using_gdbserver">Using
the </a></font><a href="#Using_gdbserver"><tt>gdbserver</tt><font face="Times New Roman">
program</font></a><font face="Times New Roman"> for details.</font></font></ul>
</ul>
</ul>
<font face="Times New Roman"><font size=+1>The debugging stub is specific
to the architecture of the remote machine; for example, use ‘</font></font><font face="Courier New"><font size=+0>sparc-stub.c</font></font><font face="Times New Roman"><font size=+1>’
to debug programs on SPARC boards. The following working remote stubs are
distributed with GDB.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>sparc-stub.c</font></font>
<ul><font face="Times New Roman"><font size=+1>For SPARC architectures.</font></font></ul>
<font face="Courier New"><font size=+0>m68k-stub.c</font></font>
<ul><font face="Times New Roman"><font size=+1>For Motorola 680x0 architectures.</font></font></ul>
<font face="Courier New"><font size=+0>i386-stub.c</font></font>
<ul><font face="Times New Roman"><font size=+1>For Intel 386 and compatible
architectures.</font></font></ul>
</ul>
</ul>
<font face="Times New Roman"><font size=+1>The ‘</font></font><font face="Courier New"><font size=+0>README</font></font><font face="Times New Roman"><font size=+1>’
file in the GDB distribution may list other recently added stubs.</font></font>
<p><a NAME="What_stub_can_do"></a><b><i><font face="Times New Roman"><font size=+2>What
the stub can do for you</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>The debugging stub for your
architecture supplies the following three subroutines.</font></font>
<ul><font face="Courier New"><font size=+0>set_debug_traps</font></font>
<ul><font face="Times New Roman"><font size=+1>This routine arranges for
</font></font><font face="Courier New"><font size=+0>handle_exception</font></font><font face="Times New Roman"><font size=+1>
to run when your program stops. You must call this subroutine explicitly
near the beginning of your program.</font></font></ul>
<font face="Courier New"><font size=+0>handle_exception</font></font>
<ul><font face="Times New Roman"><font size=+1>This is the central workhorse,
but your program never calls it explicitly—the setup code arranges for
</font></font><font face="Courier New"><font size=+0>handle_exception</font></font><font face="Times New Roman"><font size=+1>
to run when a trap is triggered.</font></font>
<br><font face="Courier New"><font size=+0>handle_exception</font></font><font face="Times New Roman"><font size=+1>
takes control when your program stops during execution (for example, on
a breakpoint), and mediates communications with GDB on the host machine.
This is where the communications protocol is implemented; </font></font><font face="Courier New"><font size=+0>handle_
exception</font></font><font face="Times New Roman"><font size=+1> acts
as the GDB representative on the target machine; it begins by sending summary
information on the state of your program, then continues to execute, retrieving
and transmitting any information GDB needs, until you execute a GDB command
that makes your program resume; at that point, </font></font><font face="Courier New"><font size=+0>handle_exception</font></font><font face="Times New Roman"><font size=+1>
returns control to your own code on the target machine.</font></font></ul>
<font face="Courier New"><font size=+0>breakpoint</font></font>
<ul><font face="Times New Roman"><font size=+1>Use this auxiliary subroutine
to make your program contain a breakpoint. Depending on the particular
situation, this may be the only way for GDB to get control. For instance,
if your target machine has some sort of interrupt button, you won’t need
to call this; pressing the interrupt button transfers control to </font></font><font face="Courier New"><font size=+0>handle_exception</font></font><font face="Times New Roman"><font size=+1>—in
effect, to GDB. On some machines, simply receiving characters on the serial
port may also trigger a trap; again, in that situation, you don’t need
to call </font></font><font face="Courier New"><font size=+0>breakpoint</font></font><font face="Times New Roman"><font size=+1>
from your own program—simply running ‘</font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1>’ from the
host GDB session gets control.</font></font>
<br><font face="Times New Roman"><font size=+1>Call </font></font><font face="Courier New"><font size=+0>breakpoint</font></font><font face="Times New Roman"><font size=+1>
if none of these is true, or if you simply want to make certain your program
stops at a predetermined point for the start of your debugging session.</font></font></ul>
</ul>
<a NAME="What_you_must_do_for_stub"></a><b><i><font face="Times New Roman"><font size=+2>What
you must do for the stub</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>The debugging stubs that
come with GDB are set up for a particular chip architecture, but they have
no information about the rest of your debugging target machine.</font></font>
<p><font face="Times New Roman"><font size=+1>First of all, you need to
tell the stub how to communicate with the serial port.</font></font>
<ul>
<ul>
<ul>
<li>
<font face="Courier New"><font size=+0>int getDebugChar()</font></font></li>

<br><font face="Times New Roman"><font size=+1>Write this subroutine to
read a single character from the serial port. It may be identical to </font></font><font face="Courier New"><font size=+0>getchar</font></font><font face="Times New Roman"><font size=+1>
for your target system; a different name is used to allow you to distinguish
the two if you wish.</font></font></ul>

<ul>
<li>
<font face="Courier New"><font size=+0>void putDebugChar(int)</font></font></li>

<br><font face="Times New Roman"><font size=+1>Write this subroutine to
write a single character to the serial port. It may be identical to </font></font><font face="Courier New"><font size=+0>putchar</font></font><font face="Times New Roman"><font size=+1>
for your target system; a different name is used to allow you to distinguish
the two if you wish.</font></font></ul>
</ul>
</ul>
<font face="Times New Roman"><font size=+1>If you want GDB to be able to
stop your program while it is running, you need to use an interrupt-driven
serial driver, and arrange for it to stop when it receives a </font></font><font face="Courier New"><font size=+0>ˆC</font></font><font face="Times New Roman"><font size=+1>
(‘</font></font><font face="Courier New"><font size=+0>\003</font></font><font face="Times New Roman"><font size=+1>’,
the </font></font><b><font face="Arial"><font size=+0>Control-C</font></font></b><font face="Times New Roman"><font size=+1>
character). That is the character which GDB uses to tell the remote system
to stop.</font></font>
<p><font face="Times New Roman"><font size=+1>Getting the debugging target
to return the proper status to GDB probably requires changes to the standard
stub; one quick and dirty way is to just execute a breakpoint instruction
(the “dirty” part is that GDB reports a </font></font><font face="Courier New"><font size=+0>SIGTRAP</font></font><font face="Times New Roman"><font size=+1>
instead of a </font></font><font face="Courier New"><font size=+0>SIGINT</font></font><font face="Times New Roman"><font size=+1>).</font></font>
<p><font face="Times New Roman"><font size=+1>Other routines you need to
supply are the following.</font></font>
<ul><font face="Courier New"><font size=+0>void</font><font size=-1> </font><font size=+0>exceptionHandler(int<i>exception_number</i>,void*<i>exception_address</i>)</font></font>
<ul><font face="Times New Roman"><font size=+1>Write this function to install
</font></font><i><font face="Courier New"><font size=+0>exception_address</font></font></i><font face="Times New Roman"><font size=+1>
in the exception handling tables.</font></font>
<br><font face="Times New Roman"><font size=+1>You need to do this because
the stub does not have any way of knowing what the exception handling tables
on your target system are like (for example, the processor’s table might
be in ROM, containing entries which point to a table in RAM). </font></font><i><font face="Courier New"><font size=+0>exception_number</font></font></i><font face="Times New Roman"><font size=+1>
is the exception number which should be changed; its meaning is architecture-dependent
(for example, different numbers might represent divide by zero, misaligned
access, etc). When this exception occurs, control should be transferred
directly to </font></font><i><font face="Courier New"><font size=+0>exception_address</font></font></i><font face="Times New Roman"><font size=+1>,
and the processor state (stack, registers, and so on) should be just as
it is when a processor exception occurs. So if you want to use a jump instruction
to reach </font></font><i><font face="Courier New"><font size=+0>exception_address</font></font></i><font face="Times New Roman"><font size=+1>,
it should be a simple jump, not a jump to subroutine.</font></font>
<br><font face="Times New Roman"><font size=+1>For the 386, </font></font><i><font face="Courier New"><font size=+0>exception_address</font></font></i><font face="Times New Roman"><font size=+1>
should be installed as an interrupt gate so that interrupts are masked
while the handler runs. The gate should be at privilege level 0 (the most
privileged level). The SPARC and 68k stubs are able to mask interrup themselves
without help from </font></font><font face="Courier New"><font size=+0>exceptionHandler</font></font><font face="Times New Roman"><font size=+1>.</font></font></ul>
<font face="Courier New"><font size=+0>void flush_i_cache()</font></font>
<ul><font face="Times New Roman"><font size=+1>(SPARC and SPARClite only)
Write this subroutine to flush the instruction cache, if any, on your target
machine. If there is no instruction cache, this subroutine may be a no-op.</font></font>
<br><font face="Times New Roman"><font size=+1>On target machines that
have instruction caches, GDB requires this function to make certain that
the state of your program is stable.</font></font></ul>
</ul>
<font face="Times New Roman"><font size=+1>You must also make sure the
following library routine is available.</font></font>
<ul><font face="Courier New"><font size=+0>void *memset(void *, int, int)</font></font>
<ul><font face="Times New Roman"><font size=+1>This is the standard library
function, </font></font><font face="Courier New"><font size=+0>memset</font></font><font face="Times New Roman"><font size=+1>,
which sets an area of memory to a known value. If you have one of the free
versions of </font></font><font face="Courier New"><font size=+0>libc.a</font></font><font face="Times New Roman"><font size=+1>,
</font></font><font face="Courier New"><font size=+0>memset</font></font><font face="Times New Roman"><font size=+1>
can be found there; otherwise, you must either obtain it from your hardware
manufacturer, or write your own.</font></font></ul>
</ul>
<font face="Times New Roman"><font size=+1>If you do not use the GNU C
compiler, you may need other standard library subroutines as well; this
varies from one stub to another, but in general the stubs are likely to
use any of the common library subroutines which </font></font><font face="Courier New"><font size=+0>gcc</font></font><font face="Times New Roman"><font size=+1>
generates as inline code.</font></font>
<p><a NAME="Putting_it_all_together"></a><b><i><font face="Times New Roman"><font size=+2>Putting
it all together</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>In summary, when your program
is ready to debug, you must use the following steps.</font></font>
<ul><font face="Arial"><font size=+1>1.</font></font>
<br><font face="Times New Roman"><font size=+1>Make sure you have the supporting
low-level routines (see <a href="#What_you_must_do_for_stub">What you must
do for the stub</a>): </font></font><font face="Courier New"><font size=+0>getDebugChar</font></font><font face="Times New Roman"><font size=+1>,
</font></font><font face="Courier New"><font size=+0>putDebugChar</font></font><font face="Times New Roman"><font size=+1>,
</font></font><font face="Courier New"><font size=+0>flush_i_cache</font></font><font face="Times New Roman"><font size=+1>,
</font></font><font face="Courier New"><font size=+0>memset</font></font><font face="Times New Roman"><font size=+1>,
</font></font><font face="Courier New"><font size=+0>exceptionHandler</font></font><font face="Times New Roman"><font size=+1>.</font></font>
<p><font face="Arial"><font size=+1>2.</font></font>
<br><font face="Times New Roman"><font size=+1>Insert these lines near
the top of your program:</font></font>
<ul><b><font face="Courier New"><font size=+0>set_debug_traps();</font></font></b>
<br><b><font face="Courier New"><font size=+0>breakpoint();</font></font></b></ul>
<font face="Arial"><font size=+1>3.</font></font>
<br><font face="Times New Roman"><font size=+1>For the 680x0 stub only,
you need to provide a variable called </font></font><font face="Courier New"><font size=+0>exceptionHook</font></font><font face="Times New Roman"><font size=+1>.
Normally you just use </font></font><font face="Courier New"><font size=+0>void
(*exceptionHook)() = 0;</font></font><font face="Times New Roman"><font size=+1>,
but if before calling </font></font><font face="Courier New"><font size=+0>set_debug_traps</font></font><font face="Times New Roman"><font size=+1>,
you set it to point to a function in your program, that function is called
when GDB continues after stopping on a trap (for example, bus error). The
function indicated by </font></font><font face="Courier New"><font size=+0>exceptionHook</font></font><font face="Times New Roman"><font size=+1>
is called with one parameter: an </font></font><font face="Courier New"><font size=+0>int</font></font><font face="Times New Roman"><font size=+1>
which is the exception number.</font></font>
<p><font face="Arial"><font size=+1>4.</font></font>
<br><font face="Times New Roman"><font size=+1>Compile and link together:
your program, the GDB debugging stub for your target architecture, and
the supporting subroutines.</font></font>
<p><font face="Arial"><font size=+1>5.</font></font>
<br><font face="Times New Roman"><font size=+1>Make sure you have a serial
connection between your target machine and the GDB host, and identify the
serial port on the host.</font></font>
<p><font face="Arial"><font size=+1>6.</font></font>
<br><font face="Times New Roman"><font size=+1>Download your program to
your target machine (or get it there by whatever means the manufacturer
provides), and start it.</font></font>
<p><font face="Arial"><font size=+1>7.</font></font>
<br><font face="Times New Roman"><font size=+1>To start remote debugging,
run GDB on the host machine, and specify as an executable file the program
that is running in the remote machine. This tells GDB how to find your
program’s symbols and the contents of its pure text.</font></font>
<br><font face="Times New Roman"><font size=+1>Then establish communication
using the </font></font><font face="Courier New"><font size=+0>target remote</font></font><font face="Times New Roman"><font size=+1>
command. Its argument specifies how to communicate with the target machine—either
via a devicename attached to a direct serial line, or a TCP port (usually
to a terminal server which in turn has a serial line to the target). For
example, to use a serial line connected to the device named ‘</font></font><font face="Courier New"><font size=+0>/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>’,
use </font></font><font face="Courier New"><font size=+0>target remote
/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>.</font></font>
<br><font face="Times New Roman"><font size=+1>To use a TCP connection,
use an argument of the form </font></font><font face="Courier New"><font size=+0><i>host</i>:port</font></font><font face="Times New Roman"><font size=+1>.
For example, to connect to port 2828 on a terminal server named </font></font><font face="Courier New"><font size=+0>manyfarms</font></font><font face="Times New Roman"><font size=+1>,
use </font></font><font face="Courier New"><font size=+0>target remote
manyfarms:2828</font></font><font face="Times New Roman"><font size=+1>.</font></font></ul>
<font face="Times New Roman"><font size=+1>Now you can use all the usual
commands to examine and change data and to step and continue the remote
program.</font></font>
<p><font face="Times New Roman"><font size=+1>To resume the remote program
and stop debugging it, use the </font></font><font face="Courier New"><font size=+0>detach</font></font><font face="Times New Roman"><font size=+1>
command.</font></font>
<p><font face="Times New Roman"><font size=+1>Whenever GDB is waiting for
the remote program, if you type the interrupt character (often, </font></font><b><font face="Arial"><font size=+0>Ctrl-C</font></font></b><font face="Times New Roman"><font size=+1>),
GDB attempts to stop the program. This may or may not succeed, depending
in part on the hardware and the serial drivers the remote system uses.
If you type the interrupt character once again, GDB displays the following
prompt:</font></font>
<ul><b><font face="Courier New"><font size=+0>Interrupted while waiting
for the program.</font></font></b>
<br><b><font face="Courier New"><font size=+0>Give up (and stop debugging
it)? (y or n)</font></font></b></ul>
<font face="Times New Roman"><font size=+1>If you type </font></font><font face="Courier New"><font size=+0>y</font></font><font face="Times New Roman"><font size=+1>,
GDB abandons the remote debugging session. (If you decide you want to try
again later, you can use </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1> again to
connect once more.) If you type </font></font><font face="Courier New"><font size=+0>n</font></font><font face="Times New Roman"><font size=+1>,
GDB goes back to waiting.</font></font>
<p><a NAME="Communication_protocol"></a><b><i><font face="Times New Roman"><font size=+2>Communication
protocol</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>The stub files provided with
GDB implement the target side of the communication protocol, and the GDB
side is implemented in the GDB source file ‘</font></font><font face="Courier New"><font size=+0>remote.c</font></font><font face="Times New Roman"><font size=+1>’.
Normally, you can simply allow these subroutines to communicate, and ignore
the details. (If you’re implementing your own stub file, you can still
ignore the details: start with one of the existing stub files. ‘</font></font><font face="Courier New"><font size=+0>sparc-stub.c</font></font><font face="Times New Roman"><font size=+1>’
is the best organized, and therefore the easiest to read.)</font></font>
<p><font face="Times New Roman"><font size=+1>However, there may be occasions
when you need to know something about the protocol—for example, if there
is only one serial port to your target machine, you might want your program
to do something special if it recognizes a packet meant for GDB.</font></font>
<p><font face="Times New Roman"><font size=+1>All GDB commands and responses
(other than acknowledgements, which are single characters) are sent as
a packet which includes a check-sum. A packet is introduced with the character,
‘</font></font><font face="Courier New"><font size=+0>$</font></font><font face="Times New Roman"><font size=+1>’,
and ends with the character, ‘</font></font><font face="Courier New"><font size=+0>#</font></font><font face="Times New Roman"><font size=+1>’,
followed by a two-digit checksum: </font></font><font face="Courier New"><font size=+0>$<i>packetinfo</i>#<i>checksum</i></font></font><font face="Times New Roman"><font size=+1>.</font></font>
<p><font size=+1><i><tt>checksum</tt></i><font face="Times New Roman">
is computed as the modulo 256 sum of the </font></font><i><font face="Courier New"><font size=+0>packetinfo
</font></font></i><font face="Times New Roman"><font size=+1>characters.</font></font>
<p><font face="Times New Roman"><font size=+1>When either the host or the
target machine receives a packet, the first response expected is an acknowledgement:
a single character, either ‘</font></font><font face="Courier New"><font size=+0>+</font></font><font face="Times New Roman"><font size=+1>’
(to indicate the package was received correctly) or ‘</font></font><font face="Courier New"><font size=+0>-</font></font><font face="Times New Roman"><font size=+1>’
(to request retransmission). The host (GDB) sends commands, and the target
(the debugging stub incorporated in your program) sends data in response.
The target also sends data when your program stops.</font></font>
<p><font face="Times New Roman"><font size=+1>Command packets are distinguished
by their first character, which identifies the kind of command.</font></font>
<p><font face="Times New Roman"><font size=+1>The following are some of
the commands currently supported (for a complete list of commands, look
in ‘</font></font><font face="Courier New"><font size=+0>gdb/remote.c.</font></font><font face="Times New Roman"><font size=+1>’):</font></font>
<br>&nbsp;
<ul><font face="Courier New"><font size=+0>g</font></font>
<ul><font face="Times New Roman"><font size=+1>Requests the values of CPU
registers.</font></font></ul>
<font face="Courier New"><font size=+0>G</font></font>
<ul><font face="Times New Roman"><font size=+1>Sets the values of CPU registers.</font></font></ul>
<font face="Courier New"><font size=+0>m<i>addr</i>,<i>count</i></font></font>
<ul><font face="Times New Roman"><font size=+1>Read countbytes at location,
</font></font><i><font face="Courier New"><font size=+0>addr</font></font></i><font face="Times New Roman"><font size=+1>.</font></font></ul>
<font face="Courier New"><font size=+0>M<i>addr</i>,<i>count</i>:...</font></font>
<ul><font face="Times New Roman"><font size=+1>Write </font></font><i><font face="Courier New"><font size=+0>count</font></font></i><font face="Times New Roman"><font size=+1>
bytes at location, </font></font><i><font face="Courier New"><font size=+0>addr</font></font></i><font face="Times New Roman"><font size=+1>.</font></font></ul>
<font face="Courier New"><font size=+0>c<i>c addr</i></font></font>
<ul><font face="Times New Roman"><font size=+1>Resume execution at the
current address (or at </font></font><i><font face="Courier New"><font size=+0>addr</font></font></i><font face="Times New Roman"><font size=+1>,
if supplied).</font></font></ul>
<font face="Courier New"><font size=+0>s <i>s addr</i></font></font>
<ul><font face="Times New Roman"><font size=+1>Step the target program
for one instruction, from either the current program counter or from </font></font><i><font face="Courier New"><font size=+0>addr</font></font></i><font face="Times New Roman"><font size=+1>,
if supplied.</font></font></ul>
<font face="Courier New"><font size=+0>k</font></font>
<ul><font face="Times New Roman"><font size=+1>Kill the target program.</font></font></ul>
<font face="Courier New"><font size=+0>?</font></font>
<ul><font face="Times New Roman"><font size=+1>Report the most recent signal.
To allow you to take advantage of the GDB signal handling commands, one
of the functions of the debugging stub is to report CPU traps as the corresponding
POSIX signal values.</font></font></ul>
<font face="Courier New"><font size=+0>T</font></font>
<ul><font face="Times New Roman"><font size=+1>Allows the remote stub to
send only the registers that GDB needs to make a quick decision about single-stepping
or conditional breakpoints. This eliminates the need to fetch the entire
register set for each instruction being stepped through.</font></font></ul>
</ul>
<font face="Times New Roman"><font size=+1>GDB now implements a write-through
cache for registers and only re-reads the registers if the target has run.</font></font>
<p><font face="Times New Roman"><font size=+1>If you have trouble with
the serial connection, you can use the command, </font></font><font face="Courier New"><font size=+0>set
remotedebug</font></font><font face="Times New Roman"><font size=+1>. This
makes GDB report on all packets sent back and forth across the serial line
to the remote machine. The packet-debugging information is printed on the
GDB standard output stream. </font></font><font face="Courier New"><font size=+0>set
remotedebug</font></font><font face="Times New Roman"><font size=+1> </font></font><font face="Courier New"><font size=+0>off</font></font><font face="Times New Roman"><font size=+1>
turns it off, and </font></font><font face="Courier New"><font size=+0>show
remotedebug</font></font><font face="Times New Roman"><font size=+1> shows
you its current state.</font></font>
<p><a NAME="Using_gdbserver"></a><b><i><font face="Times New Roman"><font size=+2>Using
the </font></font></i><font face="Courier New"><font point-size="18">gdbserver</font></font><i><font face="Times New Roman"><font size=+2>
program</font></font></i></b>
<p><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
is a control program for Unix-like systems, which allows you to connect
your program with a remote GDB via </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1>—but without
linking in the usual debugging stub.</font></font>
<p><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
is not a complete replacement for the debugging stubs, because it requires
essentially the same operating-system facilities that GDB itself does.
In fact, a system that can run </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
to connect to a remote GDB could also run GDB locally! </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
is sometimes useful nevertheless, because it is a much smaller program
than GDB itself. It is also easier to port than all of GDB, so you may
be able to get started more quickly on a new system by using </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>.
Finally, if you develop code for real-time systems, you may find that the
tradeoffs involved in real-time operation make it more convenient to do
as much development work as possible on another system, for example by
cross-compiling. You can use </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
to make a similar choice for debugging.</font></font>
<p><font face="Times New Roman"><font size=+1>GDB and </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
communicate via either a serial line or a TCP connection, using the standard
GDB remote serial protocol.</font></font>
<br>&nbsp;
<ul>
<ul>
<ul>
<li>
<b><i><font face="Times New Roman"><font size=+1>On the target machine</font></font></i></b></li>

<br><font face="Times New Roman"><font size=+1>You need to have a copy
of the program you want to debug. </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
does not need your program’s symbol table, so you can strip the program
if necessary to save space. GDB on the host system does all the symbol
handling. To use the server, you must tell it how to communicate with GDB;
the name of your program; and the arguments for your program. The syntax
has the following example's format.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>target> gdbserver <i>commprogram</i>
[<i>args</i>...]</font></font><font face="Times New Roman"><font size=+1>.</font></font></ul>
</ul>
<font face="Courier New"><font size=+0><i>comm</i> </font></font><font face="Times New Roman"><font size=+1>is
either a device name (to use a serial line) or a TCP hostname and portnumber.
For example, to debug Emacs with the argument, </font></font><font face="Courier New"><font size=+0>foo.txt</font></font><font face="Times New Roman"><font size=+1>,
and communicate with GDB over the serial port, </font></font><font face="Courier New"><font size=+0>/dev/com1</font></font><font face="Times New Roman"><font size=+1>,
use the following.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>target> gdbserver /dev/com1
emacs foo.txt.</font></font></ul>
</ul>
<font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
waits passively for the host GDB to communicate with it. To use a TCP connection
instead of a serial line, use the following.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>target> gdbserver host:2345
emacs foo.txt.</font></font></ul>
</ul>
<font face="Times New Roman"><font size=+1>The only difference from the
previous example is the first argument, specifying that you are communicating
with the host GDB via TCP. The ‘</font></font><font face="Courier New"><font size=+0>host:2345</font></font><font face="Times New Roman"><font size=+1>’
argument means that </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>is
to expect a TCP connection from machine ‘</font></font><font face="Courier New"><font size=+0>host</font></font><font face="Times New Roman"><font size=+1>’
to local TCP port 2345. (Currently, the ‘</font></font><font face="Courier New"><font size=+0>host</font></font><font face="Times New Roman"><font size=+1>’
part is ignored.) You can choose any number you want for the port number
as long as it does not conflict with any TCP ports already in use on the
target system (for example, </font></font><font face="Courier New"><font size=+0>23</font></font><font face="Times New Roman"><font size=+1>
is reserved for </font></font><font face="Courier New"><font size=+0>telnet</font></font><font face="Times New Roman"><font size=+1>).
If you choose a port number that conflicts with another service, </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
prints an error message and exits.</font></font>
<br><font face="Times New Roman"><font size=+1>You must use the same port
number with the host GDB </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1> command.</font></font></ul>

<ul>
<li>
<b><i><font face="Times New Roman"><font size=+1>On the GDB host machine</font></font></i></b></li>

<br><font face="Times New Roman"><font size=+1>You need an unstripped copy
of your program, since GDB needs symbols and debugging information.</font></font>
<br><font face="Times New Roman"><font size=+1>Start up GDB as usual, using
the name of the local copy of your program as the first argument. (You
may also need the ‘</font></font><font face="Courier New"><font size=+0>--baud</font></font><font face="Times New Roman"><font size=+1>’
option if the serial line is running at anything other than 9600 bps.)</font></font>
<br><font face="Times New Roman"><font size=+1>After that, use </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1> to establish
communications with </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>.</font></font>
<br><font face="Times New Roman"><font size=+1>Its argument is either a
device name (usually a serial device like </font></font><font face="Courier New"><font size=+0>/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>)
or a TCP port descriptor in the form, </font></font><font face="Courier New"><font size=+0><i>host</i>:<i>PORT</i></font></font><font face="Times New Roman"><font size=+1>.
For example, </font></font><font face="Courier New"><font size=+0>(gdb)
target remote /dev/ttyb</font></font><font face="Times New Roman"><font size=+1>
communicates with the server via serial line, </font></font><font face="Courier New"><font size=+0>/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>.</font></font>
<br><font face="Courier New"><font size=+0>target remote <i>the-target</i>:2345
</font></font><font face="Times New Roman"><font size=+1>communicates
via a TCP connection to port 2345 on host, </font></font><i><font face="Courier New"><font size=+0>the-target</font></font></i><font face="Times New Roman"><font size=+1>.
For TCP connections, you must start up </font></font><font face="Courier New"><font size=+0>gdbserver</font></font><font face="Times New Roman"><font size=+1>
prior to using the </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1> command.
Otherwise you may get an error whose text depends on the host system, but
which usually looks something like ‘</font></font><font face="Courier New"><font size=+0>Connection
refused</font></font><font face="Times New Roman"><font size=+1>’.</font></font></ul>
</ul>
</ul>
<a NAME="Using_gdbservnlm"></a><b><i><font face="Times New Roman"><font size=+2>Using
the </font></font></i><font face="Courier New"><font point-size="18">gdbserve.nlm</font></font><i><font face="Times New Roman"><font size=+2>
program</font></font></i></b>
<p><font face="Courier New"><font size=+0>gdbserve.nlm</font></font><font face="Times New Roman"><font size=+1>
is a control program for NetWare systems, which allows you to connect your
program with a remote GDB via </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1>.</font></font>
<p><font face="Times New Roman"><font size=+1>GDB and </font></font><font face="Courier New"><font size=+0>gdbserve.nlm</font></font><font face="Times New Roman"><font size=+1>
communicate via a serial line, using the standard GDB remote serial protocol.</font></font>
<ul>
<ul>
<ul>
<li>
<b><i><font face="Times New Roman"><font size=+1>On the target machine</font></font></i></b></li>

<br><font face="Times New Roman"><font size=+1>You need to have a copy
of the program you want to debug. </font></font><font face="Courier New"><font size=+0>gdbserve.nlm</font></font><font face="Times New Roman"><font size=+1>
does not need your program’s symbol table, so you can strip the program
if necessary to save space. GDB on the host system does all the symbol
handling. To use the server, you must tell it: how to communicate with
GDB, the name of your program, and the arguments for your program. The
syntax is the following.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>load gdbserve&nbsp;&nbsp;&nbsp;
[ BOARD=<i>board</i> ] [ PORT=<i>port</i> ]</font></font>
<br><font face="Courier New"><font size=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[ BAUD=<i>baud</i> ] <i>program</i> [ <i>args</i> ... ]</font></font></ul>
</ul>
<i><font face="Courier New"><font size=+0>board</font></font></i><font face="Times New Roman"><font size=+1>
and </font></font><i><font face="Courier New"><font size=+0>port</font></font></i><font face="Times New Roman"><font size=+1>
specify the serial line; </font></font><i><font face="Courier New"><font size=+0>baud</font></font></i><font face="Times New Roman"><font size=+1>
specifies the baud rate used by the connection. </font></font><i><font face="Courier New"><font size=+0>port</font></font></i><font face="Times New Roman"><font size=+1>
and </font></font><i><font face="Courier New"><font size=+0>node </font></font></i><font face="Times New Roman"><font size=+1>default
to 0, </font></font><i><font face="Courier New"><font size=+0>baud</font></font></i><font face="Times New Roman"><font size=+1>
defaults to 9600 bps. For example, to debug Emacs with the argument ‘</font></font><font face="Courier New"><font size=+0>foo.txt</font></font><font face="Times New Roman"><font size=+1>’and
communicate with GDB over serial port number 2 or board 1 using a 19200
bps connection, use the following.</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>load gdbserve BOARD=1 PORT=2
BAUD=19200 emacs foo.txt</font></font></ul>
</ul>

<li>
<b><i><font face="Times New Roman"><font size=+1>On the GDB host machine</font></font></i></b></li>

<br><font face="Times New Roman"><font size=+1>You need an unstripped copy
of your program, since GDB needs symbols and debugging information. Start
up GDB as usual, using the name of the local copy of your program as the
first argument. (You may also need the ‘</font></font><font face="Courier New"><font size=+0>--baud</font></font><font face="Times New Roman"><font size=+1>’
option if the serial line is running at anything other than 9600 bps.</font></font>
<p><font face="Times New Roman"><font size=+1>After that, use </font></font><font face="Courier New"><font size=+0>target
remote</font></font><font face="Times New Roman"><font size=+1> to establish
communications with </font></font><font face="Courier New"><font size=+0>gdbserve.nlm</font></font><font face="Times New Roman"><font size=+1>.
Its argument is a device name (usually a serial device, like </font></font><font face="Courier New"><font size=+0>/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>).
For example, </font></font><font face="Courier New"><font size=+0>(gdb)
target remote /dev/ttyb</font></font><font face="Times New Roman"><font size=+1>
communicates with the server via serial line, </font></font><font face="Courier New"><font size=+0>/dev/ttyb</font></font><font face="Times New Roman"><font size=+1>.</font></font></ul>
</ul>
</ul>
<a NAME="GDB_i960"></a><b><i><font face="Times New Roman"><font size=+2>GDB
with a remote i960 (Nindy)</font></font></i></b>
<p><font face="Times New Roman"><font size=+1><i>Nindy</i> is a ROM Monitor
program for Intel 960 target systems. When GDB is configured to control
a remote Intel 960 using Nindy, you can tell GDB how to connect to the
960 in the following ways:</font></font>
<ul>
<ul>
<ul>
<li>
<font face="Times New Roman"><font size=+1>Through command line options
specifying serial port, version of the Nindy protocol, and communications
speed;</font></font></li>

<li>
<font face="Times New Roman"><font size=+1>By responding to a prompt on
startup;</font></font></li>

<li>
<font face="Times New Roman"><font size=+1>By using the </font></font><font face="Courier New"><font size=+0>target</font></font><font face="Times New Roman"><font size=+1>
command at any point during your GDB session. See <font color="#008000"><a href="gdbCommands_for_managing_targets.html">Commands
for managing targets</a></font>.</font></font></li>
</ul>
</ul>
</ul>
<a NAME="Nindy_startup"></a><b><i><font face="Times New Roman"><font size=+2>Startup
with Nindy</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>If you simply start </font></font><font face="Courier New"><font size=+0>gdb</font></font><font face="Times New Roman"><font size=+1>
without using any command-line options, you are prompted for what serial
port to use, <i>before</i> you reach the ordinary GDB prompt:</font></font>
<ul>
<ul><font face="Courier New"><font size=+0>Attach /dev/ttyNN -- specify
NN, or "quit" to quit:</font></font></ul>
</ul>
<font face="Times New Roman"><font size=+1>Respond to the prompt with whatever
suffix (after </font></font><font face="Courier New"><font size=+0>/dev/tty</font></font><font face="Times New Roman"><font size=+1>)
identifies the serial port you want to use. You can, if you choose, simply
start up with no Nindy connection by responding to the prompt with an empty
line. If you do this and later wish to attach to Nindy, use </font></font><font face="Courier New"><font size=+0>target</font></font><font face="Times New Roman"><font size=+1>
(see <font color="#008000"><a href="gdbCommands_for_managing_targets.html">Commands
for managing targets</a></font>).</font></font>
<p><a NAME="Nindy_options"></a><b><i><font face="Times New Roman"><font size=+2>Options
for Nindy</font></font></i></b>
<p><font face="Times New Roman"><font size=+1>The following are the startup
options for beginning your GDB session with a Nindy-960 board attached.</font></font>
<br>&nbsp;
<ul><font face="Courier New"><font size=+0>-r<i>port</i></font></font>
<ul><font face="Times New Roman"><font size=+1>Specify the serial port
name of a serial interface to be used to connect to the target system.
This option is only available when GDB is configured for the Intel 960
target architecture. You may specify </font></font><i><font face="Courier New"><font size=+0>port</font></font></i><font face="Times New Roman"><font size=+1>
as any of: a full pathname (e.g., </font></font><font face="Courier New"><font size=+0>-r
/dev/ttya</font></font><font face="Times New Roman"><font size=+1>), a
device name in ‘</font></font><font face="Courier New"><font size=+0>/dev</font></font><font face="Times New Roman"><font size=+1>’
(e.g., </font></font><font face="Courier New"><font size=+0>-rttya</font></font><font face="Times New Roman"><font size=+1>),
or simply the unique suffix for a specific tty (e.g., </font></font><font face="Courier New"><font size=+0>-ra</font></font><font face="Times New Roman"><font size=+1>).</font></font></ul>
<font face="Courier New"><font size=+0>-O</font></font>
<ul><font face="Times New Roman"><font size=+1>(An uppercase letter “O”,
not a zero.) Specify that GDB should use the “old” Nindy monitor protocol
to connect to the target system. This option is only available when GDB
is configured for the Intel 960 target architecture.</font></font></ul>

<ul>
<ul><font face="Times New Roman"><font size=+1><b><i>Warning</i></b>:</font></font>
<br><font face="Times New Roman"><font size=+1>If you specify ‘</font></font><font face="Courier New"><font size=+0>-O</font></font><font face="Times New Roman"><font size=+1>’,
but are actually trying to connect to a target system that expects the
newer protocol, the connection fails, appearing to be a speed mismatch.
GDB repeatedly attempts to reconnect at several different line speeds.
You can abort this process with an interrupt.</font></font></ul>
</ul>
<font face="Courier New"><font size=+0>-brk</font></font>
<ul><font face="Times New Roman"><font size=+1>Specify that GDB should
first send a </font></font><font face="Courier New"><font size=+0>BREAK</font></font><font face="Times New Roman"><font size=+1>
signal to the target system, in an attempt to reset it, before connecting
to a Nindy target.</font></font></ul>

<ul>
<ul><font face="Times New Roman"><font size=+1><b><i>Warning</i></b>:</font></font>
<br><font face="Times New Roman"><font size=+1>Many target systems do not
have the hardware that this requires; it only works with a few boards.</font></font></ul>
</ul>

<ul><font face="Times New Roman"><font size=+1>The standard ‘</font></font><font face="Courier New"><font size=+0>-b</font></font><font face="Times New Roman"><font size=+1>’
option controls the line speed used on the serial port.</font></font></ul>
</ul>
<a NAME="Nindy_reset"></a><b><i><font face="Times New Roman"><font size=+2>Nindy
reset command</font></font></i></b>
<br>&nbsp;
<ul><font face="Courier New"><font size=+0>reset</font></font>
<ul><font face="Times New Roman"><font size=+1>For a Nindy target, this
command sends a “break” to the remote target system; this is only useful
if the target has been equipped with a circuit to perform a hard reset
(or some other interesting action) when a break is detected.</font></font></ul>
</ul>

<hr SIZE=3 WIDTH="100%">
<center><a href="#Top">Top</a>|<a href="gdb.html">Contents</a>|<a href="gdbindex.html">Index</a>|<a href="gdbRemote_debugging.html">Previous</a>|<a href="gdbThe_UDI_protocol_for_AMD29K.html">Next</a></center>

</body>
</html>
