<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>The Two Flavors of Variables</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeBasics_of_Variable_References.html">Previous</A>|<A HREF="makeAdvanced_Features_for_Reference_.html">Next</A>
<BR><A NAME="off_1147580"></A><A NAME="67583d2e"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>The
two flavors of variables</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>There
are two ways that a variable in gnu make can have a value; we call them
the two <I>flavors</I> of variables. The two flavors are distinguished
in how they are defined and in what they do when expanded.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The first flavor of variable
is a <I>recursively expanded</I> variable. Variables of this sort are defined
by lines using ‘=’ (see <FONT COLOR="#008000"><A HREF="makeSetting_Variables.html">Setting
variables</A></FONT>) or by the define directive (see <FONT COLOR="#008000"><A HREF="makeDefining_Variables_Verbatim.html">Defining
variables verbatim</A></FONT>). The value you specify is installed verbatim;
if it contains references to other variables, these references are expanded
whenever this variable is substituted (in the course of ex-panding some
other string). When this happens, it is called <I>recursive expansion</I>.
Consider the following example.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>foo = $(bar)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>bar = $(ugh)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>ugh = Huh?</FONT></FONT>

<P><FONT FACE="Courier New"><FONT SIZE=+0>all:;echo $(foo)</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This input will echo ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Huh?</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’;
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(foo)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(bar)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(ugh)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
which finally expands to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>Huh?</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This flavor of variable is
the only sort supported by other versions of </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>.
It has its advantages and its disadvantages. An advantage (most would say)
is that the following statement will do what was intended: when ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>CFLAGS</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is expanded in a command, it will expand to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>-Ifoo
-Ibar -O</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>CFLAGS = $(include_dirs) -O</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>include_dirs = -Ifoo -Ibar</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>A major disadvantage is that
you cannot append something on the end of a variable, as in </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>CFLAGS
= $(CFLAGS) -O</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
because it will cause an infinite loop in the variable expansion. (Actually
</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
detects the infinite loop and reports an error.)</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Another disadvantage is that
any functions referenced in the definition will be executed every time
the variable is expanded(see <FONT COLOR="#008000"><A HREF="makeFunctions_for_Transforming_Text.html">Functions
for transforming text</A></FONT>).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>This makes </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
run slower; worse, it causes the wildcard and shell functions to give unpredictable
results because you cannot easily control when they are called, or even
how many times.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>To avoid all the problems
and inconveniences of recursively expanded variables, there is another
flavor: <I>simply expanded variables</I>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1><I>Simply expanded variables</I>
are defined by lines using ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>:=</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
(see <FONT COLOR="#008000"><A HREF="makeSetting_Variables.html">Setting
variables</A></FONT>). The value of a simply expanded variable is scanned
once and for all, expanding any references to other variables and functions,
when the variable is defined.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The actual value of the simply
expanded variable is the result of expanding the text that you write.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>It does not contain any references
to other variables; it contains their values <I>as of the time this variable
was defined</I>.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Therefore, consider the following
statement.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>x :=foo</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>y := $(x) bar</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>x := later</FONT></FONT>
<BR>&nbsp;</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>This is equivalent to the next
statement.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>y := foo bar</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>x := later</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>When a simply expanded variable
is referenced, its value is substituted verbatim.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The following is a somewhat
more complicated example, illustrating the use of ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>:=</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
in conjunction with the shell function. See <FONT COLOR="#008000"><A HREF="makeThe_shell_Function.html">The
</A></FONT></FONT></FONT><FONT COLOR="#008000"><A HREF="makeThe_shell_Function.html"><B><FONT FACE="Courier New"><FONT SIZE=+0>shell</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
function</FONT></FONT></A></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
This example also shows use of the variable, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>MAKELEVEL</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
which is changed when it is passed down from level to level. (See <FONT COLOR="#008000"><A HREF="makeCommunicating_Variables_to_a_Sub.html">Communicating
variables to a sub-</A></FONT></FONT></FONT><B><FONT FACE="Courier New"><FONT COLOR="#008000"><FONT SIZE=+0><A HREF="makeCommunicating_Variables_to_a_Sub.html">make</A></FONT></FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
for information about </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>MAKELEVEL</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.)</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>ifeq (0,${MAKELEVEL})</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>cur-dir := $(shell pwd)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>whoami := $(shell whoami)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>host-type := $(shell arch)</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>MAKE := ${MAKE} host-type=${host-type}
whoami=${whoami}</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>endif</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>An advantage of this use
of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>:=</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is that a typical ‘descend into a directory’ command then looks like this:</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>${subdirs}:</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
${MAKE} cur-dir=${cur-dir}/$@ -C $@ all</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Simply expanded variables
generally make complicated makefile programming more predictable because
they work like variables in most programming languages. They allow you
to redefine a variable using its own value (or its value processed in some
way by one of the expansion functions) and to use the expansion functions
much more efficiently (see <FONT COLOR="#008000"><A HREF="makeFunctions_for_Transforming_Text.html">Functions
for transforming text</A></FONT>).</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>You can also use them to
introduce controlled leading whitespace into variable values. Leading whitespace
characters are discarded from your input before substitution of variable
references and function calls; this means you can include leading spaces
in a variable value by protecting them with variable references like the
following example’s input.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>nullstring :=</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>space := $(nullstring) # end
of the line</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>With this statement, the
value of the variable space is precisely one space.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The comment ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>#
end of the line</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is included here just for clarity. Since trailing space characters are
not stripped from variable values, just a space at the end of the line
would have the same effect (but be rather hard to read). If you put whitespace
at the end of a variable value, it is a good idea to put a comment like
that at the end of the line to make your intent clear.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Conversely, if you do <I>not</I>
want any whitespace characters at the end of your variable value, you must
remember <I>not</I> to put a random comment on the end of the line after
some whitespace, such as the following.</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>dir := /foo/bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# directory to put the frobs in</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>With this statement, the
value of the variable, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>,
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>/foo/bar</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
’ (with four trailing spaces), which was probably not the intention. (Imagine
something like ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(dir)/file</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
with this definition!)</FONT></FONT>
<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makeBasics_of_Variable_References.html">Previous</A>|<A HREF="makeAdvanced_Features_for_Reference_.html">Next</A></CENTER>

</BODY>
</HTML>
