<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Automatic Variables</TITLE>
</HEAD>
<BODY>
<A NAME="Top"></A><A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makePattern_Rule_Examples.html">Previous</A>|<A HREF="makeHow_Patterns_Match.html">Next</A>
<BR><A NAME="off_2195456"></A><A NAME="ad4b0e85"></A><B><FONT FACE="Futura Md BT"><FONT SIZE=+3>Automatic
variables</FONT></FONT></B>
<BR>
<HR SIZE=3 WIDTH="100%"><FONT FACE="Times New Roman"><FONT SIZE=+1>Suppose
you are writing a pattern rule to compile a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.c</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file into a ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.o</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
file: how do you write the ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>cc</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
command so that it operates on the right source file name? You cannot write
the name in the command, because the name is different each time the implicit
rule is applied. What you do is use a special feature of </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>,
the <I>automatic variables</I>. These variables have values computed afresh
for each rule that is executed, based on the target and dependencies of
the rule. By example, you would use ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
for the object file name and ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$&lt;</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
for the source file name.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The following is a list of
automatic variables.</FONT></FONT>
<BR>&nbsp;
<UL><B><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The file name of the target
of the rule. If the target is an archive member, then ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is the name of the archive file. In a pattern rule that has multiple targets
(see <FONT COLOR="#008000"><A HREF="makeIntroduction_to_Pattern_Rules.html">Introduction
to pattern rules</A></FONT>), ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is the name of whichever target caused the rule’s commands to be run.</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$%</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The target member name,
when the target is an archive member. See <FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html">Using
</A></FONT></FONT></FONT><FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html"><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
to update archive files</FONT></FONT></A></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
For example, if the target is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.a(bar.o)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
then ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$%</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>bar.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.a</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$%</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is empty when the target is not an archive member.</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$&lt;</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The name of the first dependency.
If the target got its commands from an implicit rule, this will be the
first dependency added by the implicit rule (see <FONT COLOR="#008000"><A HREF="makeUsing_Implicit_Rules.html">Using
implicit rules</A></FONT>).</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$?</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The names of all the dependencies
that are newer than the target, with spaces between them. For dependencies
which are archive members, only the member named is used (see <FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html">Using
</A></FONT></FONT></FONT><FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html"><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
to update archive files</FONT></FONT></A></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>).</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$ˆ</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The names of all the dependencies,
with spaces between them. For dependencies which are archive members, only
the member named is used (<FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html">Using
</A></FONT></FONT></FONT><FONT COLOR="#008000"><A HREF="makeUsing_make_to_Update_Archive_Fil.html"><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
to update archive files</FONT></FONT></A></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>).
A target has only one dependency on each other file it depends on, no matter
how many times each file is listed as a dependency. So if you list a dependency
more than once for a target, the value of ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$ˆ</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
contains just one copy of the name.</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$+</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>This is like ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$ˆ</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
but dependencies listed more than once are duplicated in the order they
were listed in the makefile. This is primarily useful for use in linking
commands where it is meaningful to repeat library file names in a particular
order.</FONT></FONT></UL>


<P><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The stem with which an implicit
rule matches (see <FONT COLOR="#008000"><A HREF="makeHow_Patterns_Match.html">How
patterns match</A></FONT>). If the target is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir/a.foo.b</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and the target pattern is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>a.<B>%</B>.b</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
then the stem is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir/foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
The stem is useful for constructing names of related files.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>In a static pattern rule,
the stem is part of the file name that matched the ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>%</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
in the target pattern.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>In an explicit rule, there
is no stem; so ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
cannot be deter-mined in that way. Instead, if the target name ends with
a recognized suffix (see <FONT COLOR="#008000"><A HREF="makeOldFashioned_Suffix_Rules.html">Old-fashioned
suffix rules</A></FONT>), ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is set to the target name minus the suffix. For example, if the target
name is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.c</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
then ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is set to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
since ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>.c</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is a suffix. gnu make does this bizarre thing only for compatibility with
other implementations of make. You should generally avoid using ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
except in implicit rules or static pattern rules.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>If the target name in an
explicit rule does not end with a recognized suffix, ‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$*</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is set to the empty string for that rule.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>$?</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is useful even in explicit rules when you wish to operate on only the dependencies
that have changed. For example, suppose that an archive named ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>lib</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is supposed to contain copies of several object files. This rule copies
just the changed object files into the archive:</FONT></FONT>
<BR>&nbsp;
<UL><FONT FACE="Courier New"><FONT SIZE=+0>lib: foo.o bar.o lose.o win.o</FONT></FONT>
<BR><FONT FACE="Courier New"><FONT SIZE=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ar r lib $?</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>Of the variables previously
listed, four have values that are single file names, and two have values
that are lists of file names. These six have variants that get just the
file’s directory name or just the file name within the directory.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>The variant variables’ names
are formed by appending ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>D</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
or ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>F</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’,
respectively. These variants are semi-obsolete in GNU </FONT></FONT><B><FONT FACE="Courier New"><FONT SIZE=+0>make</FONT></FONT></B><FONT FACE="Times New Roman"><FONT SIZE=+1>
since the functions </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>notdir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
can be used to get a similar effect (see <FONT COLOR="#008000"><A HREF="makeFunctions_for_File_Names.html">Functions
for file names</A></FONT>). Note, however, that the ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>F</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
variants all omit the trailing slash which always appears in the output
of the </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
function.</FONT></FONT></UL>
&nbsp;</UL>
<FONT FACE="Times New Roman"><FONT SIZE=+1>The following is a list of the
variants.</FONT></FONT>
<UL>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(@D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The directory part of the
file name of the target, with the trailing slash removed. If the value
of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir/foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
then ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(@D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
This value is ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>.</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
if ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
does not contain a slash.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(@F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The file-within-directory
part of the file name of the target. If the value of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$@</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir/foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
then ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(@F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo.o</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(@F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
is equivalent to ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(notdir
$@)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(*D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(*F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The directory part and the
file-within-directory part of the stem; ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>dir</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>foo</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
in this instance.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(%D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(%F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The directory part and the
file-within-directory part of the target archive member name. This makes
sense only for archive member targets of the form ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0><I>archive</I>(<I>member</I>)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
and is useful only when member may contain a directory name. (See <FONT COLOR="#008000"><A HREF="makeArchive_Members_as_Targets.html">Archive
members as targets</A></FONT>.)</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(&lt;D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(&lt;F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>The directory part and the
file-within-directory part of the first dependency.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(ˆD)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(ˆF)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Lists of the directory parts
and the file-within-directory parts of all dependencies.</FONT></FONT></UL>


<P><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(?D)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<BR><FONT FACE="Times New Roman"><FONT SIZE=+1>‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(?F)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’</FONT></FONT>
<UL><FONT FACE="Times New Roman"><FONT SIZE=+1>Lists of the directory parts
and the file-within-directory parts of all dependencies that are newer
than the target.</FONT></FONT>

<P><FONT FACE="Times New Roman"><FONT SIZE=+1>We use a special stylistic
convention when we discuss these automatic variables; we write “the value
of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$&lt;</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’”,
rather than “the variable, </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>&lt;</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>”
as we would write for ordinary variables such as </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>objects</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>
and </FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>CFLAGS</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>.
We think this convention looks more natural in this special case. Do not
assume it has a deep significance; ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$&lt;</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
refers to the variable named ‘&lt;’ just as ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(CFLAGS)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
refers to the variable named ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>CFLAGS</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.
You could just as well use ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$(&lt;)</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’
in place of ‘</FONT></FONT><FONT FACE="Courier New"><FONT SIZE=+0>$&lt;</FONT></FONT><FONT FACE="Times New Roman"><FONT SIZE=+1>’.</FONT></FONT></UL>
</UL>

<CENTER>
<HR SIZE=3 WIDTH="100%"></CENTER>

<CENTER><A HREF="#Top">Top</A>|<A HREF="make.html">Contents</A>|<A HREF="makeindex.html">Index</A>|<A HREF="makePattern_Rule_Examples.html">Previous</A>|<A HREF="makeHow_Patterns_Match.html">Next</A></CENTER>

</BODY>
</HTML>
